--- File: .env.example ---
ANTHROPIC_API_KEY=
GROQ_API_KEY=
OPENAI_API_KEY=
OPENROUTER_API_KEY=

TWITTER_USERNAME=
TWITTER_PASSWORD=
TWITTER_EMAIL=

STARKNET_RPC_URL=
STARKNET_ADDRESS=
STARKNET_PRIVATE_KEY=

# This is the current GraphQL to make the examples work
GRAPHQL_URL=https://api.cartridge.gg/x/sepolia-rc-18/torii

DRY_RUN=1

# Discord Bot Token (https://discord.com/developers/applications)
# Required Gateway Intents: Server Members, Message Content, Presence
DISCORD_TOKEN=

# Telegram Configuration
# TELEGRAM_STARTUP_CHAT_ID: Chat ID where startup notifications will be sent
TELEGRAM_STARTUP_CHAT_ID=

# GramJS Configuration (required for both bot and user clients)
# TELEGRAM_TOKEN: Bot token from @BotFather (required for bot mode)
TELEGRAM_TOKEN=

# Get these from https://my.telegram.org/apps
TELEGRAM_API_ID=
TELEGRAM_API_HASH=

# Optional: Session string for user authentication
# After first successful interactive login, the app will provide a session string
# Save it here to avoid interactive login in subsequent runs
TELEGRAM_USER_SESSION=

# Hyperliquid Trading Configuration
# HYPERLIQUID_MAIN_ADDRESS: Your main Hyperliquid address (format: 0x...)
# HYPERLIQUID_WALLET_ADDRESS: Your wallet address for trading (format: 0x...)
# HYPERLIQUID_PRIVATE_KEY: Your private key (Keep this secure!)
HYPERLIQUID_MAIN_ADDRESS=
HYPERLIQUID_WALLET_ADDRESS=
HYPERLIQUID_PRIVATE_KEY=

SUI_PRIVATE_KEY= # Sui Mnemonic Seed Phrase (`sui keytool generate ed25519`) , Also support `suiprivatekeyxxxx` (sui keytool export --key-identity 0x63)
SUI_NETWORK=mainnet   # must be one of mainnet, testnet, devnet, localnet

COMPOSIO_API_KEY=

--- End File: .env.example ---

--- File: docs/content/docs/advanced/extensions-vs-services.mdx ---
---
title: Extensions vs Services
description:
  Understanding the difference between extensions and services in Daydreams.
---

## Overview

The Daydreams framework uses both Services and Extensions as core architectural
components, but they serve different purposes. Let's explore the differences:

## Service (Provider)

Services are primarily focused on **Dependency Injection (DI) and Lifecycle
Management** for specific functionality, often managing external clients or
shared utilities.

- **Definition:** Created using `service({...})`
- **Key Methods:**
  - `register(container)`: Adds instances or factories to the DI container. This
    runs _before_ booting.
  - `boot(container)`: Performs asynchronous initialization after all services
    have been registered. This runs during `agent.start()`.
- **Role:** Manages _how_ a dependency is created, configured, initialized, and
  made available via the `container`.
- **Analogy:** Think of a service provider as the **blueprint and setup
  instructions** for a specific tool or utility.

## Extension

Extensions act as **modular packages or bundles** that group related Daydreams
features together for easy integration into an agent.

- **Definition:** Created using `extension({...})`
- **Contents:**
  - `name` (required): Unique identifier
  - `services`: Array of Service Provider definitions this extension requires
  - `contexts`: Definitions for specific Context types
  - `actions`: Action definitions
  - `inputs`: Input definitions
  - `outputs`: Output definitions
  - `events`: Zod schemas for events the extension might emit
  - `install(agent)`: Optional hook that runs once when the extension is added
    during `agent.start()`
- **Role:** Organizes and encapsulates a set of related functionalities and
  declares the services those functionalities need.
- **Analogy:** Think of an extension as a **toolbox** for a specific domain
  (e.g., a "Discord Toolbox").

## Key Differences

| Feature           | Service (Provider)                     | Extension                                                               |
| :---------------- | :------------------------------------- | :---------------------------------------------------------------------- |
| **Primary Focus** | Dependency Injection & Lifecycle       | Bundling & Organizing Features                                          |
| **Defined By**    | `service({...})`                       | `extension({...})`                                                      |
| **Contains**      | `register`, `boot` methods             | `actions`, `contexts`, `inputs`, `outputs`, `services`, `install`, etc. |
| **Purpose**       | Manages _how_ a dependency is provided | Packages _what_ features are provided                                   |
| **Relationship**  | Often **included within** an Extension | **Uses** Services to manage its dependencies                            |

## In Simple Terms

- You define a `service` to tell the system _how_ to create and initialize
  something like an API client.
- You define an `extension` to bundle together all the `actions`, `contexts`,
  `inputs`, and `outputs` related to a feature, and you list the `services` that
  those features depend on.

When you add an `extension` to your agent via `createDreams`, the framework
automatically registers the `services` listed within that extension, making them
available via the `container` for the extension's components to use.

--- End File: docs/content/docs/advanced/extensions-vs-services.mdx ---

--- File: docs/content/docs/advanced/extensions.mdx ---
---
title: Extensions
description: Building your own modular Daydreams extensions.
---

Extensions are the primary mechanism for packaging and distributing reusable
Daydreams functionality. They bundle together contexts, actions, inputs,
outputs, and the service providers they depend on.

## Purpose

- **Encapsulate Features:** Group all related components for a specific
  capability (e.g., Discord integration, ChromaDB support, a custom game
  interface).
- **Simplify Agent Configuration:** Add complex features to an agent by simply
  including the extension in the `createDreams` configuration.
- **Promote Code Reuse:** Share common functionalities across different agents.

## Defining an Extension

Use the `extension` helper function exported from `@daydreamsai/core`:

```typescript
import {
  extension,
  context,
  action,
  input,
  output,
  service,
  type AnyAgent, // Import necessary types
} from "@daydreamsai/core";
import { z } from "zod";

// Assume necessary components like myApiService, myFeatureContext, etc. are defined elsewhere
declare const myApiService: any;
declare const myFeatureContext: any;
declare const myFeatureAction: any;

export const myExtension = extension({
  // Required: A unique name for the extension
  name: "my-feature",

  // Optional: Service providers required by this extension's components.
  // These services will be registered and booted automatically.
  services: [myApiService],

  // Optional: Context definitions provided by this extension.
  // These become available for use with agent.run() / agent.send().
  contexts: {
    myFeature: myFeatureContext,
  },

  // Optional: Action definitions provided by this extension.
  // These become available for the LLM to call.
  actions: [myFeatureAction],

  // Optional: Input definitions provided by this extension.
  // Their 'subscribe' methods will be called on agent.start().
  inputs: {
    "my-feature:event": input({
      /* ... input definition ... */
      subscribe: (send, agent) => {
        /* ... listen and call send() ... */
      },
    }),
  },

  // Optional: Output definitions provided by this extension.
  // These become available for the LLM to use in <output> tags.
  outputs: {
    "my-feature:notify": output({
      /* ... output definition ... */
      handler: (data, ctx, agent) => {
        /* ... send notification ... */
      },
    }),
  },

  // Optional: Events defined by this extension (primarily for typing ctx.emit).
  events: {
    myEvent: z.object({ id: z.string() }),
  },

  // Optional: Logic to run once when the extension is added during agent.start().
  // Useful for one-time setup that doesn't fit the service 'boot' lifecycle.
  async install(agent: AnyAgent) {
    console.log("Installing My Feature Extension!");
    // Example: agent.container.resolve('logger').info(...)
  },
});
```

## Usage and Lifecycle

1.  **Configuration:** Pass your extension instances to `createDreams` in the
    `extensions` array:

    ```typescript
    import { createDreams } from "@daydreamsai/core";
    import { myExtension } from "./my-extension";
    import { discord } from "@daydreamsai/discord"; // Example built-in

    const agent = createDreams({
      model: /* ... */,
      extensions: [
        myExtension,
        discord, // Add other extensions
      ],
      // ... other agent config
    });
    ```

2.  **Merging:** When `createDreams` initializes, it iterates through the
    `extensions` array. For each extension, it merges the defined `contexts`,
    `actions`, `inputs`, `outputs`, and `events` into the agent's central
    registries, making them available for use.
3.  **Service Registration:** It automatically registers all `services` listed
    within each extension with the agent's `ServiceManager`.
4.  **Installation & Booting:** When `agent.start()` is called:
    - The `install` method of each extension is executed (if defined).
    - The `ServiceManager` boots all registered services (calling their `boot`
      methods, ensuring dependencies are ready).
    - Input `subscribe` methods are called to start listening for external
      events.

Extensions provide a powerful and organized way to structure agent capabilities,
making it easy to combine built-in features with your own custom logic and
integrations.

--- End File: docs/content/docs/advanced/extensions.mdx ---

--- File: docs/content/docs/advanced/grpo-training-export.mdx ---
---
title: Training Data Export for GRPO
description:
  This guide explains how to export episodic memories as training data for Group
  Relative Policy Optimization (GRPO) using the Daydreams AI core package.
---

## What is GRPO Training?

GRPO (Group Relative Policy Optimization) is a reinforcement learning algorithm
designed to enhance reasoning capabilities in large language models. It
optimizes memory usage and is particularly effective for tasks requiring complex
problem-solving, such as:

- Mathematical reasoning
- Decision-making scenarios
- Step-by-step problem solving
- Game-based learning environments

**Key Benefits of GRPO:**

- Improves reasoning capabilities beyond standard fine-tuning
- Optimizes memory usage compared to traditional PPO
- Particularly effective for complex problem-solving tasks

## Workflow Overview

Your Daydreams agent can build reasoning traces for GRPO training by following
this structured workflow:

1. **Define Prompt Sources** - Use static datasets or interactive environments
2. **Generate Reasoning Traces** - Create completions that include thought
   processes
3. **Store and Save Data** - Export in JSONL format compatible with training
   tools

## Enabling Automatic Export

You can configure Daydreams to automatically export training data after each
episode:

```typescript
import { createDreams } from "@daydreamsai/core";

const agent = createDreams({
  model: openai("gpt-4-turbo"),
  exportTrainingData: true,
  trainingDataPath: "./grpo-training-data.jsonl", // Optional, defaults to "./training-data.jsonl"
  // ... other configuration options
});
```

**Note:** If you don't specify `trainingDataPath`, Daydreams will save the data
to `./training-data.jsonl` in your project root.

## Manual Export

You can manually export all episodes as training data:

```typescript
// Export using the default path from your agent configuration
await agent.exportAllTrainingData();

// Or specify a custom path
await agent.exportAllTrainingData("./custom-path/grpo-training-data.jsonl");
```

## Understanding the Data Format for GRPO

Daydreams exports training data in JSONL (JSON Lines) format, optimized for GRPO
training. Each line contains a JSON object with:

```json
{
  "prompt": "You are in a dark room with a door to the north.",
  "completion": "I need to find a way out. I should check if the door is locked.\n\nI found the door was unlocked and was able to exit the room."
}
```

The format includes:

- **prompt**: The observation or context provided to the agent
- **completion**: The agent's reasoning process and action results

For interactive environments, ensure completions include both reasoning and an
explicit action statement:

```json
{
  "prompt": "You are in a dark room with a door to the north.",
  "completion": "I need to find a way out. I should check if the door is locked.\n\nAction: try opening the door"
}
```

## Creating Custom Training Pairs for GRPO

For advanced use cases, you can create custom training data pairs specifically
designed for GRPO:

## Optimizing Data for GRPO Training

To maximize the effectiveness of your GRPO training data:

1. **Include diverse scenarios** - Ensure your agent encounters a variety of
   situations
2. **Capture step-by-step reasoning** - The completion should show the agent's
   thought process
3. **Format actions consistently** - Use patterns like "Action: [action]" for
   easy parsing
4. **Balance task difficulty** - Include both simple and complex reasoning
   challenges

## Customizing the Export Format

If you need a different format for your specific GRPO training framework:

1. Create your own formatter function based on the Daydreams utilities
2. Process the episodic memories to match your required format
3. Save the data using your preferred file structure

**Example use case:** You might need to add additional metadata fields like task
difficulty or domain type to help with training organization.

--- End File: docs/content/docs/advanced/grpo-training-export.mdx ---

--- File: docs/content/docs/advanced/introduction.mdx ---
---
title: Introduction
description: Deeper dives into Daydreams capabilities.
---

This section serves as an exploration of the more conceptually difficult aspects
surrounding Daydreams, as well as a collection of projects demonstrating such
niche usage.

- **[Custom Extensions](/docs/advanced/extensions):** Learn how to bundle your
  own contexts, actions, services, and more into reusable extensions.

- **[Services](/docs/advanced/services):** Understand the dependency injection
  container and service provider pattern for managing dependencies and component
  lifecycles.

- **[GRPO Training Data Export](/docs/advanced/grpo-training-export):** Discover
  how to export agent interaction data for advanced model training techniques
  like Group Relative Policy Optimization.

- **[Extensions versus Services](/docs/advanced/extensions-vs-services):** Where
  and when to use services, extensions, and why.

> 💭 **WIP**: Some sections or mentions here may be nascent explorations of the
> framework's potential.

For those truly pushing the envelope, solving the hardest problems, we want your
work to be seen. If we haven't seen you yet, the best place to find us is
Discord and X.

Dreaming.

--- End File: docs/content/docs/advanced/introduction.mdx ---

--- File: docs/content/docs/advanced/meta.json ---
{
  "pages": [
    "introduction",
    "extensions-vs-services",
    "extensions",
    "services",
    "grpo-training-export"
  ]
}

--- End File: docs/content/docs/advanced/meta.json ---

--- File: docs/content/docs/advanced/services.mdx ---
---
title: Services
description: Dependency Injection & Lifecycle Management.
---

Daydreams utilizes a Dependency Injection (DI) container and a Service Provider
pattern to manage dependencies and component lifecycles effectively.

## Dependency Injection (`container.ts`)

At the heart of the framework's modularity is a simple Dependency Injection
container, created using `createContainer()`. The container is responsible for
instantiating and providing access to various services and components throughout
the agent's lifecycle.

**Purpose:**

- Decouples components by removing the need for them to know how to create their
  dependencies.
- Manages the lifecycle of services (e.g., ensuring only one instance of a
  database client exists).
- Makes components like loggers, clients, or configuration easily accessible.

**Core Methods:**

- `container.register(token, factory)`: Registers a factory function. A _new
  instance_ is created every time `resolve` is called for the `token`.
- `container.singleton(token, factory)`: Registers a factory function, but the
  instance is created _only once_ on the first `resolve` call. Subsequent calls
  return the same instance.
- `container.instance(token, value)`: Registers a pre-existing object instance
  directly.
- `container.resolve<Type>(token)`: Retrieves the instance associated with the
  `token`. Throws an error if the token is not registered.
- `container.alias(aliasToken, originalToken)`: Creates an alternative name
  (`aliasToken`) to resolve an existing `originalToken`.

```typescript
import { createContainer, Logger, LogLevel } from "@daydreamsai/core"; // Assuming Logger/LogLevel are exported

// Assume DatabaseClient exists
declare class DatabaseClient {
  constructor(uri: string | undefined);
}

const container = createContainer();

// Register a singleton database client
container.singleton("dbClient", () => new DatabaseClient(process.env.DB_URI));

// Register a pre-created config object
const config = { apiKey: "123" };
container.instance("appConfig", config);

// Register a transient logger (new instance each time)
container.register(
  "requestLogger",
  () => new Logger({ level: LogLevel.DEBUG })
);

// Resolve dependencies
const db = container.resolve<DatabaseClient>("dbClient");
const cfg = container.resolve<typeof config>("appConfig");
const logger1 = container.resolve<Logger>("requestLogger");
const logger2 = container.resolve<Logger>("requestLogger"); // Different instance from logger1
```

The main `Agent` instance, `Logger`, `TaskRunner`, and other core components are
typically registered within the container when `createDreams` is called.

## Service Providers (`serviceProvider.ts`)

While you could register everything directly with the container, Daydreams uses
a Service Provider pattern to organize the registration and initialization
(booting) of related services, especially within extensions.

**Purpose:**

- Groups related service registrations.
- Provides a dedicated `boot` phase for initialization logic that might depend
  on other services already being registered (e.g., connecting a client after
  its configuration is registered).

**Defining a Service Provider:**

Use the `service` helper function:

```typescript
import { service, type Container } from "@daydreamsai/core";

// Assume MyApiClient exists and has a connect method
declare class MyApiClient {
  constructor(config: { baseUrl: string | undefined });
  connect(): Promise<void>;
}

const myApiService = service({
  // Optional: Register dependencies into the container.
  // Runs before the boot phase.
  register(container: Container) {
    container.singleton("apiConfig", () => ({ baseUrl: process.env.API_URL }));
    container.singleton(
      "apiClient",
      (c) => new MyApiClient(c.resolve("apiConfig"))
    );
  },

  // Optional: Perform initialization logic after registration.
  // Runs during agent.start() after all services are registered.
  async boot(container: Container) {
    const apiClient = container.resolve<MyApiClient>("apiClient");
    await apiClient.connect(); // Example: Connect the client
    console.log("My API Client Connected!");
  },
});
```

**Lifecycle:**

1.  **Registration:** When a service provider is added to the agent (usually via
    an extension), its `register` method is called immediately by the
    `ServiceManager` (created internally in `createDreams`).
2.  **Booting:** When `agent.start()` is called, the `ServiceManager` iterates
    through all registered service providers and calls their `boot` methods
    _after_ all `register` methods have completed.

Services and the DI container form the backbone for managing dependencies and
initializing components within Daydreams agents and extensions.

--- End File: docs/content/docs/advanced/services.mdx ---

--- File: docs/content/docs/concepts/actions.mdx ---
---
title: Actions
description: Define capabilities and interactions for your Daydreams agent.
---

Actions are the primary way Daydreams agents perform tasks, interact with
external systems (like APIs or databases), and modify their own state. They are
essentially functions that the agent's underlying Large Language Model (LLM) can
choose to call based on its reasoning and the current situation.

Think of actions as the tools or capabilities you give your agent.

## Defining an Action

You define actions using the `action` helper function from `@daydreamsai/core`.
Here's the essential structure:

```typescript
import {
  action,
  type ActionCallContext,
  type AnyAgent,
} from "@daydreamsai/core";
import { z } from "zod";

// Define the structure for the action's arguments using Zod
const searchSchema = z.object({
  query: z.string().describe("The specific search term or question"),
  limit: z
    .number()
    .optional()
    .default(10)
    .describe("Maximum number of results to return"),
});

// Define the action itself
export const searchDatabaseAction = action({
  // Required: A unique name used by the LLM to call this action.
  // Use clear, descriptive names (e.g., verbNoun).
  name: "searchDatabase",

  // Required: A clear description explaining what the action does.
  // This is crucial for the LLM to understand *when* to use this action.
  description:
    "Searches the company knowledge base for records matching the query.",

  // Optional (but highly recommended): A Zod schema defining the expected arguments.
  // The framework automatically validates arguments provided by the LLM against this schema.
  // Use `.describe()` on fields to provide hints to the LLM.
  schema: searchSchema,

  // Required: The function that executes the action's logic.
  // It receives validated arguments, context information, and the agent instance.
  async handler(args, ctx, agent) {
    // 'args': The validated arguments object, matching the 'schema'.
    // Type is automatically inferred: { query: string; limit: number }
    const { query, limit } = args;

    // 'ctx': The ActionCallContext, providing access to memory, signals, etc.
    // 'agent': The main agent instance, for accessing services, logger, etc.

    agent.logger.info(
      "searchDatabase",
      `Searching for: "${query}" (limit: ${limit})`
    );

    try {
      // --- Perform the action's logic ---
      // Example: Use a service resolved from the agent's container
      // const db = agent.container.resolve<MyDatabaseClient>('database');
      // const results = await db.search(query, { limit });

      // Simulate an async database call
      await new Promise((resolve) => setTimeout(resolve, 100));
      const results = [
        { id: "doc1", title: `Result for ${query}` },
        { id: "doc2", title: `Another result for ${query}` },
      ].slice(0, limit);
      // --- End of action logic ---

      // Return a structured result. This is logged and becomes available
      // to the LLM in subsequent reasoning steps.
      return {
        success: true,
        count: results.length,
        results: results,
        message: `Found ${results.length} results for "${query}".`,
      };
    } catch (error) {
      agent.logger.error("searchDatabase", "Search failed", { query, error });
      // Return an error structure if the action fails
      return {
        success: false,
        error:
          error instanceof Error ? error.message : "Unknown database error",
        message: `Failed to search database for "${query}".`,
      };
    }
  },
});

// Type definition for the ActionCallContext if needed elsewhere
type SearchDbContext = ActionCallContext<typeof searchSchema>;
```

## Working with Action Arguments (`args`)

The `handler` function receives the action's arguments in the first parameter
(`args`). These arguments have already been:

1.  Generated by the LLM based on your action's `schema`.
2.  Parsed and **validated** by the framework against your `schema`.

You can directly use the properties defined in your schema within the handler,
with type safety if using TypeScript.

## Managing State (`ctx.memory`)

Actions often need to read or modify the persistent state associated with the
**current context instance** (e.g., the specific chat session or project the
agent is working on). You access this state via `ctx.memory`.

```typescript
import {
  action,
  type ActionCallContext,
  type AnyAgent,
} from "@daydreamsai/core";
import { z } from "zod";

// Define the expected structure of the context's memory
interface TaskListMemory {
  tasks?: { id: string; title: string; status: "pending" | "completed" }[];
}

// Assume myContext is defined elsewhere and uses TaskListMemory

export const addTaskAction = action({
  name: "addTask",
  description: "Adds a new task to the current project's task list.",
  schema: z.object({
    title: z.string().describe("The title of the new task"),
  }),
  handler(args, ctx: ActionCallContext<any, any, TaskListMemory>, agent) {
    // Access the persistent memory for THIS context instance.
    const contextMemory = ctx.memory;

    // Initialize the tasks array if it doesn't exist
    if (!Array.isArray(contextMemory.tasks)) {
      contextMemory.tasks = [];
    }

    const newTask = {
      id: agent.utils.randomUUIDv7(), // Generate a unique ID
      title: args.title,
      status: "pending" as const,
    };

    // --- Modify the context's state ---
    contextMemory.tasks.push(newTask);
    // --- State modification ends ---

    // The changes to ctx.memory are automatically saved
    // by the framework at the end of the run cycle.

    agent.logger.info("addTask", `Added task: ${newTask.title}`);

    return {
      success: true,
      taskId: newTask.id,
      message: `Task "${newTask.title}" added successfully.`,
    };
  },
});
```

**Important Memory Scopes in `ctx`:**

- `ctx.memory`: (Most commonly used) Persistent memory for the **current context
  instance**. Use this for state related to the specific chat, project, game,
  etc.
- `ctx.actionMemory`: (Less common) Persistent memory tied to the **action
  definition itself**, across all contexts. Configure via the `memory` option in
  `action()`. Useful for action-specific counters, rate limits, etc.
- `ctx.agentMemory`: Persistent memory for the **main agent context** (if one
  was defined globally). Use for global agent settings or state.

Always choose the memory scope that matches where your state needs to live.

## Associating Actions with Contexts

While you can define actions globally when calling `createDreams`, it's often
more organized and efficient to associate actions directly with the `Context`
they primarily relate to. This makes the action available _only_ when that
specific context is active and ensures the action handler has direct, typed
access to that context's memory.

There are two ways to associate actions with a context definition:

**1. Using the `actions` property:**

```typescript
import { context, action, type ActionCallContext } from "@daydreamsai/core";
import { z } from "zod";

interface MyContextMemory {
  value: number;
}

const myContext = context<MyContextMemory, { id: string }>({
  type: "myContext",
  schema: z.object({ id: string() }),
  create: () => ({ value: 0 }),
  // ... other context properties

  // Define actions directly within the context
  actions: [
    action({
      name: "incrementValue",
      description: "Increments the context's value.",
      schema: z.object({ amount: z.number().optional().default(1) }),
      // `ctx.memory` is automatically typed as MyContextMemory here
      handler(args, ctx, agent) {
        ctx.memory.value += args.amount;
        return { success: true, newValue: ctx.memory.value };
      },
    }),
  ],
});
```

**2. Using the `.setActions()` method (often better for typing):**

```typescript
import { context, action, type ActionCallContext } from "@daydreamsai/core";
import { z } from "zod";

interface MyContextMemory {
  value: number;
}

const myContextDefinition = context<MyContextMemory, { id: string }>({
  type: "myContext",
  schema: z.object({ id: string() }),
  create: () => ({ value: 0 }),
  // ... other context properties
});

const incrementAction = action({
  name: "incrementValue",
  description: "Increments the context's value.",
  schema: z.object({ amount: z.number().optional().default(1) }),
  // Handler defined separately or inline
  handler(
    args,
    ctx: ActionCallContext<any, typeof myContextDefinition>,
    agent
  ) {
    // Type hint might be needed here sometimes, but .setActions() helps inference
    ctx.memory.value += args.amount;
    return { success: true, newValue: ctx.memory.value };
  },
});

// Associate actions using the chained method
const myContextWithActions = myContextDefinition.setActions([
  incrementAction,
  // ... other actions specific to myContext
]);
```

**Benefits of Context-Specific Actions:**

- **Scoped Availability:** The `incrementValue` action will only appear in the
  LLM's available actions when an instance of `myContext` is active in the
  agent's run.
- **Typed State Access:** Within the handler, `ctx.memory` is correctly typed
  according to the context's memory interface (`MyContextMemory` in this
  example).
- **Organization:** Keeps related logic bundled together.

**Note:** This same pattern applies to defining context-specific `Inputs` and
`Outputs` using `.setInputs({...})` and `.setOutputs({...})`.

## Interacting with External Systems

Actions are the natural place to interact with external APIs, databases, or
other services. Remember to use `async`/`await` for any I/O operations.

```typescript
import { action } from "@daydreamsai/core";
import { z } from "zod";

export const sendNotificationAction = action({
  name: "sendNotification",
  description: "Sends a notification to a user via an external service.",
  schema: z.object({
    userId: z.string().describe("The ID of the user to notify"),
    message: z.string().describe("The notification message"),
  }),
  async handler(args, ctx, agent) {
    try {
      // Example: Get a service client from the DI container
      // const notificationService = agent.container.resolve<NotificationService>('notify');
      // await notificationService.send(args.userId, args.message);

      // Simulate async API call
      agent.logger.debug(
        "sendNotification",
        `Simulating notification to ${args.userId}`
      );
      await new Promise((resolve) => setTimeout(resolve, 150));

      return { success: true, message: `Notification sent to ${args.userId}.` };
    } catch (error) {
      agent.logger.error("sendNotification", "Failed to send notification", {
        args,
        error,
      });
      return {
        success: false,
        error: "Service unavailable",
        message: "Could not send notification.",
      };
    }
  },
});
```

## Important Considerations for Handlers

When writing action handlers, keep these points in mind:

1.  **Asynchronous Execution:** Handlers often perform I/O. Always use
    `async`/`await` for promises. The framework runs handlers concurrently up to
    a configured limit, so they might not execute instantly if the agent is
    busy.
2.  **Cancellation (`ctx.abortSignal`):** For actions that might run for a long
    time (e.g., complex calculations, polling), you **must** check for
    cancellation requests. The `ctx.abortSignal` signals if the overall agent
    run has been cancelled.

    ```typescript
    async handler(args, ctx, agent) {
      for (let i = 0; i < 100; i++) {
        // Check for cancellation before long-running work
        if (ctx.abortSignal?.aborted) {
           agent.logger.warn("longAction", "Action cancelled by signal");
           throw new Error("Action cancelled"); // Or return an appropriate state
        }
        // Or use throwIfAborted() which throws if cancelled
        // ctx.abortSignal?.throwIfAborted();

        await performStep(i); // Represents potentially long work
      }
      // ...
    }
    ```

3.  **Retries (`retry` option):** You can configure actions to automatically
    retry on failure using the `retry` option in the action definition (e.g.,
    `retry: 3`). If you use retries, try to make your handler **idempotent** –
    running it multiple times with the same `args` should produce the same final
    state without unintended side effects (e.g., don't create duplicate
    records).
4.  **Error Handling:** Use `try...catch` blocks within your handler to catch
    errors from external calls or internal logic. Return a structured error
    response so the agent (or logs) can understand what went wrong. You can also
    use the advanced `onError` hook in the action definition for centralized
    error handling logic.

## How the LLM Chooses Actions

The LLM doesn't directly execute your code. Instead:

1.  The framework presents the `name` and `description` of all available actions
    to the LLM in its prompt.
2.  Based on its instructions and the current context, the LLM decides which
    action to use.
3.  It formulates the arguments for the action based on the `schema` you
    provided (including any `.describe()` hints).
4.  The framework intercepts the LLM's request, validates the arguments against
    the `schema`, and then securely executes your `handler` function with the
    validated `args`.

Therefore, clear `name`s and detailed `description`s are vital for the LLM to
use your actions correctly.

## Best Practices

- **Clear Naming & Descriptions:** Make them unambiguous for the LLM.
- **Precise Schemas:** Use Zod effectively, adding `.describe()` to clarify
  arguments for the LLM.
- **Structured Returns:** Return objects from handlers with clear success/error
  status and relevant data.
- **Use `async`/`await`:** Essential for any I/O.
- **Handle Errors:** Use `try...catch` and return meaningful error information.
- **Check for Cancellation:** Implement `ctx.abortSignal` checks in long-running
  handlers.
- **Consider Idempotency:** Especially if using the `retry` option.
- **Choose the Right Memory Scope:** Use `ctx.memory` for context instance state
  unless you specifically need action (`ctx.actionMemory`) or global
  (`ctx.agentMemory`) state.
- **Keep Actions Focused:** Aim for single responsibility per action.
- **Use `agent.logger`:** Log important steps and errors for debugging.

Actions are the core mechanism for adding custom capabilities and stateful
interactions to your Daydreams agents.

--- End File: docs/content/docs/concepts/actions.mdx ---

--- File: docs/content/docs/concepts/agent-lifecycle.mdx ---
---
title: Agent Lifecycle
description: How Daydreams agents process information and execute tasks.
---

The core of the Daydreams framework is the agent's execution lifecycle. This
loop manages how an agent receives input, reasons with an LLM, performs actions,
and handles results. Understanding this flow is crucial for building and
debugging agents.

Let's trace the lifecycle of a typical request:

## 1. Input Reception

- **Source:** An external system (like Discord, Telegram, CLI, or an API) sends
  information to the agent. This is usually configured via an `extension`.
- **Listener:** An `input` definition within the agent or an extension listens
  for these events (e.g., a new message arrives).
- **Trigger:** When the external event occurs, the input listener is triggered.
- **Invocation:** The listener typically calls `agent.send(...)`, providing:
  - The target `context` definition (which part of the agent should handle
    this?).
  - `args` to identify the specific context instance (e.g., which chat
    session?).
  - The input `data` itself (e.g., the message content).

## 2. `agent.send` - Starting the Process

- **Log Input:** The framework logs the incoming information as an `InputRef` (a
  record of the input).
- **Initiate Run:** It then calls the internal `agent.run` method to start or
  continue the processing cycle for the specified context instance, passing the
  new `InputRef` along.

## 3. `agent.run` - Managing the Execution Cycle

- **Load/Create Context:** The framework finds the specific `ContextState` for
  the target instance (e.g., the state for chat session #123). If it's the first
  time interacting with this instance, it creates the state and its associated
  persistent memory (`ContextState.memory`). It also retrieves or creates the
  temporary `WorkingMemory` for this specific run.
- **Handle Concurrency:** It checks if this context instance is already
  processing another request. If so, the new input is usually added to the
  ongoing run. If not, it sets up a new run.
- **Setup Run Environment:** It prepares the environment for the LLM
  interaction, gathering all available `actions`, `outputs`, and relevant
  context information.
- **Start Step Loop:** It begins the main processing loop, which iterates
  through one or more reasoning steps until the interaction is complete.

## 4. Inside the Step Loop - Perception, Reasoning, Action

Each iteration (step) within the `agent.run` loop represents one turn of the
agent's core reasoning cycle:

- **Prepare State:** The agent gathers the latest information, including:
  - The current persistent state of the active `Context`(s) (via their `render`
    functions).
  - The history of the current interaction from `WorkingMemory` (processed
    inputs, outputs, action results from previous steps).
  * Any _new_ unprocessed information (like the initial `InputRef` or results
    from actions completed in the previous step).
  * The list of currently available `actions` and `outputs`.
- **Generate Prompt:** This information is formatted into a structured prompt
  (using XML) for the LLM. The prompt clearly tells the LLM its instructions,
  what tools (actions/outputs) it has, the current state, and what new
  information needs attention. (See [Prompting](/docs/concepts/prompting)).
- **LLM Call:** The agent sends the complete prompt to the configured LLM.
- **Process LLM Response Stream:** As the LLM generates its response token by
  token:
  - The framework **streams** the response.
  - It **parses** the stream, looking for specific XML tags defined in the
    expected response structure (`<reasoning>`, `<action_call>`, `<output>`).
  - The LLM's thought process is extracted from `<reasoning>` tags and logged.
  - Instructions to perform actions (`<action_call>`) or send outputs
    (`<output>`) are identified.
- **Execute Actions & Outputs:**
  - For each identified `<action_call>`, the framework validates the arguments
    against the action's schema and schedules the action's `handler` function to
    run via the `TaskRunner`. (See [Actions](/docs/concepts/actions) and
    [Tasks](/docs/concepts/tasks)).
  * For each identified `<output>`, the framework validates the
    content/attributes and runs the output's `handler` function to send the
    information externally (e.g., post a message). (See
    [Outputs](/docs/concepts/outputs)).
- **Wait for Actions:** The agent waits for any critical asynchronous actions
  scheduled in this step to complete. Their results (`ActionResult`) are logged
  to `WorkingMemory`.
- **Check Completion:** The agent determines if the interaction is complete or
  if another reasoning step (another loop iteration) is needed based on defined
  conditions (`shouldContinue` hooks or remaining unprocessed logs).

## 5. Run Completion

- **Exit Loop:** Once the loop condition determines no further steps are needed,
  the loop exits.
- **Final Tasks:** Any final cleanup logic or `onRun` hooks defined in the
  context are executed.
- **Save State:** The final persistent state (`ContextState.memory`) of all
  involved contexts is saved to the `MemoryStore`.
- **Return Results:** The framework resolves the promise originally returned by
  `agent.send` or `agent.run`, providing the complete log (`chain`) of the
  interaction.

This detailed cycle illustrates how Daydreams agents iteratively perceive
(inputs, results), reason (LLM prompt/response), and act (outputs, actions),
using streaming and asynchronous task management to handle potentially complex
interactions efficiently.

--- End File: docs/content/docs/concepts/agent-lifecycle.mdx ---

--- File: docs/content/docs/concepts/contexts.mdx ---
---
title: Contexts
description: Managing state, memory, and behavior for agent interactions.
---

In Daydreams, a **Context** defines a specific scope or environment for your
agent's interactions or tasks. Think of it as a dedicated workspace that holds
the state, memory, available tools (actions, inputs, outputs), and specific
instructions relevant to that particular job.

You might use different contexts for:

- Handling individual user chat sessions (`chatContext`).
- Managing a specific game state (`gameContext`).
- Executing a complex workflow or process (`workflowContext`).
- Interacting with a specific external system (`externalApiContext`).

Each running **instance** of a context (e.g., the chat session with _user A_)
maintains its own unique state and memory, separate from other instances (like
the chat session with _user B_).

## Defining a Context

You define context types using the `context` function from `@daydreamsai/core`.

```typescript
import {
  context,
  action,
  type AnyAgent,
  type ContextState,
} from "@daydreamsai/core";
import { z } from "zod";

// 1. Define the structure of the persistent memory for this context type
interface ChatMemory {
  messageHistory: { sender: "user" | "agent"; text: string }[];
  userPreferences: Record<string, any>;
  lastInteractionTime?: number;
}

// 2. Define the Zod schema for arguments needed to identify a specific instance
const chatSchema = z.object({
  sessionId: z.string().describe("Unique identifier for the chat session"),
  userId: z.string().describe("Identifier for the user in the session"),
});

// 3. Define the context using the `context` function
const chatContext = context<
  ChatMemory, // Type for the persistent memory
  typeof chatSchema // Type for the identifying arguments
>({
  // Required: A unique identifier string for this *type* of context
  type: "chat",

  // Required: The Zod schema defining the arguments needed to identify
  // or create a specific *instance* of this context.
  schema: chatSchema,

  // Optional: Function to generate a unique string key for an instance from its arguments.
  // Use this if the 'type' alone isn't unique (e.g., multiple chat sessions).
  // The full instance ID becomes "<type>:<key>" (e.g., "chat:session-xyz").
  key: ({ sessionId }) => sessionId,

  // Optional: Defines the initial structure and default values for the
  // context instance's persistent memory (`ctx.memory`).
  // This runs only if no saved memory exists for this instance.
  create: (state, agent) => {
    agent.logger.info(
      "chatContext",
      `Creating new memory for session: ${state.key}`
    );
    return {
      messageHistory: [],
      userPreferences: {}, // Can use `state.options` if `setup` is used
    };
  },

  // Optional: Provides static or dynamic instructions to the LLM *when this context is active*.
  instructions: (state) =>
    `You are chatting with user ${state.args.userId}. Be helpful.`,

  // Optional: A description of this context type's purpose.
  description: "A chat session with a specific user.",

  // Optional: Function to format the context's *current memory state* for the LLM prompt.
  // Helps the LLM understand the current situation within this context instance.
  render: (state) => {
    // state.memory is typed as ChatMemory here
    const recentHistory = state.memory.messageHistory
      .slice(-5) // Show last 5 messages
      .map((msg) => `${msg.sender}: ${msg.text}`)
      .join("\n");

    return `
## Recent Chat History (Session: ${state.key}):
${recentHistory || "No messages yet."}

## User Preferences:
${JSON.stringify(state.memory.userPreferences)}
    `;
  },

  // --- Optional Lifecycle Hooks & Config ---
  // onStep: async (ctx, agent) => { /* Logic per step */ },
  // onRun: async (ctx, agent) => { /* Logic on run completion */ },
  // shouldContinue: (ctx) => ctx.memory.messageHistory.length < 50, // Example condition
  // onError: async (error, ctx, agent) => { /* Handle errors */ },
  // model: mySpecificLLM, // Override agent's default model
  // maxSteps: 15, // Limit run steps for this context type
});

// You can then associate actions, inputs, or outputs specifically for this context
// (See "Associating Components" section below)
// chatContext.setActions([...]);
// chatContext.setInputs({...});
// chatContext.setOutputs({...});
```

**Key Definition Parameters:**

- `type`: Unique string identifying the context _type_.

- `schema`: Zod schema for arguments needed to identify a context _instance_.
  Use `.describe()` on fields for clarity.

- `key`: (Optional) Function `(args) => string` to create a unique instance key
  from arguments.

- `create`: (Optional) Function `(state, agent) => TMemory` defining the initial
  structure of the instance's persistent memory (`ctx.memory`).

- `render`: (Optional) Function `(state) => string | XMLElement | ...`
  formatting the current `state.memory` for the LLM prompt. Keep it concise and
  relevant.

- `instructions` / `description`: (Optional) Provide guidance to the LLM about
  the context.

- Lifecycle Hooks (`onStep`, `onRun`, etc.): (Optional) Add custom logic at
  different points in the execution cycle.
- Configuration (`model`, `maxSteps`, etc.): (Optional) Override agent defaults
  for this context type.

## Context Memory (`ctx.memory`)

The most important concept for managing state within a context is its
**persistent memory**.

- **Definition:** The structure and initial values are defined by the `create`
  function in your `context` definition.
- **Access:** Within context lifecycle hooks (like `onStep`) and within the
  `handler` of any action, input, or output associated with this context, you
  can access the **current instance's** memory via `ctx.memory`.
- **Persistence:** Changes made to `ctx.memory` during an agent run are
  **automatically saved** by the framework to the configured `MemoryStore` at
  the end of the run cycle.
- **Loading:** When an agent run starts for a specific context instance, the
  framework loads its saved memory from the `MemoryStore` into `ctx.memory`.

```typescript
// Inside an action handler associated with chatContext:
handler(args, ctx, agent) {
  // ctx.memory is typed as ChatMemory
  const history = ctx.memory.messageHistory;
  const lastMsg = history[history.length - 1];

  // Modify the memory
  ctx.memory.lastInteractionTime = Date.now();
  ctx.memory.messageHistory.push({ sender: "agent", text: "Acknowledged." });

  // This change will be saved automatically.
  return { success: true };
}
```

## Associating Components (Actions/Inputs/Outputs)

While you can define components globally, it's often better to associate them
directly with the context they belong to using the chained `.setActions()`,
`.setInputs()`, and `.setOutputs()` methods. This provides better organization
and ensures components have typed access to the correct context memory.

```typescript
import { chatContext, ChatMemory } from "./chatContext"; // Assuming context is defined elsewhere
import { sendMessageAction } from "./actions/sendMessage"; // Assuming action is defined

// Associate the action with the chat context
const chatContextWithActions = chatContext.setActions([
  sendMessageAction,
  // other actions relevant only to chat...
]);

// Now, within sendMessageAction's handler, ctx.memory will be typed as ChatMemory
// and the action will only be available when chatContext is active.

// Similarly for inputs and outputs:
// chatContext.setInputs({ ... });
// chatContext.setOutputs({ ... });
```

You can also define them inline using the `actions`, `inputs`, or `outputs`
properties directly within the `context({...})` definition, though the chained
methods often offer superior type inference.

## Working with Context Instances

You typically interact with specific context instances through the `agent`
object:

- `agent.getContext({ context: chatContext, args: { sessionId: "xyz", userId: "user1" } })`:
  Retrieves the `ContextState` for the specified instance. If it doesn't exist,
  it creates it (running `create` if needed) and loads its memory.

- `agent.run({ context: chatContext, args: { sessionId: "xyz", userId: "user1" }, ... })`:
  Starts (or continues) the agent's processing loop specifically for this
  context instance.

- `agent.getContextById("chat:session-xyz")`: (Less common) Retrieves a context
  instance directly by its full ID if you know it.

- `agent.saveContext(contextState)`: Manually saves the state. Usually handled
  automatically by the agent lifecycle.

## Context Memory vs. Working Memory

It's important not to confuse the **persistent Context Memory (`ctx.memory`)**
with the temporary **Working Memory**.

- **Context Memory (`ctx.memory`):** Specific to a context **instance**. Holds
  the **persistent state** (like chat history). Defined by `create`.
  Saved/loaded by the `MemoryStore`. Used by `render`.
- **Working Memory:** Exists only for the duration of a single `agent.run`.
  Holds the **temporary log** of inputs, outputs, thoughts, and action
  calls/results for _that specific run_. Used to build the prompt at each step.

## Best Practices

- **Scope Appropriately:** Design contexts around distinct tasks or interaction
  boundaries.
- **Define Memory Clearly:** Use interfaces (like `ChatMemory`) for your context
  memory structure. Initialize it properly in `create`.
- **Keep `render` Concise:** Only include state in `render` that is essential
  for the LLM's immediate reasoning. Avoid overly large state dumps.
- **Use Zod Schemas:** Clearly define `schema` for context arguments with
  `.describe()`.
- **Associate Components:** Link actions, inputs, and outputs to their relevant
  contexts for better organization and type safety.

Contexts provide the structure for organizing your agent's knowledge, state, and
capabilities, enabling complex and stateful interactions.

--- End File: docs/content/docs/concepts/contexts.mdx ---

--- File: docs/content/docs/concepts/core.mdx ---
---
title: Introduction
description:
  Understand the fundamental building blocks of the Daydreams framework.
---

The Daydreams framework is designed around a set of core concepts that work
together to enable autonomous agent behavior. Understanding these concepts is
key to effectively building and customizing agents.

## Core Architecture

A Daydreams agent consists of several key components:

### Contexts

Contexts are the foundation of a Daydreams agent. Similar to React components,
contexts manage state and rendering for your agent. Each context:

- Has a defined schema for initialization
- Maintains its own memory state
- Provides a rendering function that formats its state for the LLM

```ts
const myContext = context({
  // Unique identifier for this context type
  type: "my-context",

  // Schema defining the arguments needed to initialize this context
  schema: z.object({
    id: z.string(),
  }),

  // Function to generate a unique key for this context instance
  key({ id }) {
    return id;
  },

  // Initialize the context's memory state
  create(state) {
    return {
      items: [],
      currentItem: null,
    };
  },

  // Format the context for the LLM
  render({ memory }) {
    return `
      Current Items: ${memory.items.join(", ")}
      Active Item: ${memory.currentItem || "None"}
    `;
  },
});
```

### Actions

Actions are functions that your agent can call to interact with its environment
or modify its state. They're similar to event handlers in React:

```ts
action({
  name: "addItem",
  description: "Add a new item to the list",
  schema: z.object({
    item: z.string().describe("The item to add"),
  }),
  handler(call, ctx, agent) {
    // Access the context memory
    const contextMemory = ctx.agentMemory;

    // Update the state
    contextMemory.items.push(call.data.item);

    // Return a response
    return {
      message: `Added ${call.data.item} to the list`,
      items: contextMemory.items,
    };
  },
});
```

### Extensions

Extensions are pre-packaged bundles of inputs, outputs, and actions that add
specific capabilities to your agent. For example, the `cli` extension adds
terminal input/output capabilities.

## The React-like Mental Model

If you're familiar with React, you can think of Daydreams in similar terms:

- **Contexts** are like React components, managing state and rendering
- **Actions** are like event handlers, responding to inputs and updating state
- **Extensions** are like pre-built component libraries
- The agent itself is like a React application, orchestrating everything

This mental model makes it easy to reason about how your agent works and how to
structure complex behaviors.

---

This section provides a detailed explanation of each fundamental component:

- **[Agent Lifecycle](/docs/concepts/agent-lifecycle):** How an agent processes
  information, makes decisions, and executes tasks in a continuous loop.
- **[Contexts](/docs/concepts/contexts):** The mechanism for managing state,
  memory, and behavior for specific tasks or interactions.
- **[Actions](/docs/concepts/actions):** Definable tasks or capabilities that an
  agent can perform.
- **[Inputs](/docs/concepts/inputs):** How agents receive data and trigger
  processing cycles.
- **[Outputs](/docs/concepts/outputs):** How agents communicate results or send
  information to external systems.
- **[Memory](/docs/concepts/memory):** The different ways agents store,
  retrieve, and utilize information (Working, Episodic, Vector).
- **[Prompting](/docs/concepts/prompting):** How instructions and context are
  formatted for the LLM to guide its reasoning.
- **[Tasks](/docs/concepts/tasks):** The system for managing asynchronous
  operations and background tasks.
- **[Services & Extensions](/docs/advanced):** How to integrate external
  services and extend the framework's capabilities.

Explore these pages to gain a deeper understanding of how Daydreams works under
the hood.

--- End File: docs/content/docs/concepts/core.mdx ---

--- File: docs/content/docs/concepts/inputs.mdx ---
---
title: Inputs
description: How Daydreams agents receive information and trigger processing.
---

Inputs are the mechanism by which Daydreams agents receive information from the
outside world. They act as the triggers that initiate or contribute to an
agent's processing cycle (`agent.run`). An input could represent a user message,
a blockchain event, an API webhook, a sensor reading, or any other data source
relevant to the agent's task.

## Defining an Input

Input sources are defined using the `input` helper function exported from
`@daydreamsai/core`. Each input definition connects an external data source to
the agent's core processing loop.

```typescript
import { input, context, type AnyAgent } from "@daydreamsai/core";
import { z } from "zod";
import { EventEmitter } from "events"; // Example: Using a simple Node.js EventEmitter

// Assume myContext is defined elsewhere
declare const myContext: any;

// Example: An input source listening to a simple EventEmitter
const myEventEmitter = new EventEmitter();

const eventInput = input({
  // Required: A unique identifier for this input source type.
  // Helps in logging and debugging. e.g., "myApi:webhook", "discord:message"
  type: "custom:event",

  // Optional (but recommended): Zod schema for the *data payload* that will be
  // passed into the agent via the `send` function below. This validates
  // the data structure *before* it triggers the agent's run cycle.
  schema: z.object({
    eventId: z.string().describe("Unique ID for the incoming event"),
    payload: z.any().describe("The actual data content of the event"),
    source: z.string().optional().describe("Origin of the event"),
  }),

  // Required (usually): Connects to the external data source and calls `send`
  // when new data arrives.
  subscribe: (send, agent: AnyAgent) => {
    // `send` is the crucial function provided by the framework. You call this
    // to push validated data into the agent for processing.
    // `agent` is the agent instance, useful for accessing shared services or config.

    const listener = (eventData: {
      id: string;
      data: any;
      origin?: string;
    }) => {
      console.log(`External event received: ${eventData.id}`);

      // 1. Determine the target Context and its arguments.
      // This tells the agent *which* context instance should handle this input.
      // This might be static or dynamically determined based on eventData.
      const targetContext = myContext; // Replace with your actual context definition
      const contextArgs = { someId: eventData.id }; // Args matching targetContext.schema

      // 2. Prepare the data payload according to this input's `schema`.
      const inputData = {
        eventId: eventData.id,
        payload: eventData.data,
        source: eventData.origin,
      };

      try {
        // 3. Validate the payload before sending (optional but good practice)
        eventInput.schema?.parse(inputData); // Use the defined schema

        // 4. Call `send` to push the input data into the agent.
        // This triggers the agent's processing cycle for the target context instance.
        send(targetContext, contextArgs, inputData);
      } catch (validationError) {
        agent.logger.error(
          "eventInput:subscribe",
          "Invalid event data received",
          { eventData, validationError }
        );
        // Decide how to handle invalid data (e.g., log, ignore)
      }
    };

    // Attach the listener to the external source
    myEventEmitter.on("newEvent", listener);
    agent.logger.info("eventInput", "Subscribed to newEvent");

    // IMPORTANT: Return a cleanup function.
    // This is called when the agent stops, ensuring you detach listeners,
    // close connections, clear intervals, etc.
    return () => {
      myEventEmitter.off("newEvent", listener);
      agent.logger.info("eventInput", "Unsubscribed from newEvent");
    };
  },

  // Optional: Pre-process data *after* `send` is called but *before* the log entry
  // (InputRef) is created. Useful for adding metadata based on context state.
  handler: async (data, ctx, agent) => {
    // `data` is the payload passed to `send`.
    // `ctx` is the ContextState of the target context instance.
    // Example: Check if this event was already seen in this context instance
    const seen = ctx.memory.processedEventIds?.includes(data.eventId) ?? false;
    return {
      data: data, // Can optionally transform the data here
      params: { seen: String(seen) }, // Add parameters to the InputRef log entry
    };
  },

  // Optional: Customize how this input is represented in logs or prompts.
  format: (ref) => {
    // `ref` is the InputRef object (log entry)
    return `Event Received: ID=${ref.data.eventId}, Source=${ref.data.source ?? "N/A"}`;
  },

  // Optional: One-time setup logic when the agent starts.
  install: async (agent) => {
    // E.g., agent.container.resolve('myApiClient').connect();
    agent.logger.info("eventInput", "Install hook executed");
  },
});
```

**Key Concepts:**

- **`type`**: A unique string identifying your input source.
- **`schema`**: (Recommended) A Zod schema defining the structure of the data
  payload you intend to pass via `send`. Validation happens automatically if
  provided.
- **`subscribe(send, agent)`**: The core function where you connect to your
  external data source (API, websocket, event emitter, polling mechanism, etc.).
  - When data arrives, you call the provided `send` function.
  - You **must** return a cleanup function to disconnect/unsubscribe when the
    agent stops.
- **`send(context, args, data)`**: This framework-provided function is your
  gateway into the agent.
  - `context`: The **context definition** object that should handle this input.
  - `args`: An object matching the `context.schema`, identifying the specific
    **instance** of the context.
  - `data`: The payload containing the actual input information, ideally
    matching this `input`'s `schema`.
- **`handler(data, ctx, agent)`**: (Optional) Pre-processing function executed
  after `send` but before the input log entry is finalized. Allows data
  transformation or adding metadata (`params`) based on the target context's
  state (`ctx`).
- **`format(ref)`**: (Optional) Customize the string/XML representation of the
  input log entry (`InputRef`).

## How Inputs Trigger the Agent

1.  **External Event:** Your `subscribe` function detects an event or receives
    data.
2.  **`send` Called:** Your code calls `send(context, args, data)`.
3.  **Agent Invoked:** The framework receives the call, creates a basic log
    entry (`InputRef`) for this input, and starts or queues an `agent.run` cycle
    for the specified `context` instance identified by `args`.
4.  **Pre-processing (`handler`):** If you defined an `input.handler`, it runs,
    potentially modifying the data or adding parameters to the `InputRef`.
5.  **Run Cycle:** The agent proceeds with its run cycle
    ([Agent Lifecycle](/docs/concepts/agent-lifecycle)), processing this new
    `InputRef` along with other state information to generate a response or
    perform actions.

## Inputs within Extensions

Inputs are commonly bundled within [Extensions](/docs/advanced/extensions) to
package integrations cleanly. The structure is the same, but the `input`
definitions live inside the `inputs` property of the `extension` definition.

```typescript
import { extension, input /* ... */ } from "@daydreamsai/core";
import { z } from "zod";
import { myService } from "./myService";
import { myContext } from "./myContext";

export const myApiExtension = extension({
  name: "myApi",
  services: [myService], // Optional services used by the input
  contexts: { myContext }, // Optional contexts targeted by the input

  inputs: {
    // Input definitions go here, keyed by their type
    "myApi:webhook": input({
      type: "myApi:webhook", // Redundant but ensures key matches type
      schema: z.object({
        /* ... webhook payload schema ... */
      }),
      subscribe(send, agent) {
        const apiClient = agent.container.resolve<MyApiClient>("myApiClient"); // Use a service

        const webhookHandler = (payload: any) => {
          const validatedData =
            myApiExtension.inputs["myApi:webhook"].schema.parse(payload);
          // Determine context/args based on payload
          const contextArgs = { entityId: validatedData.entityId };
          send(myContext, contextArgs, validatedData);
        };

        apiClient.registerWebhookListener(webhookHandler);
        return () => apiClient.removeWebhookListener(webhookHandler);
      },
      // ... other input properties ...
    }),
    // ... potentially other inputs for this extension ...
  },
});
```

## Examples

(Keep the existing CLI, Telegram, and Twitter examples here, perhaps slightly
simplifying the code snippets to focus on the `subscribe` and `send` pattern.)

### CLI Input (from `@daydreamsai/cli`)

```typescript
// Simplified example
input({
  type: "cli:input",
  subscribe(send, { container }) {
    const rl = container.resolve<readline.Interface>("readline");
    const listen = async () => {
      while (true) {
        // Basic loop, real implementation handles abort
        const line = await rl.question("> ");
        if (line === "exit") break;
        // Send to a default CLI context instance
        send(cliContext, { user: "cli_user" }, line);
      }
    };
    listen(); // Start listening
    return () => {
      /* Abort logic here */
    };
  },
});
```

### Telegram Message Input (from `@daydreamsai/telegram`)

```typescript
// Simplified example
input({
  type: "telegram:message",
  schema: z.object({
    /* ... */
  }),
  subscribe(send, { container }) {
    const tg = container.resolve<Telegraf>("telegraf");
    tg.on("message", (ctx) => {
      if ("text" in ctx.message) {
        const dataPayload = {
          /* ... extract user, text ... */
        };
        // Send data to the specific telegram chat context
        send(telegramChat, { chatId: ctx.chat.id }, dataPayload);
      }
    });
    // Telegraf handles cleanup
    return () => {};
  },
});
```

Inputs are the crucial link between your agent and the information it needs to
react to, enabling dynamic and event-driven behavior.

--- End File: docs/content/docs/concepts/inputs.mdx ---

--- File: docs/content/docs/concepts/memory.mdx ---
---
title: Memory
description: How Daydreams agents store, recall, and learn from information.
---

Memory is fundamental to how Daydreams agents operate, allowing them to maintain
state, recall past interactions, store learned information, and improve their
performance over time. The framework provides a flexible system with different
types of memory serving distinct purposes.

## Core Memory Components (`BaseMemory`)

When creating an agent using `createDreams`, you configure its primary memory
system via the `memory` option. This accepts an object conforming to the
`BaseMemory` type, which holds implementations for different storage needs:

```typescript
import { createDreams } from "@daydreamsai/core";
import { createMemory, createMemoryStore, createVectorStore } from "@daydreamsai/core";
import { createChromaVectorStore } from "@daydreamsai/chroma"; // Example
import { createMongoMemoryStore } from "@daydreamsai/mongo"; // Example

const agent = createDreams({
  model: /* ... */,
  memory: createMemory(
    // 1. MemoryStore: For key-value based storage
    await createMongoMemoryStore({ uri: "mongodb://localhost:27017" }),

    // 2. VectorStore: For embedding storage and similarity search
    createChromaVectorStore("my-agent-episodes")
  ),
  // Optional: Enable automatic episodic memory generation
  // generateMemories: true,
  // exportTrainingData: true, // Optionally save episodes for fine-tuning
  // trainingDataPath: './agent-training.jsonl'
});
```

The `createMemory` function bundles together two main storage interfaces:

1.  **`MemoryStore`**: A key-value store interface for structured data
    persistence.
2.  **`VectorStore`**: An interface for storing vector embeddings and performing
    similarity searches, primarily used for episodic memory.

The `BaseMemory` object passed to `createDreams` makes these stores available
throughout the agent's systems.

## `MemoryStore` (Key-Value Storage)

The `MemoryStore` handles the persistence of structured data associated with
contexts and actions. It defines a simple key-value interface:

- `get<T>(key: string): Promise<T | null>`: Retrieve data by key.
- `set<T>(key: string, value: T): Promise<void>`: Store or update data by key.
- `delete(key: string): Promise<void>`: Remove data by key.
- `clear(): Promise<void>`: Remove all data (use with caution).

**Uses:**

- Storing `ContextState` snapshots (key: `"context:<contextId>"`).
- Storing persistent `Context` memory (key: `"memory:<contextId>"`).
- Storing `WorkingMemory` snapshots between runs (key:
  `"working-memory:<contextId>"`).
- Storing persistent `Action` memory (key: defined in `action.memory.key`).

**Implementations:**

- `createMemoryStore()`: Default in-memory store using a `Map` (data lost on
  restart). Found in `@daydreamsai/core`.
- `createMongoMemoryStore()`: MongoDB-backed implementation. Found in
  `@daydreamsai/mongo`.
- _(Others like SQLite, Redis might be available or could be implemented)_

## `VectorStore` (Embedding Storage & Search)

The `VectorStore` is designed for handling high-dimensional vector embeddings,
typically used for semantic search and retrieving relevant past experiences
(Episodic Memory).

- `upsert(contextId: string, data: any): Promise<void>`: Add or update vector
  embeddings, often associated with a specific context.
- `query(contextId: string, query: string): Promise<any[]>`: Search for vectors
  similar to the query text within a specific context.
- `createIndex(indexName: string): Promise<void>`: Create an index (if required
  by the backend).
- `deleteIndex(indexName: string): Promise<void>`: Delete an index.

**Uses:**

- Storing `Episode` embeddings for recall.
- Potentially storing document embeddings for RAG (Retrieval-Augmented
  Generation) patterns (though not explicitly shown in the core loop).

**Implementations:**

- `createVectorStore()`: Default no-op implementation (does nothing). Found in
  `@daydreamsai/core`.
- `createChromaVectorStore()`: Implementation using ChromaDB. Found in
  `@daydreamsai/chroma`. Requires `OPENAI_API_KEY` for default embedding or a
  custom embedder.
- _(Others like Pinecone might be available or could be implemented)_

## Clarification: Context vs. Memory

It's important to distinguish between the concept of a "Context" and "Memory":

- **Context (`context({...})` Definition & `ContextState` Instance):**

  - **Definition:** Think of this as a **blueprint** or template for a specific
    type of interaction scope (e.g., a chat session, a game state). It defines
    the _rules_, _behavior_, expected `schema` arguments, the structure of its
    persistent memory (`create`), how that state is rendered for the LLM
    (`render`), and its associated `inputs`, `outputs`, and `actions`.
  - **Instance (`ContextState`):** This is a **runtime instance** of a Context
    definition, representing a specific, active scope (e.g., the chat session
    with _user A_). It holds a reference to the definition, the specific `args`
    used to identify it, and the actual, current **memory payload** for this
    instance (`ContextState.memory`).

- **Memory (`ContextState.memory`, `WorkingMemory`, etc.):**
  - **Context Memory (`ContextState.memory`):** This is the actual **persistent
    data payload** or state associated with a specific `ContextState` instance.
    Its structure is determined by the `context.create` function. This is what's
    loaded from/saved to the `MemoryStore` and rendered via `context.render`.
  - **Other Memory Types:** The framework also uses other memory concepts like
    `WorkingMemory` (transient log for a single run), `ActionMemory` (persistent
    state for an action definition), and `AgentMemory` (persistent state for the
    main agent context). These are distinct from the specific
    `ContextState.memory` of a running context instance.

**In essence:**

A **Context** defines the **structure and behavior** of an interaction scope.
**Memory** (specifically `ContextState.memory`) is the **persistent data**
stored _within_ a particular instance of that Context.

## Types of Memory Usage

### Working Memory

- **Purpose:** Short-term, temporary storage for a single `agent.run` cycle.
- **Content:** Holds the sequence of `Log` objects (`InputRef`, `OutputRef`,
  `Thought`, `ActionCall`, `ActionResult`, `EventRef`, `StepRef`, `RunRef`)
  generated during the run.
- **Lifecycle:** Created at the start of `agent.run`, populated during stream
  processing, used to build prompts at each step, and potentially snapshotted to
  the `MemoryStore` between runs.
- **Access:** Available as `ctx.workingMemory` within handlers.

### Context Memory

- **Purpose:** Persistent state associated with a specific `Context` instance
  (e.g., chat history for a specific user session).
- **Structure:** Defined by the `create` function in the `context` definition.
- **Lifecycle:** Loaded from the `MemoryStore` when `agent.getContext` is
  called, updated by context logic or actions, saved back to the `MemoryStore`
  via `agent.saveContext`.
- **Access:** Available as `ctx.memory` within context-related functions
  (`render`, `onStep`, etc.) and action handlers.

### Action Memory

- **Purpose:** Persistent state associated specifically with an `Action`
  definition, allowing it to maintain state across multiple calls within
  different runs or contexts.
- **Structure:** Defined by the `memory` option in the `action` definition,
  using the `memory()` helper.
- **Lifecycle:** Loaded from the `MemoryStore` before the action handler runs,
  potentially updated by the handler, saved back to the `MemoryStore` after the
  handler completes.
- **Access:** Available as `ctx.actionMemory` within the action's handler.

### Agent Memory

- **Purpose:** Persistent state associated with the agent's main/root context
  (if one is defined in `createDreams`). Used for global agent state.
- **Lifecycle:** Loaded/saved from the `MemoryStore` using the main agent
  context's ID.
- **Access:** Available as `ctx.agentMemory` within action handlers when a main
  agent context exists.

### Episodic Memory

- **Purpose:** Enables the agent to learn from past experiences by recalling
  relevant "episodes" (sequences of observation/thought -> action -> result).
- **Structure:** Defined by the `Episode` interface (observation, thoughts,
  result, timestamp, etc.).
- **Generation:** Handled by `generateEpisode` (`memory/utils.ts`), which uses
  an LLM to summarize the `Thought`, `ActionCall`, and `ActionResult`. Triggered
  automatically if `agent.memory.generateMemories` is true.
- **Storage:** The generated `Episode` (or its embedding) is stored in the
  `VectorStore` via `agent.memory.vector.upsert()`.
- **Retrieval:** When a new `InputRef` is processed (`handleInput`), the
  `agent.memory.vector.query()` method is called to find relevant past episodes
  based on the input content. Retrieved episodes are added to
  `WorkingMemory.episodicMemory`.
- **Training Data:** Episodes can be exported as prompt/completion pairs for
  fine-tuning models using `agent.exportAllTrainingData()` or by setting
  `exportTrainingData: true` on the agent config.

By combining these memory types and storage backends, Daydreams agents can
maintain short-term focus (Working Memory), long-term context state
(Context/Action/Agent Memory), and learn from past interactions (Episodic Memory
via VectorStore).

--- End File: docs/content/docs/concepts/memory.mdx ---

--- File: docs/content/docs/concepts/meta.json ---
{
  "pages": [
    "core",
    "agent-lifecycle",
    "contexts",
    "actions",
    "inputs",
    "outputs",
    "memory",
    "prompting",
    "tasks"
  ]
}

--- End File: docs/content/docs/concepts/meta.json ---

--- File: docs/content/docs/concepts/outputs.mdx ---
---
title: Outputs
description: How Daydreams agents send information and responses.
---

Outputs are how Daydreams agents communicate results or send information to
external systems or users. If Inputs are how agents "listen," Outputs are how
they "speak" or "act" based on the LLM's reasoning.

Examples of outputs include:

- Sending a message to a Discord channel or Telegram chat.
- Posting a tweet.
- Returning a response in a CLI session.
- Calling an external API based on the agent's decision (though Actions are
  often better for this if a response is needed).

## Defining an Output

Outputs are defined using the `output` helper function exported from
`@daydreamsai/core`. Each definition specifies how the agent should structure
information for a particular output channel and how to execute the sending
logic.

```typescript
import {
  output,
  context,
  type AnyAgent,
  type ContextState, // Base context state type
  type OutputRef, // Type for the log entry
} from "@daydreamsai/core";
import { z } from "zod";

// Assume myDiscordClient.sendMessage exists
declare const myDiscordClient: {
  sendMessage: (channelId: string, content: string) => Promise<any>;
};
declare const myContext: any; // Placeholder for your context type

const discordMessageOutput = output({
  // Required: A unique identifier for this output type. Used by the LLM.
  type: "discord:message",

  // Optional: Description for the LLM.
  description: "Sends a message to a specific Discord channel.",

  // Optional: Instructions for the LLM on usage.
  instructions: "Use this to reply to the user in the Discord channel.",

  // Optional: Zod schema for the main content of the output.
  // The LLM provides this content *inside* the <output> tag.
  // Defaults to z.string() if omitted.
  schema: z.string().describe("The message content to send."),

  // Optional: Zod schema for additional attributes the LLM must provide
  // *on* the <output> tag itself.
  attributes: z.object({
    channelId: z.string().describe("The ID of the Discord channel to send to."),
    replyToUserId: z
      .string()
      .optional()
      .describe("User ID to mention in the reply."),
  }),

  // Required (usually): The function that performs the actual sending logic.
  handler: async (data, ctx, agent) => {
    // 'data' contains the validated content (from schema).
    // 'ctx' includes the ContextState and the OutputRef for this specific call.
    // Access attributes parsed from the <output> tag via ctx.outputRef.params.
    const { channelId, replyToUserId } = ctx.outputRef.params ?? {};
    const content = data; // Access validated content from schema

    let messageContent = content;
    if (replyToUserId) {
      messageContent = `<@${replyToUserId}> ${content}`;
    }

    console.log(`Sending to Discord channel ${channelId}: ${messageContent}`);
    // Example: await myDiscordClient.sendMessage(channelId, messageContent);
    await new Promise((res) => setTimeout(res, 50)); // Simulate async

    // Optional: Return data to update the OutputRef log.
    // Can also return an array of OutputRefResponse for multiple logs.
    return {
      data: { content: messageContent, channelId }, // Updated data for the log
      params: ctx.outputRef.params, // Typically keep original params
      processed: true, // Mark this output as fully handled
    };
  },

  // Optional: Custom formatting for the OutputRef log.
  format: (res) => {
    // Note: 'res' is the OutputRef after the handler possibly updated it
    const outputData = Array.isArray(res.data) ? res.data[0] : res.data; // Adjust if handler returns array
    return `Sent Discord message to ${res.params?.channelId}: "${outputData?.content ?? res.content}"`;
  },

  // Optional: Examples for the LLM.
  examples: [
    `<output type="discord:message" channelId="12345">Hello there!</output>`,
    `<output type="discord:message" channelId="67890" replyToUserId="user123">Got it!</output>`,
  ],

  // Optional: Setup logic run when the agent starts.
  install: async (agent) => {
    /* ... */
  },

  // Optional: Conditionally enable this output based on context.
  enabled: (ctx: ContextState) => {
    // Example: Only enable if the current context is a discord channel
    // return ctx.context.type === 'discord:channel';
    return true;
  },

  // Optional: Associate with a specific context type.
  // context: myContext,
});
```

**Key Parameters:**

- `type` (string): Unique identifier used in `<output type="...">`.
- `description`/`instructions` (string, optional): Help the LLM understand what
  the output does and when to use it.
- `schema` (Zod Schema, optional): Defines the structure and validates the
  _content_ placed _inside_ the `<output>` tag by the LLM. Defaults to
  `z.string()`.
- `attributes` (Zod Schema, optional): Defines and validates _attributes_ placed
  _on_ the `<output>` tag itself (e.g.,
  `<output type="discord:message" channelId="...">`). These provide necessary
  parameters for the `handler`.
- `handler` (Function): Executes the logic to send the information externally.
  It receives:
  - `data`: The validated content from the `schema`.
  - `ctx`: The context state (`ContextState`) augmented with the specific
    `outputRef` for this call (`OutputRef`). Attributes parsed from the tag are
    found in `ctx.outputRef.params`.
  - `agent`: The agent instance.
  - It can optionally return an `OutputRefResponse` (or array thereof) to update
    the log entry or mark it as processed.
- `format` (Function, optional): Customizes the log representation of the
  `OutputRef`.
- `examples` (string[], optional): Provides concrete examples to the LLM on how
  to structure the `<output>` tag.
- `install` / `enabled` / `context` (Functions/Context, optional): Similar to
  Actions and Inputs for setup, conditional availability, and context scoping.

## LLM Interaction

1.  **Availability:** Enabled outputs are presented to the LLM within the
    `<available-outputs>` tag in the prompt, including their type, description,
    instructions, content schema (`content_schema`), attribute schema
    (`attributes_schema`), and examples.
2.  **Invocation:** The LLM generates an output by including an `<output>` tag
    in its response stream, matching one of the available types. It must provide
    any required attributes defined in the `attributes` schema and the content
    inside the tag matching the `schema`.
    ```xml
    <output type="discord:message" channelId="123456789">
      This is the message content generated by the LLM.
    </output>
    ```

## Execution Flow

1.  **Parsing:** When the framework parses an `<output>` tag from the LLM stream
    (`handleStream` in `streaming.ts`), it extracts the `type`, `attributes`,
    and `content`.
2.  **Log Creation:** An initial `OutputRef` log is created (`getOrCreateRef` in
    `streaming.ts`).
3.  **Processing:** Once the tag is fully parsed (`el.done`), the engine calls
    `handleOutput` (`handlers.ts`).
4.  **Validation:** `handleOutput` finds the corresponding output definition by
    `type`. It validates the extracted `content` against the `output.schema` and
    the extracted `attributes` against the `output.attributes` schema.
5.  **Handler Execution:** If validation passes, `handleOutput` executes the
    `output.handler` function, passing the validated content (`data`) and the
    context state augmented with the `outputRef` (`ctx`). Attributes are
    accessed via `ctx.outputRef.params`.
6.  **External Action:** The `handler` performs the necessary external operation
    (e.g., sending the Discord message).
7.  **Logging:** The `handler` can optionally return data to update the
    `OutputRef` log. The `OutputRef` is added to the `WorkingMemory`.

## Outputs vs. Actions

While outputs and actions share similar structures, they serve different
purposes:

| Feature         | Actions                                     | Outputs                                         |
| --------------- | ------------------------------------------- | ----------------------------------------------- |
| Primary purpose | Two-way interaction (call -> result -> LLM) | One-way communication (LLM -> external)         |
| Return value    | Result is crucial for next LLM step         | Result usually not directly needed by LLM       |
| State mutation  | Commonly used to update context state       | Can update state but less common                |
| Usage pattern   | LLM requests data or triggers process       | LLM communicates final response or notification |
| Error handling  | Errors often returned to LLM for reaction   | Errors handled internally (logged/retried)      |

### When to Use Outputs vs. Actions

- **Use outputs when**: The primary goal is to communicate outward (send a
  message, display UI, log data), and you **don't** need the result of that
  communication for the LLM's immediate next reasoning step.
- **Use actions when**: You need the **result** of the operation (e.g., data
  fetched from an API, status of a transaction) for the LLM to continue its
  reasoning process or make subsequent decisions.

## Best Practices for Outputs

1. **Keep outputs focused**: Each output definition should have a single, clear
   responsibility (e.g., `discord:message`, `log:event`).
2. **Handle errors gracefully**: The `handler` should contain `try...catch`
   blocks for external calls and report failures appropriately (e.g., log an
   error, perhaps emit an `error` event) without crashing the agent.
3. **Consider asynchronous processing**: For outputs involving potentially slow
   external systems, ensure the `handler` is `async` and handles the operation
   without blocking the main agent loop excessively.
4. **Track important outputs in context**: If the fact that an output occurred
   is important for future agent decisions (e.g., remembering a message was
   sent), update the relevant context memory within the `handler`.
5. **Use descriptive names and schemas**: Clearly define the `type`, `schema`,
   and `attributes` so the LLM understands exactly how to use the output.
   Provide good `examples`.

Outputs allow the agent to respond and communicate, completing the interaction
loop initiated by Inputs and guided by Actions.

--- End File: docs/content/docs/concepts/outputs.mdx ---

--- File: docs/content/docs/concepts/prompting.mdx ---
---
title: Prompting
description:
  How Daydreams structures prompts to guide LLM reasoning and actions.
---

The interaction between the Daydreams framework and the Large Language Model
(LLM) is mediated through carefully structured prompts. These prompts provide
the LLM with the necessary context, instructions, available tools (actions and
outputs), and current state, guiding its reasoning process and constraining its
output format.

## The Main Prompt Template (`mainPrompt`)

The core prompt structure is defined in `packages/core/src/prompts/main.ts`
within the `mainPrompt` configuration object. It uses a main template string
(`promptTemplate`) composed of several sections identified by placeholders:

```text
{{intro}}      # General instructions for the agent's task
{{instructions}} # Step-by-step guide on how to process updates
{{content}}    # Dynamically generated section with available tools and state
{{response}}   # Structure definition for the LLM's expected output
{{footer}}     # Final reminders and important notes
```

Each placeholder (`{{intro}}`, `{{instructions}}`, etc.) corresponds to static
text providing overall guidance to the LLM on how it should behave within the
framework.

## Dynamic Prompt Generation

At each step of the [Agent Lifecycle](/docs/concepts/agent-lifecycle), the
framework dynamically generates the content for the `{{content}}` section of the
`promptTemplate`. This ensures the LLM always has the most up-to-date
information.

1.  **Gathering Data (`formatPromptSections`)**: The `formatPromptSections`
    function (in `packages/core/src/prompts/main.ts`) collects the current
    state, including:
    - Available `actions`.
    - Available `outputs`.
    - Active `contexts` and their rendered state.
    - Recent `WorkingMemory` logs (both processed and unprocessed).
2.  **Formatting to XML (`packages/core/src/formatters.ts`)**: Various helper
    functions (`formatAction`, `formatContextState`, `formatOutputInterface`,
    `formatContextLog`, `formatValue`, `formatXml`) convert these JavaScript
    objects and data structures into standardized XML strings. This XML format
    is designed to be clearly parsable by both the LLM and the framework's
    stream parser.
3.  **Rendering (`render`)**: The `render` function (from
    `packages/core/src/formatters.ts`) injects these dynamically generated XML
    strings into the main `promptTemplate`, replacing placeholders like
    `{{actions}}`, `{{outputs}}`, `{{contexts}}`, `{{workingMemory}}`, and
    `{{updates}}`.

## Key XML Sections in the Prompt

The dynamically generated `{{content}}` section typically includes these crucial
XML blocks:

- **`<available-actions>`**: Lists all actions currently enabled for the agent.
  Each action includes its `name`, `description`, `instructions`, and argument
  `schema` (as JSON schema).
  ```xml
  <available-actions>
    <action name="getWeather">
      <description>Fetches the current weather...</description>
      <schema>{ "type": "object", "properties": { ... } }</schema>
    </action>
    ...
  </available-actions>
  ```
- **`<available-outputs>`**: Lists all outputs the agent can generate. Each
  output includes its `type`, `description`, `instructions`, content `schema`
  (`content_schema`), attribute `schema` (`attributes_schema`), and `examples`.
  ```xml
  <available-outputs>
    <output type="discord:message">
      <description>Sends a message...</description>
      <attributes_schema>{ "type": "object", ... }</attributes_schema>
      <content_schema>{ "type": "string", ... }</content_schema>
      <examples>...</examples>
    </output>
    ...
  </available-outputs>
  ```
- **`<contexts>`**: Displays the state of currently active contexts, as rendered
  by their respective `render` functions.
  ```xml
  <contexts>
    <context type="chat" key="session123">
      user1: Hi there!
      agent: Hello! How can I help?
    </context>
    ...
  </contexts>
  ```
- **`<working-memory>`**: Shows _processed_ logs (`InputRef`, `OutputRef`,
  `ActionCall`, `ActionResult`, `Thought`, `EventRef`) from previous steps
  within the _current_ run.
  ```xml
  <working-memory>
    <input type="cli:message" timestamp="...">User message</input>
    <action_call name="lookupUser" id="..." timestamp="...">...</action_call>
    <action_result callId="..." name="lookupUser" timestamp="...">...</action_result>
    <output type="cli:message" timestamp="...">Agent response</output>
  </working-memory>
  ```
- **`<updates>`**: Shows _new_, _unprocessed_ logs (typically new `InputRef`s or
  `ActionResult`s from the previous step) that the LLM needs to analyze and
  react to in the _current_ step.
  ```xml
  <updates>
    <input type="discord:message" timestamp="...">A new message requiring a response</input>
    <action_result callId="..." name="complexCalculation" timestamp="...">Result is 42</action_result>
  </updates>
  ```

## Expected LLM Response Structure

The framework instructs the LLM (via the `{{response}}` section of the template)
to structure its output using specific XML tags:

```xml
<response>
  <reasoning>
    [LLM's thought process explaining its analysis and plan]
  </reasoning>

  [Optional: Action calls]
  <action_call name="actionName">[Arguments based on action schema and format (JSON/XML)]</action_call>

  [Optional: Outputs]
  <output type="outputType" attribute1="value1">[Content matching the output's schema]</output>
</response>
```

- **`<response>`**: The root tag for the entire response.
- **`<reasoning>`**: Contains the LLM's step-by-step thinking process. This is
  logged as a `Thought`.
- **`<action_call>`**: Used to invoke an action. The `name` must match an
  available action. The content (arguments) depends on the action's defined
  `schema` and `callFormat` (defaulting to JSON if schema is complex, but can be
  XML). The framework parses this content accordingly.
- **`<output>`**: Used to generate an output. The `type` must match an available
  output. Any required `attributes` must be included, and the content must match
  the output's content `schema`.

The framework parses this XML structure from the LLM's response stream to
trigger the corresponding handlers for actions and outputs.

## Template Engine (`{{...}}`)

The prompt template includes a mention of a simple template engine using
`{{...}}` syntax (e.g., `{{calls[0].someValue}}`, `{{shortTermMemory.key}}`). As
noted in the prompt comments, its primary intended use is for **intra-turn data
referencing**. This means allowing an action call within the _same_ LLM response
to reference the anticipated result of a _previous_ action call in that _same_
response.

Example:

```xml
<response>
  <reasoning>First, I need to create a file, then write to it.</reasoning>
  <action_call name="createFile">{ "directory": "/tmp" }</action_call>
  <action_call name="writeFile">{ "fileId": "{{calls[0].fileId}}", "content": "Hello!" }</action_call>
</response>
```

Here, the `writeFile` call references the `fileId` expected to be returned by
the `createFile` action called just before it within the same LLM response turn.
The framework resolves these templates _before_ executing the action handlers
(using `resolveTemplates` in `packages/core/src/handlers.ts`).

This dynamic and structured prompting approach allows Daydreams to effectively
leverage LLMs for complex orchestration tasks, providing them with the necessary
information and tools while ensuring their output can be reliably processed.

--- End File: docs/content/docs/concepts/prompting.mdx ---

--- File: docs/content/docs/concepts/tasks.mdx ---
---
title: Tasks
description: Managing asynchronous operations and concurrency.
---

Daydreams agents often need to perform asynchronous operations, primarily when
executing [Actions](/docs/concepts/actions) that interact with external APIs,
blockchains, or other time-consuming processes. The framework includes a
`TaskRunner` to manage these operations efficiently.

## Purpose

The `TaskRunner` serves two main purposes:

1.  **Concurrency Control:** It limits the number of asynchronous tasks (like
    action handlers) that run simultaneously. This prevents the agent from
    overwhelming external services with too many requests at once (rate
    limiting) or consuming excessive local resources.
2.  **Prioritization (Future):** While the core framework primarily uses default
    priority, the underlying queue supports prioritizing tasks, allowing more
    critical operations to potentially execute sooner.

## Initialization and Configuration

A `TaskRunner` instance is automatically created within `createDreams` unless a
custom one is provided in the `Config`. Its concurrency limit can be configured:

```typescript
import { createDreams, TaskRunner } from "@daydreamsai/core";

// Default TaskRunner with concurrency based on environment or default (e.g., 3)
const agent1 = createDreams({
  /* ... */
});

// Explicitly configure concurrency
const agent2 = createDreams({
  // ... other config
  taskRunner: new TaskRunner(5), // Allow up to 5 tasks concurrently
});

// Access the runner later
const runner = agent2.taskRunner;
```

The concurrency limit determines how many tasks from the internal queue can be
actively running at any given moment.

## Key Implications for Users

While you typically don't interact directly with the `TaskRunner` or define new
`task` types, understanding how it works is important for writing effective
agent components, especially [Actions](/docs/concepts/actions):

1.  **Actions are Queued & Run Concurrently:** When the LLM calls an action via
    `<action_call>`, its `handler` is scheduled by the `TaskRunner`, not
    executed immediately. The runner processes tasks concurrently up to its
    configured limit (default is 3). If more actions are called than the limit
    allows, they wait in a queue.
    - _Effect:_ Prevents overwhelming external services; actions might not start
      instantly if the runner is busy.
2.  **`async`/`await` is Essential:** Because action handlers are executed
    asynchronously via the Task Runner, any I/O operations (API calls, database
    queries, file system access) within your handler **must** use
    `async`/`await` correctly. The framework waits for the promise returned by
    the handler (managed by the Task Runner) to resolve before considering the
    action complete.
3.  **Action `retry` Option & Idempotency:** You can configure automatic retries
    for an action using the `retry` property in its definition. If enabled, the
    `TaskRunner` will re-execute the handler if it fails (throws an error).
    - _Best Practice:_ If using retries, design your action handlers to be
      **idempotent** – meaning executing the handler multiple times with the
      same arguments yields the same final state without unwanted side effects
      (e.g., avoid creating duplicate database entries).
4.  **Action Cancellation (`ctx.abortSignal`):** Action handlers receive an
    `AbortSignal` within their `ctx` (`ActionCallContext`).
    - _Requirement:_ For long-running handlers (e.g., complex loops, waiting for
      external processes), you **should** check `ctx.abortSignal.aborted`
      periodically or use `ctx.abortSignal.throwIfAborted()` and cease execution
      if the signal is aborted. This allows agent runs to be cancelled cleanly.
5.  **`queueKey` Option (Advanced):** Actions can specify a `queueKey`. This
    directs the `TaskRunner` to use a specific queue for that action. While the
    default is `'main'`, this advanced feature could be used with custom
    `TaskRunner` configurations to manage different concurrency limits for
    different types of actions (e.g., a separate queue with lower concurrency
    for a rate-limited API).

In summary, focus on writing robust, `async`-aware, and potentially idempotent
action handlers, leveraging `ctx.abortSignal` for cancellation. The Task Runner
handles the scheduling and concurrency control behind the scenes.

## Internal Usage (`runAction`)

The most common use of the `TaskRunner` is internal to the framework. When the
agent parses an `<action_call>` from the LLM, the `handleActionCall` function
doesn't execute the action's handler directly. Instead, it uses
`taskRunner.enqueueTask` to schedule the execution:

```typescript
// Simplified logic within handleActionCall (handlers.ts)

// ... prepare context and arguments ...

result.data = await taskRunner.enqueueTask(
  runAction, // The task definition for running actions
  {
    // Parameters for runAction
    action,
    agent,
    logger,
    ctx: callCtx,
  },
  {
    // Options for the task enqueueing
    debug: agent.debugger,
    retry: action.retry,
    abortSignal,
    priority: 0, // Default priority
  }
);

// ... process result ...
```

This ensures that action executions respect the concurrency limits set for the
agent.

## Defining Tasks (`task` helper)

The framework uses a `task` helper function (from `@daydreamsai/core/task`) to
define named, reusable asynchronous operations that can be managed by the
`TaskRunner`. Key framework tasks like `runAction` (executing action handlers)
and `runGenerate` (calling the LLM) are defined using this helper.

```typescript
import { task, type TaskContext } from "@daydreamsai/core";

// Example task definition (similar to runAction)
const myCustomTask = task(
  // 1. Unique key/name for the task (used for logging/debugging)
  "agent:run:myCustomTask",

  // 2. The async function implementing the task logic
  async (params: { someData: string }, ctx: TaskContext) => {
    // 'params' are the arguments passed when enqueuing
    // 'ctx' provides task-specific context

    ctx.debug("myCustomTask", ["Executing"], params); // Use debug provided via options
    console.log(`Task ${ctx.callId} running with data:`, params.someData);

    // ... perform asynchronous work ...
    await new Promise((resolve) => setTimeout(resolve, 100));

    return { success: true, taskId: ctx.callId };
  },

  // 3. Optional default TaskOptions
  {
    retry: 1, // Default retry count
  }
);

// How it might be enqueued:
// agent.taskRunner.enqueueTask(myCustomTask, { someData: "hello" }, { priority: 1 });
```

The `TaskContext` passed to the task function includes:

- `callId`: A unique ID generated for this specific task execution.
- `debug`: A `Debugger` function instance (configured via `TaskOptions` or
  defaulting from agent config).

While you typically won't need to define new tasks often (most work happens in
action handlers), understanding this pattern helps clarify how core operations
like `runAction` are structured and managed.

## Direct Usage

While primarily used internally for actions, you _could_ access the `TaskRunner`
via `agent.taskRunner` within your custom code (e.g., inside an action handler
or context hook) if you need to manage additional complex, long-running, or
resource-intensive asynchronous operations with concurrency control. However,
simple `async/await` within action handlers is usually sufficient.

The `TaskRunner` provides robust management for the asynchronous operations
essential to the agent's functioning, ensuring stability and controlled resource
usage.

--- End File: docs/content/docs/concepts/tasks.mdx ---

--- File: docs/content/docs/contributing.mdx ---
---
title: Contributing
description: Contributing to Daydreams.
---

## Contributing

Looking to contribute? We'd love your help, dreamer.

If you are a developer and would like to contribute with code, please check out
our [GitHub repository](https://github.com/daydreamsai/daydreams) and open an
issue to discuss before opening a Pull Request.

## Star History

<a href="https://www.star-history.com/#daydreamsai/daydreams&Date">
  <picture>
    <source
      media="(prefers-color-scheme: dark)"
      srcSet="https://api.star-history.com/svg?repos=daydreamsai/daydreams&type=Date&theme=dark"
    />
    <source
      media="(prefers-color-scheme: light)"
      srcSet="https://api.star-history.com/svg?repos=daydreamsai/daydreams&type=Date"
    />
    <img
      alt="Star History Chart"
      src="https://api.star-history.com/svg?repos=daydreamsai/daydreams&type=Date"
    />
  </picture>
</a>

--- End File: docs/content/docs/contributing.mdx ---

--- File: docs/content/docs/extra-reading/container.mdx ---
---
title: container.ts
---

This file provides a system called a "Dependency Injection (DI) Container",
created using `createContainer()`. Its main job is to manage shared resources or
services that different parts of your agent might need, like a connection to an
external API, a database client, or the agent's logger. It ensures these
resources are created correctly and makes them easily accessible wherever
needed.

## How to Use

You generally **don't create or directly interact** with the container yourself
using `createContainer()`. The Daydreams framework creates one automatically
when you call `createDreams`.

- **Registering:** Services (defined using the `service` helper) or Extensions
  use the container's `register`, `singleton`, or `instance` methods internally
  to tell the container _how_ to create or find a specific resource (e.g.,
  "Here's how to make the database client"). `singleton` is common for resources
  you only want one of (like a database connection).
- **Accessing:** When your `action` handler (or other component) needs to use a
  shared resource managed by the container, you access it through the `agent`
  object: `agent.container.resolve<ResourceType>('resourceName')`. For example,
  to get the logger, you might use `agent.container.resolve<Logger>('logger')`.

## Benefit

The container decouples your code. Your action handler doesn't need to know
_how_ to create the database client or logger; it just asks the container for it
by name (`'database'`, `'logger'`). This makes your code cleaner, easier to
test, and simplifies managing shared resources, especially within extensions. If
the way a resource is created changes, you only need to update its registration,
not every place it's used.

## Anticipated Questions

- _"Do I need to call `createContainer()`?"_ No, the agent created by
  `createDreams` already includes a pre-configured container available at
  `agent.container`.
- _"How do things get into the container?"_ Typically through `ServiceProvider`
  definitions (created with the `service` helper), which are often bundled
  within `Extension`s. The service's `register` method puts things into the
  container. Core framework components like the default `Logger` are also
  registered automatically.
- _"What's the difference between `register` and `singleton`?"_ When
  registering, `singleton` ensures only _one instance_ of the resource is ever
  created and shared. `register` creates a _new instance_ every time `resolve`
  is called for that name (less common for shared resources).

--- End File: docs/content/docs/extra-reading/container.mdx ---

--- File: docs/content/docs/extra-reading/context.mdx ---
---
title: context.ts
---

This file provides the essential `context` function, which you use to define
different "modes" or "workspaces" for your agent. Think of each context
definition as a blueprint for a specific task or interaction type, like handling
a chat conversation, managing a game, or performing a specific workflow. Each
active instance of a context (e.g., a specific chat session) gets its own
separate memory and state.

## How to Use

You'll typically define your contexts in separate files using the
`context({...})` function and then pass these definitions to `createDreams`. Key
things you define inside `context({...})`:

- `type`: A unique name for this type of context (e.g., `"chat"`,
  `"projectBoard"`).
- `schema`: (Using Zod) Defines the arguments needed to identify a _specific
  instance_ of this context (e.g., `{ sessionId: z.string() }` for a chat).
- `create`: A function that returns the initial structure and default values for
  this context's persistent memory (`ctx.memory`). This runs the first time an
  instance is accessed.
- `render`: (Optional) A function that formats the current state (`ctx.memory`)
  of an instance into text (or XML) for the AI model to understand the current
  situation within that specific workspace.
- `actions`, `inputs`, `outputs`: (Optional, often added via `.setActions()`,
  etc.) Link specific tools (Actions), data sources (Inputs), and response
  methods (Outputs) directly to this context type.

## Benefit

Contexts allow your agent to manage multiple tasks or interactions
simultaneously without getting confused. Each context instance has its own
dedicated memory (`ctx.memory`) where it stores relevant information (like chat
history or task lists) persistently. The `render` function ensures the AI model
gets only the relevant state for the specific task it's working on at that
moment. Associating actions/inputs/outputs keeps your agent's capabilities
organized.

## Anticipated Questions

- _"What's the difference between context memory (`ctx.memory`) and working
  memory?"_ `ctx.memory` is the _persistent_ storage for a specific context
  instance (like chat history saved to a database). _Working memory_ is
  _temporary_ storage used during a single agent run cycle to track the steps
  (inputs, thoughts, actions) of that specific interaction.
- _"How do I identify a specific chat session if I have multiple?"_ You use the
  `schema` you define to pass identifying arguments (like a `sessionId`) when
  calling `agent.run` or `agent.send`. The optional `key` function in the
  context definition helps create truly unique IDs if needed (e.g.,
  `chat:session-xyz`).
- _"How does the AI know what happened in this specific chat?"_ The `render`
  function you define formats the relevant parts of `ctx.memory` (e.g., recent
  messages) and includes it in the prompt sent to the AI model for that specific
  context instance.

--- End File: docs/content/docs/extra-reading/context.mdx ---

--- File: docs/content/docs/extra-reading/dreams.mdx ---
---
title: dreams.ts
---

This file provides the `createDreams` function, which is the main entry point
for building your Daydreams agent. Think of it as the constructor or blueprint
for your AI assistant. It takes all your configurations (like which AI model to
use, what tools it has, how it remembers things) and assembles them into a
ready-to-run agent.

## How to Use

You'll call `createDreams({...})` once in your project setup, passing it a
configuration object. This object specifies:

- `model`: Which language model (like OpenAI's GPT or Anthropic's Claude) the
  agent should use for thinking (using providers from the Vercel AI SDK).
- `extensions`: Pre-built packages of functionality (like Discord integration or
  file system access) you want your agent to have.
- `contexts`: Custom definitions for different tasks or conversations your agent
  needs to manage.
- `actions`: Custom tools or abilities you define for your agent.
- `memory`: How the agent should store and recall information (e.g., using
  in-memory storage or a database like MongoDB).
- _(and other optional configurations)_

The function returns an `agent` object. You'll then typically call
`await agent.start()` to initialize it and `agent.send(...)` or `agent.run(...)`
to give it tasks or information to process.

## Benefit

It provides a single, organized way to configure and initialize your entire
agent. Instead of manually wiring up all the different parts (model, memory,
tools), `createDreams` handles the setup and dependencies, letting you focus on
defining your agent's capabilities and behavior.

## Anticipated Questions

- _"Do I need to provide all configuration options?"_ No, many options have
  sensible defaults (like basic memory storage). You typically only need to
  provide the `model` and any `extensions` or custom `actions`/`contexts` you
  want to use.
- _"What's the difference between `agent.send()` and `agent.run()`?"_
  `agent.send()` is typically used when an external event happens (like a user
  sending a message), providing the input data. `agent.run()` is the underlying
  method that processes information, reasons, and takes action; `send` usually
  calls `run` internally.
- _"Where do I define things like actions and contexts?"_ You usually define
  them in separate files and import them into your main setup file where you
  call `createDreams`.

--- End File: docs/content/docs/extra-reading/dreams.mdx ---

--- File: docs/content/docs/extra-reading/formatters.mdx ---
---
title: formatters.ts
---

This file contains helper functions that translate the agent's internal data
(like your action definitions, context state, and logs) into the structured XML
format the AI model expects to see in its prompt. It also helps format Zod
schemas into JSON schemas for the prompt.

## How it Affects You

You don't need to call functions like `formatAction` or `formatContextState`
directly. The framework uses them automatically when preparing the prompt for
the AI model during each step of an `agent.run`. For example:

- When you define an `action` with a description and schema, `formatAction`
  converts that definition into the `<action>` XML block seen in the prompt.
- When you define a `render` function for your `context`, the output of your
  function is placed inside the `<state>` tag within the `<context>` XML block
  generated by `formatContextState`.
- The `formatSchema` function ensures the Zod schemas you define for actions,
  outputs, etc., are translated into a format the AI model can understand within
  the prompt's `<schema>` tags.

## Benefit

These formatters ensure that all the information the agent needs to give the AI
model (available tools, current state, recent history) is presented in a
consistent, structured way (XML) that the model is trained to understand. This
standardization makes the communication between your agent's code and the AI
model reliable. You don't have to worry about manually creating complex XML
prompts.

## Anticipated Questions

- _"Do I need to write XML?"_ No. You define your components using
  JavaScript/TypeScript objects (via helpers like `action`, `context`, etc.).
  These formatters handle the conversion to XML automatically before sending the
  prompt to the AI.
- _"Why does Daydreams use XML in prompts?"_ XML provides a clear way to
  structure complex information (like nested states, lists of tools with
  descriptions and schemas) for the AI model, making it easier for the model to
  parse and understand the different parts of the prompt.
- _"What is the `render` function in this file used for?"_ It's primarily used
  internally by the framework to assemble the main prompt template by inserting
  the formatted XML blocks (like actions, contexts, logs) into the correct
  placeholders.

--- End File: docs/content/docs/extra-reading/formatters.mdx ---

--- File: docs/content/docs/extra-reading/handlers.mdx ---
---
title: handlers.ts
---

This file holds the internal "handlers" that the Daydreams agent uses during its
execution cycle (`agent.run`). When the agent receives input, or when the AI
model decides to call an action or send an output, the functions in this file
are responsible for processing those requests correctly. Think of it as the
agent's internal dispatcher and validator.

## How it Affects You

You don't call functions from this file directly. It works behind the scenes,
but it's where several important things happen based on how you defined your
actions, inputs, and outputs:

- **Validation:** When the AI model provides arguments for your `action` or
  content/attributes for your `output`, the code here validates that data
  against the `schema` you defined using Zod. If the validation fails, it
  prevents your `handler` code from running with bad data.
- **Parsing:** It parses the arguments/content provided by the AI model (which
  might be in JSON or XML format) into a usable JavaScript object/value before
  passing it to your `handler`.
- **Template Resolution:** If you use templates like `{{calls[0].someValue}}` in
  your action arguments (as described in [Prompting](/docs/concepts/prompting)),
  the `resolveTemplates` function here handles resolving those values _before_
  your action's `handler` is called.
- **Handler Execution:** It prepares the necessary context (including the
  correct memory scopes like `ctx.memory` or `ctx.actionMemory`) and then calls
  the specific `handler` function you wrote in your `action`, `input`, or
  `output` definition. For actions, it uses the `TaskRunner` to queue the
  execution.
- **Error Handling:** It defines specific errors like `NotFoundError` (if the AI
  calls a non-existent action/output) and `ParsingError` (if validation fails).

## Benefit

These handlers ensure that the interaction between the AI model's requests and
your custom code (in action/output/input handlers) is safe, validated, and
correctly contextualized. It bridges the gap between the AI's structured text
output and the execution of your JavaScript/TypeScript functions, handling
potential errors and data transformations along the way.

## Anticipated Questions

- _"Is this where my `action`'s `handler` function actually runs?"_ Yes,
  functions in this file (specifically `handleActionCall` which uses `runAction`
  from `tasks/index.ts`) are responsible for preparing the context and
  ultimately calling the `handler` you defined for your action (via the
  `TaskRunner`).
- _"What happens if the AI provides arguments that don't match my action's Zod
  schema?"_ The validation logic within `prepareActionCall` in this file will
  catch the mismatch, throw a `ParsingError`, and prevent your action's
  `handler` from being called with invalid data.
- _"How does the agent know which specific context's memory (`ctx.memory`) to
  give my action handler?"_ The logic here (within functions like
  `prepareActionCall` and `handleOutput`) identifies the correct `ContextState`
  based on the current run and makes its `memory` available in the `ctx` object
  passed to your handler.

--- End File: docs/content/docs/extra-reading/handlers.mdx ---

--- File: docs/content/docs/extra-reading/http.mdx ---
---
title: http.ts
---

This file provides a convenient helper object named `http` for making network
requests to external APIs or web services from within your agent's actions. It's
essentially a smarter version of the standard web `fetch` command.

## How to Use

When you write an `action` handler that needs to fetch data from or send data to
an external API, you can import and use this `http` object.

- For simple GET requests expecting JSON data:

  ```typescript
  import { http } from "@daydreamsai/core";

  // Inside an action handler:
  try {
    const data = await http.get.json<{ someField: string }>(
      "https://api.example.com/data?id=123"
    );
    console.log(data.someField);
    return { success: true, result: data };
  } catch (error) {
    console.error("API call failed:", error);
    return { success: false, error: "API failed" };
  }
  ```

- For POST requests sending JSON data:

  ```typescript
  import { http } from "@daydreamsai/core";

  // Inside an action handler:
  const payload = { name: "Widget", value: 42 };
  try {
    const response = await http.post.json(
      "https://api.example.com/create",
      payload
    );
    return { success: true, id: response.id };
  } catch (error) {
    // ... handle error ...
  }
  ```

- It also includes helpers for specific protocols like `http.jsonrpc(...)` and
  `http.graphql(...)`.

## Benefit

- **Automatic Retries:** The key benefit is built-in automatic retries. If a
  network request fails due to a temporary network issue or a specific server
  error (like 500 or 503), the `http` helper will automatically wait a bit and
  try the request again a few times before giving up. This makes your actions
  more resilient to temporary glitches.
- **Convenience:** Provides shortcuts for common tasks like setting JSON
  headers, parsing JSON responses, and adding query parameters (`params`
  option).

## Anticipated Questions

- _"Do I have to use this instead of `fetch`?"_ No, you can still use the
  standard `fetch` API directly in your actions if you prefer. However, using
  the `http` helper gives you the automatic retry logic for free.
- _"How do I set custom headers (like Authorization)?"_ You can pass standard
  `fetch` options (like `headers`) as the last argument to the `http` methods
  (e.g.,
  `http.get.json(url, params, { headers: { 'Authorization': 'Bearer ...' } })`).

--- End File: docs/content/docs/extra-reading/http.mdx ---

--- File: docs/content/docs/extra-reading/introduction.mdx ---
---
title: introduction
---

# The Git-Gud Guide to Daydreams

This started out as a collection of notes from a hobbyist developer trying to
understand the `@daydreamsai/core` package more deeply. The goal isn't to be an
exhaustive API reference, but rather a practical guide – "extra reading" – to
help you grasp the purpose and role of the key TypeScript files that make up the
core framework.

## What's Here?

Each page in this section dives into a specific Typescript file from the core
library. You'll find explanations focusing on:

- **What it is:** A high-level description of the file's purpose.
- **How it Affects You / How to Use:** Practical information on whether you
  interact with it directly and how it fits into building your agent.
- **Benefit:** Why this component exists and what advantages it offers.
- **Anticipated Questions:** Answers to common questions a developer might have
  when encountering this part of the framework.

## How to Approach It

Think of these pages as supplementary material to the main concepts and
tutorials. If you're wondering _why_ something works the way it does in
Daydreams, or what's happening under the hood when you make a call or define an
action, browsing the relevant file explanations here might provide valuable
context.

You can start by using the search or dive into specific files as you encounter
them in your development.

--- End File: docs/content/docs/extra-reading/introduction.mdx ---

--- File: docs/content/docs/extra-reading/logger.mdx ---
---
title: logger.ts
---

This file provides the `Logger` class used throughout the Daydreams framework
for recording informational messages, warnings, and errors that occur during
agent execution. It helps you understand what your agent is doing and diagnose
problems.

## How to Use

You don't typically create a `Logger` instance yourself. The agent object
returned by `createDreams` already has a pre-configured logger available at
`agent.logger`. You use this instance inside your `action` handlers, `context`
lifecycle methods, or `service` definitions to log relevant information:

```typescript
import {
  action,
  type ActionCallContext,
  type AnyAgent,
} from "@daydreamsai/core";

export const myAction = action({
  name: "processData",
  // ... schema ...
  async handler(args, ctx: ActionCallContext, agent: AnyAgent) {
    // Log informational message
    agent.logger.info("processData:handler", "Starting data processing", {
      inputArgs: args,
    });

    try {
      // ... do some work ...
      const result = { status: "completed" };
      // Log successful completion (at debug level)
      agent.logger.debug("processData:handler", "Processing successful", {
        result,
      });
      return result;
    } catch (error) {
      // Log an error
      agent.logger.error("processData:handler", "Processing failed!", {
        error,
      });
      throw error; // Re-throw or handle error
    }
  },
});
```

- Common methods are `agent.logger.info()`, `agent.logger.warn()`,
  `agent.logger.error()`, `agent.logger.debug()`, and `agent.logger.trace()`.
- Each method takes a `context` string (often the function/component name), a
  `message` string, and optional `data` object.

## Benefit

Provides a standard way to record what's happening inside your agent. This is
crucial for:

- **Debugging:** Seeing the flow of execution, variable values, and errors.
- **Monitoring:** Understanding how your agent is performing in production.
- **Auditing:** Keeping a record of important events or decisions. The default
  logger prints messages to the console with timestamps, levels, and context,
  making it easy to follow along.

## Anticipated Questions

- _"How can I change the logging level (e.g., see DEBUG messages)?"_ You can set
  the `logLevel` option when calling `createDreams`. For example:
  `createDreams({ ..., logLevel: LogLevel.DEBUG })`. The levels are `ERROR`,
  `WARN`, `INFO`, `DEBUG`, `TRACE` (most verbose).
- _"Can I send logs somewhere other than the console?"_ Yes, the logger is
  designed with "transports". While the default is `ConsoleTransport`, you could
  potentially implement custom transports (though this is an advanced topic not
  covered here) and provide them via the `logger` or `transports` option in
  `createDreams`.
- _"Why provide a `context` string (like `'processData:handler'`)?"_ It helps
  identify _where_ in the code the log message originated, which is very useful
  for debugging complex agents.

--- End File: docs/content/docs/extra-reading/logger.mdx ---

--- File: docs/content/docs/extra-reading/memory.mdx ---
---
title: memory.ts
---

These files define the agent's memory system. `base.ts` provides the fundamental
building blocks: `MemoryStore` for saving and loading the persistent state of
your contexts (like chat history), and `VectorStore` for storing "episodic
memories" (learned experiences) using vector embeddings for later recall.
`utils.ts` contains helpers, primarily for automatically generating those
episodic memories using an LLM.

## How to Use

You configure the agent's memory system via the `memory` option when calling
`createDreams`.

- You typically provide implementations for `MemoryStore` and `VectorStore`.
- The core package provides simple defaults: `createMemoryStore()` (stores data
  in memory, lost on restart) and `createVectorStore()` (does nothing).
- For real persistence, you'll import and use implementations from other
  Daydreams packages, like `@daydreamsai/mongo` for MongoDB
  (`createMongoMemoryStore`) or `@daydreamsai/chroma` for ChromaDB
  (`createChromaVectorStore`).
- The `createMemory` function (exported from `base.ts`) is used to bundle your
  chosen store implementations together for the `memory` option.

```typescript
import { createDreams, createMemory } from '@daydreamsai/core';
// Import specific store implementations
import { createMongoMemoryStore } from '@daydreamsai/mongo';
import { createChromaVectorStore } from '@daydreamsai/chroma';

const agent = createDreams({
  model: /* ... */,
  memory: createMemory(
    // Use MongoDB for context state
    await createMongoMemoryStore({ uri: 'mongodb://...' }),
    // Use ChromaDB for episodic memory/vector search
    createChromaVectorStore('my-agent-episodes')
  ),
  // Optional: Enable automatic episodic memory generation
  // generateMemories: true,
  // vectorModel: openai('text-embedding-3-small') // Model for embeddings
});
```

- Episodic memory generation (from `utils.ts`) happens automatically in the
  background if you set `generateMemories: true` in the agent config and provide
  a `VectorStore`.

## Benefit

Allows your agent to have both persistent state (remembering conversations or
task progress across restarts via `MemoryStore`) and the ability to learn from
past interactions (recalling relevant experiences via `VectorStore` and episodic
memory). You can choose storage backends suitable for your needs (simple
in-memory for testing, robust databases for production).

## Anticipated Questions

- _"Do I need both MemoryStore and VectorStore?"_ `MemoryStore` is essential for
  saving the state of your `context` instances (like `ctx.memory`).
  `VectorStore` is only needed if you want the agent to use episodic memory
  (learning from past interactions using embeddings). You can use the default
  `createVectorStore()` if you don't need episodic memory.
- _"What is episodic memory?"_ It's a feature where the agent summarizes
  sequences of thought -> action -> result into "episodes". These are stored as
  vector embeddings. When the agent encounters a new situation, it can search
  its `VectorStore` for similar past episodes to potentially inform its current
  reasoning. (Requires `generateMemories: true` and a `VectorStore`).
- _"Where does `ctx.memory` get saved?"_ The agent automatically saves the
  `memory` property of your `ContextState` instances to the configured
  `MemoryStore` at the end of each run cycle.

--- End File: docs/content/docs/extra-reading/memory.mdx ---

--- File: docs/content/docs/extra-reading/meta.json ---
{
  "pages": [
    "introduction",
    "package-managers",
    "dreams",
    "context",
    "prompt",
    "memory",
    "handlers",
    "tasks",
    "container",
    "serviceProvider",
    "formatters",
    "logger",
    "http",
    "providers-api",
    "types",
    "utils"
  ]
}

--- End File: docs/content/docs/extra-reading/meta.json ---

--- File: docs/content/docs/extra-reading/package-managers.mdx ---
---
title: package managers
---

It's worth mentioning the role of a good package manager, especially for rapid
development and monorepos. Wondering which one to use? The simple answer:
**[Bun](https://bun.sh/package-manager)**

## **Why?**

For the hobbyist developer, Bun offers several compelling advantages:

- **Speed:** Bun reduces wait time for installing dependencies, running scripts,
  and starting your application/agent.

- **Simplicity:** Bun acts as a runtime, package manager, bundler, and test
  runner rolled into one. This eliminates the need to learn, configure, and
  manage multiple separate tools. Keep it clean.

- **Ease of Use:** No more needing separate compilation steps (`tsc`) before
  running your code (`node index.js`). Bun runs TypeScript directly.

Essentially, Bun lets hobbyists focus more on building cool things and less on
wrangling complex development toolchains.

--- End File: docs/content/docs/extra-reading/package-managers.mdx ---

--- File: docs/content/docs/extra-reading/prompt.mdx ---
---
title: prompt.ts
---

This file offers general tools for working with prompt templates and parsing
structured (XML) responses, separate from the main agent prompt defined in
`prompts/main.ts`. It provides `createPrompt` for making reusable prompt
templates and `createParser` for defining how to extract data from XML text into
a specific JavaScript object structure.

## How to Use

While the core agent loop uses its own specific prompt, you might use these
helpers in more advanced scenarios, perhaps within an `action` handler:

- `createPrompt`: If an action needs to call _another_ LLM for a sub-task, you
  could use `createPrompt` to define a reusable template for that specific
  sub-task prompt.

  ```typescript
  import { createPrompt } from "@daydreamsai/core";

  const summarizeTemplate = createPrompt<{ textToSummarize: string }>(
    "Please summarize the following text concisely:\n{{textToSummarize}}"
  );

  // Later, in an action handler:
  const subTaskPrompt = summarizeTemplate({ textToSummarize: someLongText });
  // const summary = await callAnotherLLM(subTaskPrompt);
  ```

- `createParser`: If an action receives a complex XML response from an external
  system (or perhaps even from a specialized LLM call), you could use
  `createParser` to define precisely how to extract the necessary data from the
  XML tags into a structured JavaScript object.

## Benefit

Provides flexible utilities for developers who need to implement custom prompt
generation or response parsing logic within their actions or extensions, beyond
the standard agent interaction loop. `createPrompt` helps manage reusable prompt
strings, and `createParser` offers a structured way to handle custom XML parsing
needs.

## Anticipated Questions

- _"Is this the main prompt the agent uses?"_ No, the main prompt template and
  its formatting logic are primarily defined in
  `packages/core/src/prompts/main.ts`. This file (`prompt.ts`) provides more
  general, optional tools for custom prompt/parsing scenarios.
- _"When would I need `createParser`?"_ It's less common, but potentially useful
  if an action interacts with a system that returns data in a specific XML
  format, and you want a structured way to extract information based on tag
  names.

--- End File: docs/content/docs/extra-reading/prompt.mdx ---

--- File: docs/content/docs/extra-reading/providers-api.mdx ---
---
title: providers/api.ts
---

This file provides helper functions for interacting with external APIs within
your agent's actions or services. The main exported function is `fetchGraphQL`,
designed specifically to simplify making requests to GraphQL APIs.

## How to Use

If you need to query a GraphQL endpoint from an `action` handler, you can import
`fetchGraphQL` from `@daydreamsai/core`.

```typescript
import { action, fetchGraphQL } from "@daydreamsai/core";
import type { AnyAgent, ActionCallContext } from "@daydreamsai/core";

const GRAPHQL_ENDPOINT = "https://api.example.com/graphql";

interface UserData {
  user: { id: string; name: string };
}

export const getUserAction = action({
  name: "getUserData",
  schema: z.object({ userId: z.string() }),
  async handler(args, ctx: ActionCallContext, agent: AnyAgent) {
    const query = `
      query GetUser($id: ID!) {
        user(id: $id) {
          id
          name
        }
      }
    `;
    const variables = { id: args.userId };

    try {
      const result = await fetchGraphQL<UserData>(
        GRAPHQL_ENDPOINT,
        query,
        variables
      );

      if (result instanceof Error) {
        agent.logger.error("getUserAction", "GraphQL query failed", {
          error: result.message,
        });
        return { success: false, error: result.message };
      }

      agent.logger.info("getUserAction", "Got user data", {
        user: result.user,
      });
      return { success: true, userData: result.user };
    } catch (error) {
      agent.logger.error("getUserAction", "Fetch failed", { error });
      return { success: false, error: "Network error" };
    }
  },
});
```

## Benefit

`fetchGraphQL` handles the boilerplate of setting up a GraphQL POST request
(setting headers, stringifying the query and variables). It also provides basic
error handling, returning an `Error` object if the GraphQL response indicates
errors, which you can check for using `instanceof Error`. This makes interacting
with GraphQL APIs from your actions cleaner and less error-prone than using
`fetch` directly for this specific case.

## Anticipated Questions

- _"Is there a helper for REST APIs?"_ While `api.ts` contains a `fetchRest`
  function, it doesn't seem to be exported directly via `@daydreamsai/core`. For
  general REST calls, you would typically use the `http` helper object (from
  `http.ts`) which provides automatic retries, or the standard `fetch` API.
- _"How does this differ from the `http` helper?"_ The `http` object provides
  general-purpose HTTP request helpers (GET, POST, JSON) with automatic retries.
  `fetchGraphQL` is specifically tailored for the GraphQL protocol, formatting
  the request body correctly and performing basic GraphQL-specific error checks
  on the response.

--- End File: docs/content/docs/extra-reading/providers-api.mdx ---

--- File: docs/content/docs/extra-reading/serviceProvider.mdx ---
---
title: serviceProvider.ts
---

This file provides the `service` helper function, which you use to define how
shared resources or external clients (like an API client, database connection,
or special utility) should be managed by the Daydreams framework. It ensures
these services are set up correctly and are ready to use when your agent needs
them.

## How to Use

You typically define a service in its own file using `service({...})` and then
include it in an `Extension`. Inside the `service({...})` call, you can define:

- `register(container)`: (Optional) A function where you tell the agent's DI
  Container (`agent.container`) how to create this service instance. Often,
  you'll use
  `container.singleton('serviceName', () => new MyServiceClient(...))` here to
  ensure only one instance is created.
- `boot(container)`: (Optional) An `async` function where you perform any
  necessary initialization _after_ all services have been registered (e.g.,
  connecting to the API using credentials maybe resolved from the container).
  This runs when `agent.start()` is called.

```typescript
import { service, type Container } from "@daydreamsai/core";

// Assume MyApiClient class exists
declare class MyApiClient {
  constructor(config: { url: string });
  connect(): Promise<void>;
}

export const myApiService = service({
  register(container: Container) {
    // Tell the container how to create the client (as a singleton)
    container.singleton(
      "myApiClient",
      () => new MyApiClient({ url: "https://api.example.com" })
    );
  },
  async boot(container: Container) {
    // Initialize the client after registration
    const client = container.resolve<MyApiClient>("myApiClient");
    await client.connect();
    console.log("My API Client connected!");
  },
});

// Typically, you would then include `myApiService` in an extension's `services` array.
```

## Benefit

Defining services this way ensures proper setup and teardown, especially for
resources needing asynchronous initialization (`boot`). It integrates smoothly
with the DI Container, making services easily accessible via
`agent.container.resolve('serviceName')` in your actions or other components,
without them needing to know the setup details. Bundling services in Extensions
makes them reusable.

## Anticipated Questions

- _"When should I use a `service` vs just putting logic in an `action`?"_ Use a
  `service` for shared, reusable components, especially those managing
  connections to external systems or requiring specific setup/initialization
  steps (`boot`). Actions are better for defining specific _tasks_ the agent can
  perform, which might _use_ one or more services obtained from the container.
- _"What's the difference between `register` and `boot`?"_ `register` runs first
  and only tells the container _how_ to create the service. `boot` runs later
  (during `agent.start()`) and performs the actual initialization (like
  connecting), potentially using other services that were registered earlier.
- _"Do I need to call `createServiceManager()`?"_ No, this is handled internally
  by `createDreams`. You just define your services using the `service` helper.

--- End File: docs/content/docs/extra-reading/serviceProvider.mdx ---

--- File: docs/content/docs/extra-reading/tasks.mdx ---
---
title: task.ts
---

These files define the system (`TaskRunner`) that manages how your agent runs
asynchronous operations, especially the `handler` functions inside your custom
`action` definitions. Think of it as a queue manager that prevents your agent
from trying to do too many things at once, particularly when actions involve
waiting for external APIs or services.

## How it Affects You

You don't directly use the `TaskRunner` or the `task` function yourself.
However, its existence impacts how you write your `action` handlers:

- **Concurrency:** By default, the agent only runs a few action handlers
  simultaneously (e.g., 3). If the AI model asks the agent to perform many
  actions quickly, some will wait in a queue managed by the `TaskRunner` before
  they start executing. This prevents overwhelming external services.
- **Asynchronous Code:** Because actions are run through this system, your
  `action` handlers **must** use `async` and `await` correctly if they perform
  any operations that take time (like network requests `fetch`, database calls,
  or even just `setTimeout`). The `TaskRunner` waits for the `Promise` returned
  by your `async handler` to finish.
- **Retries:** You can add a `retry` option when defining an `action`. If the
  action's handler fails (throws an error), the `TaskRunner` will automatically
  try running it again a few times. If you use this, try to make your handler
  logic _idempotent_ (safe to run multiple times with the same input).
- **Cancellation:** Long-running actions should check for cancellation signals.
  Inside your `action` handler, the `ctx` object contains an `abortSignal`. You
  should check `ctx.abortSignal.aborted` periodically in long loops or
  before/after long waits and stop execution if it's `true`. This allows the
  agent's overall run to be cancelled cleanly if needed.

## Benefit

The `TaskRunner` automatically handles concurrency limits and retries for your
actions, making your agent more stable and preventing it from accidentally
overloading external systems you interact with. It ensures asynchronous
operations are managed correctly within the agent's lifecycle.

## Anticipated Questions

- _"Do I need to create a `TaskRunner`?"_ No, `createDreams` creates one for you
  automatically with default settings.
- _"How do I know when my action handler actually runs?"_ It runs shortly after
  the AI model calls the action, but it might be delayed slightly if the
  `TaskRunner`'s queue is busy with other actions. Use `agent.logger` inside
  your handler to see when it starts and finishes.
- _"What if my action needs to run for a very long time?"_ Make sure to
  implement the cancellation check using `ctx.abortSignal.aborted` so the agent
  can stop it if necessary.

--- End File: docs/content/docs/extra-reading/tasks.mdx ---

--- File: docs/content/docs/extra-reading/types.mdx ---
---
title: types.ts
---

This file acts as the central dictionary for all the data structures used within
the Daydreams framework. It defines the specific "shape" (using TypeScript types
and interfaces) that different pieces of data should have, such as what
information defines an `Action`, what goes into a `Context`, or what the `Agent`
object looks like.

## How to Use

You generally **don't need to change** this file. However, you'll interact with
the types defined here frequently when writing your agent code:

- **Type Hints:** When defining the `handler` for your `action`, `input`, or
  `output`, you'll often use types imported from `@daydreamsai/core` (which
  ultimately come from this file) to get auto-completion and type safety for the
  arguments passed to your function (like the `args`, `ctx`, and `agent`
  parameters).

  ```typescript
  import {
    action,
    type ActionCallContext,
    type AnyAgent,
  } from "@daydreamsai/core";
  import { z } from "zod";

  // Define the memory structure for a specific context
  interface MyChatMemory {
    history: { role: "user" | "agent"; text: string }[];
  }

  // Use ActionCallContext with your memory type for the 'ctx' parameter
  export const myAction = action({
    name: "reply",
    schema: z.object({ message: z.string() }),
    handler: async (
      args,
      ctx: ActionCallContext<any, any, MyChatMemory>,
      agent: AnyAgent
    ) => {
      // Now, ctx.memory is correctly typed as MyChatMemory
      ctx.memory.history.push({ role: "agent", text: args.message });
      // agent parameter is typed as AnyAgent
    },
  });
  ```

- **Defining Memory:** When you define a `context`, you'll often create an
  `interface` for its specific memory structure (like `MyChatMemory` above).
  This interface defines the shape of the data stored in `ctx.memory` for that
  context.
- **Understanding Logs:** If you work with the detailed execution logs
  (`agent.run` results), the types like `InputRef`, `OutputRef`, `ActionCall`,
  `ActionResult`, `Thought` define the structure of each log entry.

## Benefit

Using the types defined here makes your code safer and easier to write. Your
code editor can provide helpful auto-completion and immediately warn you if
you're using a component incorrectly (e.g., trying to access a property that
doesn't exist on the `ctx` object or passing the wrong type of argument to an
action). It acts as a form of documentation, clarifying what data is available
where.

## Anticipated Questions

- _"Do I need to import types directly from `types.ts`?"_ No, you should import
  types directly from the main package entry point:
  `import type { Action, Context, Agent } from '@daydreamsai/core';`.
- _"There are so many types! Which ones are most important?"_ The most common
  ones you'll likely encounter when building your agent are `Agent`, `Context`,
  `Action`, `Input`, `Output`, `ActionCallContext`, `ContextState`,
  `WorkingMemory`, `MemoryStore`, `VectorStore`, and the various `Ref` types
  (`InputRef`, `OutputRef`, etc.) if you inspect execution logs. Many others are
  for internal framework use.
- _"I see types like `AnyAction`. Is it easier to use those instead of specific
  ones like `Action<MySchema, ...>`?"_ While using `AnyAction` might seem
  simpler because you don't need to specify detailed types, it's generally **not
  recommended**, especially when starting out. Using specific types gives you
  significant advantages:

  1.  **Type Safety:** TypeScript can check your code for errors _before_ you
      run it (e.g., did you misspell a property name in `ctx.memory`? Are you
      using the action's `args` correctly?). `AnyAction` turns these checks off,
      leading to potential runtime bugs that are harder to find.
  2.  **Auto-completion:** Your code editor can provide helpful suggestions for
      properties and methods when you use specific types, making coding faster
      and reducing typos. This doesn't work well with `AnyAction`.
  3.  **Clarity:** Specific types make your code easier to understand for
      yourself and others. It clearly shows what data an action expects and
      uses.

  It's better practice to define Zod schemas for action arguments and interfaces
  for context memory, then use those in your definitions (e.g.,
  `Action<typeof mySchema, MyResult, MyMemoryInterface>`).

--- End File: docs/content/docs/extra-reading/types.mdx ---

--- File: docs/content/docs/extra-reading/utils.mdx ---
---
title: utils.ts
---

This file provides essential "factory" functions that you use to define the
building blocks of your Daydreams agent, such as its tools (Actions), how it
receives information (Inputs), how it responds (Outputs), how it remembers
things specifically for an action (Memory), and how you bundle features together
(Extensions).

## How to Use

You'll import these functions directly from `@daydreamsai/core` when defining
your agent's components, typically in separate files.

- `action({...})`: Use this to define a specific capability or tool for your
  agent. You give it a `name`, `description`, expected arguments (`schema` using
  Zod), and the `handler` code that runs when the AI decides to use this tool.
  (See [Actions](/docs/concepts/actions) for details).

  ```typescript
  import { action } from "@daydreamsai/core";
  import { z } from "zod";

  export const myAction = action({
    name: "myTool",
    description: "Does something cool.",
    schema: z.object({ param: z.string() }),
    handler: async (args, ctx, agent) => {
      /* ... */
    },
  });
  ```

- `input({...})`: Use this to define how your agent receives information from
  the outside world (like a chat message or an API event). You specify how to
  `subscribe` to the source and how to `send` incoming data into the agent for
  processing. (See [Inputs](/docs/concepts/inputs)).
- `output({...})`: Use this to define how your agent sends information out (like
  replying to a chat). You give it a `type`, expected content structure
  (`schema`), and the `handler` code that performs the sending. (See
  [Outputs](/docs/concepts/outputs)).
- `extension({...})`: Use this to package related actions, inputs, outputs,
  contexts, and services together into a reusable module. You provide a `name`
  and arrays/objects containing the components this extension provides. (See
  [Services & Extensions](/docs/advanced)).
- `memory({...})`: A specialized helper used within an `action` definition if
  that specific action needs its own persistent memory across different calls
  (less common than context memory). You provide a `key` and a `create` function
  for its initial state.

## Benefit

These functions provide a standardized way to define the different parts of your
agent. They ensure all the necessary configuration details are provided and
integrate smoothly with the agent's lifecycle and the AI model. They abstract
away the internal wiring, letting you focus on the logic of your agent's
capabilities.

## Anticipated Questions

- _"Do I use these functions inside `createDreams`?"_ No, you typically use
  these functions in separate files to define your actions, inputs, etc., and
  then you import those definitions and pass them _to_ `createDreams` in its
  configuration object (e.g., in the `actions: [...]` or `extensions: [...]`
  arrays).
- _"What's the difference between `action` and `output`?"_ Use `action` when the
  agent needs to perform a task and get a result back to continue thinking (like
  looking up information). Use `output` when the agent just needs to send
  information out (like sending a final reply message).

--- End File: docs/content/docs/extra-reading/utils.mdx ---

--- File: docs/content/docs/guides/deep.mdx ---
---
title: Deep Research
description:
  This guide will walk you through creating an AI agent that can perform deep
  research using Daydreams.
---

You can find a deep-research example in the
[examples](https://github.com/daydreamsai/daydreams/tree/main/examples/deep-research)
directory.

Detailed tutorial coming soon!

--- End File: docs/content/docs/guides/deep.mdx ---

--- File: docs/content/docs/guides/giga.mdx ---
---
title: Building a Gigaverse Game Agent
description:
  This guide will walk you through creating an AI agent that can play the
  Gigaverse dungeon crawler game using Daydreams.
---

This guide will walk you through creating an AI agent that can play the
Gigaverse dungeon crawler game using Daydreams.

## Prerequisites

Before starting, make sure you have:

1. A Gigaverse account
2. The following environment variables set up:
   - `ANTHROPIC_API_KEY`: Your Anthropic API key
   - `GIGA_TOKEN`: Your Gigaverse authentication token (Bearer token from
     browser)

## Creating the Agent

First, let's create a basic Gigaverse agent:

```ts
import { anthropic } from "@ai-sdk/anthropic";
import {
  createDreams,
  context,
  render,
  action,
  validateEnv,
  LogLevel,
  type Agent,
} from "@daydreamsai/core";
import { cliExtension } from "@daydreamsai/cli";
import { string, z } from "zod";

// Validate environment variables
const env = validateEnv(
  z.object({
    ANTHROPIC_API_KEY: z.string().min(1, "ANTHROPIC_API_KEY is required"),
    GIGA_TOKEN: z.string().min(1, "GIGA_TOKEN is required"),
  })
);

// Define the goal-oriented context
const goalContexts = context({
  type: "goal",
  schema: z.object({
    id: string(),
    initialGoal: z.string(),
    initialTasks: z.array(z.string()),
  }),

  key({ id }) {
    return id;
  },

  create(state) {
    return {
      goal: state.args.initialGoal,
      tasks: state.args.initialTasks ?? [],
      currentTask: state.args.initialTasks?.[0],
    };
  },

  render({ memory }) {
    return render(template, {
      goal: memory.goal,
      tasks: memory.tasks.join("\n"),
      currentTask: memory.currentTask ?? "NONE",
    });
  },
});

// Create the Gigaverse agent
createDreams({
  logger: LogLevel.INFO,
  model: anthropic("claude-3-7-sonnet-latest"),
  extensions: [cliExtension],
  context: goalContexts,
  actions: [
    // Actions will be defined below
  ],
}).start({
  id: "gigaverse-agent",
  initialGoal: "Successfully complete a dungeon run in Gigaverse",
  initialTasks: [
    "Start a new dungeon run",
    "Make strategic combat decisions using rock-paper-scissors mechanics",
    "Select optimal loot after defeating enemies",
    "Progress as far as possible in the dungeon",
  ],
});
```

## How It Works

The Gigaverse agent is built using several key components:

1. **Context Template**: Defines the agent's understanding of the game and its
   current state:

```ts
const template = `
# Gigaverse Dungeon Game

You are an AI agent playing a rock-paper-scissors dungeon crawler game.

## Game Rules:
- Combat is resolved through rock-paper-scissors mechanics
- You can collect loot after defeating enemies
- Your goal is to progress as far as possible in the dungeon

## Current Status:
Goal: {{goal}} 
Tasks: {{tasks}}
Current Task: {{currentTask}}

Make strategic decisions based on enemy patterns and your current state.
`;
```

2. **Game Actions**: The agent can perform several actions in the game:

   - `attackInDungeon`: Make combat decisions (rock, paper, scissors) or select
     loot
   - `getPlayerState`: Retrieve the current game state
   - `startNewRun`: Begin a new dungeon run

## Understanding Gigaverse Game Mechanics

Gigaverse is a dungeon crawler game with the following key mechanics:

1. **Rock-Paper-Scissors Combat**: Battles are resolved using the classic
   rock-paper-scissors game:

   - Rock beats Scissors
   - Scissors beats Paper
   - Paper beats Rock

2. **Dungeon Progression**: Players advance through the dungeon by defeating
   enemies.

3. **Loot System**: After defeating enemies, players can select one of three
   loot options to enhance their character.

4. **Health Management**: Players must manage their health throughout the
   dungeon run.

## Core Game Actions

Let's implement the three main actions needed for the Gigaverse agent:

### 1. Attack in Dungeon

This action handles both combat (rock-paper-scissors) and loot selection:

```ts
action({
  name: "attackInDungeon",
  description: "Attack in the dungeon using rock-paper-scissors game mechanics",
  schema: z
    .object({
      action: z
        .enum([
          "rock",
          "paper",
          "scissor",
          "loot_one",
          "loot_two",
          "loot_three",
        ])
        .describe("The attack move to make"),
      dungeonId: z
        .number()
        .default(0)
        .describe("The ID of the dungeon"),
    })
    .describe(
      "You use this to make an action in a dungeon. If the lootPhase == true then you can select the Loot option, which will then take you to the next phase. If the lootPhase == false then you can select the Rock, Paper, Scissors option."
    ),
  async handler(data, ctx, agent) {
    try {
      const { action, dungeonId } = data;

      const payload = {
        action: action,
        actionToken: new Date().getTime().toString(),
        dungeonId: dungeonId,
      };

      const response = await fetch(
        "https://gigaverse.io/api/game/dungeon/action",
        {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${env.GIGA_TOKEN}`,
          },
          body: JSON.stringify(payload),
        }
      );

      if (!response.ok) {
        throw new Error(`Attack action failed with status ${response.status}`);
      }

      const result = await response.json();
      return {
        success: true,
        result,
        message: `Successfully performed ${action} attack in dungeon ${dungeonId}`,
      };
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : String(error);
      return {
        success: false,
        error: errorMessage,
        message: "Attack action failed",
      };
    }
  },
}),
```

### 2. Get Player State

This action retrieves the current state of the player in the dungeon:

```ts
action({
  name: "getPlayerState",
  description: "Get the current state of the player in the dungeon",
  schema: z.object({}),
  async handler(data, ctx, agent) {
    try {
      const response = await fetch(
        "https://gigaverse.io/api/game/dungeon/state",
        {
          method: "GET",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${env.GIGA_TOKEN}`,
          },
        }
      );

      if (!response.ok) {
        throw new Error(`Fetch player state failed with status ${response.status}`);
      }

      const result = await response.json();
      return {
        success: true,
        playerState: result,
        message: "Successfully fetched player's dungeon state",
      };
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : String(error);
      return {
        success: false,
        error: errorMessage,
        message: "Failed to fetch player's dungeon state",
      };
    }
  },
}),
```

### 3. Start New Run

This action initiates a new dungeon run:

```ts
action({
  name: "startNewRun",
  description: "Start a new dungeon run. Use this when the player dies or wants to start a new run from outside the dungeon.",
  schema: z.object({
    dungeonId: z
      .number()
      .default(1)
      .describe("The ID of the dungeon to start. Default is 1."),
  }),
  async handler(data, ctx, agent) {
    try {
      const { dungeonId } = data;

      const payload = {
        action: "start_run",
        actionToken: new Date().getTime().toString(),
        dungeonId: dungeonId,
      };

      const response = await fetch(
        "https://gigaverse.io/api/game/dungeon/action",
        {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${env.GIGA_TOKEN}`,
          },
          body: JSON.stringify(payload),
        }
      );

      if (!response.ok) {
        throw new Error(`Start new run failed with status ${response.status}`);
      }

      const result = await response.json();
      return {
        success: true,
        result,
        message: `Successfully started a new run in dungeon ${dungeonId}`,
      };
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : String(error);
      return {
        success: false,
        error: errorMessage,
        message: "Failed to start a new dungeon run",
      };
    }
  },
}),
```

## Agent Decision Making

The agent uses the context and player state to make strategic decisions. Here's
how the agent approaches the game:

1. **Analyzing Enemy Patterns**:

   - The agent observes patterns in enemy moves over multiple encounters
   - It can identify if an enemy favors certain moves (like using "rock" more
     frequently)
   - This information helps the agent make counter-moves (like choosing "paper"
     against a "rock"-favoring enemy)

2. **Loot Selection Strategy**:

   - After defeating enemies, the agent evaluates the three loot options
   - It considers the player's current health, inventory, and progression
   - The agent selects loot that complements the player's build or addresses
     weaknesses

3. **Adaptive Gameplay**:

   - As the dungeon difficulty increases, the agent adjusts its strategy
   - It may prioritize health-restoring items when health is low
   - The agent can become more conservative or aggressive based on the player's
     current state

4. **Goal-Oriented Planning**:
   - The agent maintains awareness of its overall goal and current tasks
   - It can reprioritize tasks based on the changing game state
   - This ensures the agent makes decisions that contribute to long-term success

## Integrating with Daydreams

This example showcases several key Daydreams features:

1. **Goal-Oriented Context**: The agent maintains a structured goal and task
   list.

2. **Action Definitions**: Clear, typed actions with Zod schemas for validation.

3. **API Integration**: Seamless interaction with external APIs (Gigaverse in
   this case).

4. **Error Handling**: Robust error handling to manage API failures gracefully.

## Next Steps

- Customize the agent's strategy by modifying the context template
- Add more sophisticated decision-making logic
- Implement inventory management and character progression
- Extend the agent to handle more complex game scenarios

For a more thorough demonstration of API implementation for Gigaverse, you can
find the complete example in the
[examples](https://github.com/daydreamsai/daydreams/tree/main/examples/games/gigaverse)
directory.

--- End File: docs/content/docs/guides/giga.mdx ---

--- File: docs/content/docs/guides/introduction.mdx ---
---
title: Introduction
description: Bootstrap your first Daydreams agent.
---

## Bootstrapping a New Agent

The easiest way to get started with Daydreams is to use the CLI tool:

### Install the CLI

```bash
npm install -g @daydreamsai/create-agent
```

### Create a new agent

```bash
npx @daydreamsai/create-agent dreaming-agent
```

This will scaffold a new agent project with all the necessary files and
dependencies.

### Navigate to your project

```bash
cd dreaming-agent
```

### Configure Environment

Copy the `.env.example` file to `.env` and fill in your API keys.

```bash
cp .env.example .env
```

### Start your agent

```bash
npm start
# or use bun
# bun run index.ts
```

## Complete Example

Here's a minimal example of a Daydreams agent using the CLI extension:

```ts
import { createDreams } from "@daydreamsai/core";
import { cli } from "@daydreamsai/core/extensions";
import { groq } from "@daydreamsai/core/models";

const agent = createDreams({
  model: groq("deepseek-r1-distill-llama-70b"),
  extensions: [cli],
}).start();
```

This will run the agent in the terminal. Talk to it!

For more detailed usage, check out the other guides or explore the
[Concepts](/docs/concepts/core) section.

--- End File: docs/content/docs/guides/introduction.mdx ---

--- File: docs/content/docs/guides/mcp-guide.mdx ---
---
title: Model Context Protocol (MCP) Guide for Daydreams
---

This guide explains how to use the Model Context Protocol (MCP) integration with
Daydreams, allowing your agents to connect to MCP servers and access their
resources, tools, and prompts.

More information about MPC specification can be found in the
[MCP Github](https://github.com/modelcontextprotocol/specification).

## What is MCP?

The Model Context Protocol (MCP) is a standardized way for applications to
provide context to Large Language Models (LLMs). It separates the concerns of
providing context from the actual LLM interaction, allowing for a more modular
and flexible architecture.

Key benefits of MCP include:

- **Standardization**: A common protocol for context exchange between
  applications and LLMs
- **Separation of concerns**: Applications can focus on providing context, while
  LLMs can focus on processing it
- **Modularity**: Connect to multiple context sources simultaneously
- **Extensibility**: Add new context sources without changing the core
  application

## MCP in Daydreams

Daydreams provides a built-in MCP extension that allows your agents to:

- Connect to multiple MCP servers simultaneously
- Access resources from MCP servers
- Execute tools provided by MCP servers
- Use prompts defined on MCP servers

## Getting Started

### Prerequisites

Before you begin, make sure you have:

- Daydreams installed
- Node.js 18 or later
- An MCP server to connect to (or you can use the example server provided)

### Installation

1. Create a new Daydreams project or use an existing one
2. Install the required dependencies:

```bash
npm install @daydreamsai/core @modelcontextprotocol/sdk @ai-sdk/anthropic
# or
yarn add @daydreamsai/core @modelcontextprotocol/sdk @ai-sdk/anthropic
# or
pnpm add @daydreamsai/core @modelcontextprotocol/sdk @ai-sdk/anthropic
```

### Basic Setup

To connect your Daydreams agent to an MCP server, add the MCP extension to your
agent configuration:

```typescript
import { createDreams } from "@daydreamsai/core";
import { mcpExtension } from "@daydreamsai/mcp";
import { anthropic } from "@ai-sdk/anthropic";
import path from "path";

// Create an agent with the MCP extension
createDreams({
  model: anthropic("claude-3-7-sonnet-latest"),

  // Add the MCP extension with server configuration
  extensions: [
    mcpExtension([
      {
        id: "example-server",
        name: "Example Resource Server",
        transport: {
          type: "stdio",
          command: "node",
          args: [path.join(__dirname, "mcp-server-example.mjs")],
        },
      },
    ]),
  ],
}).start();
```

## Creating a Simple MCP Server

Here's how to create a simple MCP server that provides a tool and a resource:

```javascript
// mcp-server-example.mjs
import {
  McpServer,
  ResourceTemplate,
} from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { ListToolsRequestSchema } from "@modelcontextprotocol/sdk/types.js";
import { z } from "zod";

// Create an MCP server
const server = new McpServer({
  name: "Demo",
  version: "1.0.0",
});

// Add an addition tool
server.tool("add", { a: z.number(), b: z.number() }, async ({ a, b }) => ({
  content: [{ type: "text", text: String(a + b) }],
}));

// Add a dynamic greeting resource
server.resource(
  "greeting",
  new ResourceTemplate("greeting://{name}", { list: undefined }),
  async (uri, { name }) => ({
    contents: [
      {
        uri: uri.href,
        text: `Hello, ${name}!`,
      },
    ],
  })
);

// List available tools
server.resource(ListToolsRequestSchema, async () => {
  return {
    tools: [
      {
        name: "add",
        description: "Add two numbers",
        parameters: {
          a: { type: "number" },
          b: { type: "number" },
        },
      },
    ],
  };
});

// Start receiving messages on stdin and sending messages on stdout
const transport = new StdioServerTransport();
await server.connect(transport);
```

## Conclusion

The MCP integration in Daydreams provides a powerful way to connect your agents
to external data sources and tools. By following this guide, you should be able
to create agents that can interact with MCP servers and leverage their
capabilities to build more sophisticated AI applications.

For more information, refer to:

- [MCP TypeScript SDK documentation](https://github.com/modelcontextprotocol/typescript-sdk)

--- End File: docs/content/docs/guides/mcp-guide.mdx ---

--- File: docs/content/docs/guides/meta.json ---
{
  "pages": ["introduction", "supabase", "giga", "mcp-guide", "twitter", "deep"]
}

--- End File: docs/content/docs/guides/meta.json ---

--- File: docs/content/docs/guides/supabase.mdx ---
---
title: Supabase
description:
  This guide will walk you through creating an AI agent that utilizes supabase
  as the memory store.
---

## Using Supabase with Daydreams

Setup Info:

- Vector Model Provider: `gpt-4-turbo` via `@ai-sdk/openai`
- Model Provider: `google/gemini-2.0-flash-001` via
  `@openrouter/ai-sdk-provider`
- Memory Store: Supabase via `@daydreamsai/supabase`
- Communication method: Command Line via `@daydreamsai/cli`

Initialize a project and add our setup packages

```bash
bun init
bun add @daydreamsai/core @daydreamsai/supabase @daydreamsai/cli @ai-sdk/openai @openrouter/ai-sdk-provider
```

After installing the packages, go to
[https://supabase.com/](https://supabase.com/) and create a new project. Once
your project is created, you'll need to add the two environment variables
necessary for this package to your environment.

```bash
# Supabase
SUPABASE_URL=YOUR_SUPABASE_URL
SUPABASE_SERVICE_KEY=YOUR_SUPABASE_SERVICE_KEY

# Other variables used in this example
OPENROUTER_API_KEY=YOUR_SUPABASE_SERVICE_KEY
OPENAI_API_KEY=YOUR_OPENAI_KEY
OPENROUTER_API_KEY=YOUR_OPENROUTER_KEY
```

These variables are provided by Supabase when you create the project and can be
found in your project settings:Data API.

Next, you need to set up the necessary database structure for the agent's
memory. Copy the following SQL code block and paste in the Supabase SQL Editor
(found in the sidebar):

```sql
-- Enable the pgvector extension if it's not already enabled
-- This is crucial for vector similarity search used by SupabaseVectorStore
CREATE EXTENSION IF NOT EXISTS vector;

-- Function to enable pgvector extension (might be used internally by SupabaseVectorStore)
CREATE OR REPLACE FUNCTION enable_pgvector_extension()
RETURNS void
LANGUAGE plpgsql
AS $$
BEGIN
  CREATE EXTENSION IF NOT EXISTS vector;
END;
$$;

-- Function to execute arbitrary SQL (potentially used by SupabaseVectorStore for initialization)
-- SECURITY DEFINER allows the function to run with the privileges of the user who defines it,
-- necessary for operations like creating tables or extensions if the calling user doesn't have direct permissions.
-- Ensure you understand the security implications before using SECURITY DEFINER.
CREATE OR REPLACE FUNCTION execute_sql(query text)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  EXECUTE query;
END;
$$;
```

Afterards you should see a success message like "Success. No rows returned".

With the Supabase setup complete, let's create the agent in our `index.ts`:

```ts
// This example shows how to use Supabase with DaydreamsAI.

// Vector Model Provider: gpt-4-turbo                    via @ai-sdk/openai
// Model Provider:        google/gemini-2.0-flash-001    via @openrouter/ai-sdk-provider
// Memory Store:          @daydreamsai/supabase
// CLI Extension:         @daydreamsai/cli

import { openai } from "@ai-sdk/openai";
import {
  createContainer,
  createDreams,
  Logger,
  LogLevel,
  validateEnv,
} from "@daydreamsai/core";
import { createSupabaseBaseMemory } from "@daydreamsai/supabase";
import { z } from "zod";
import { cliExtension } from "@daydreamsai/cli";
import { openrouter } from "@openrouter/ai-sdk-provider";

validateEnv(
  z.object({
    OPENAI_API_KEY: z.string().min(1, "OPENAI_API_KEY is required"),
    SUPABASE_URL: z.string().min(1, "SUPABASE_URL is required"),
    SUPABASE_SERVICE_KEY: z.string().min(1, "SUPABASE_SERVICE_KEY is required"),
  })
);

const agent = createDreams({
  container: createContainer(),
  logger: new Logger({ level: LogLevel.DEBUG }),
  model: openrouter("google/gemini-2.0-flash-001"),
  extensions: [cliExtension],
  memory: createSupabaseBaseMemory({
    url: process.env.SUPABASE_URL!,
    key: process.env.SUPABASE_SERVICE_KEY!,
    memoryTableName: "agent",
    vectorTableName: "agentVectors",
    vectorModel: openai("gpt-4-turbo"),
  }),
});

// Agent starts
await agent.start();
```

Run the agent and chat via the command line interface!

```
bun run index.ts
```

--- End File: docs/content/docs/guides/supabase.mdx ---

--- File: docs/content/docs/guides/twitter.mdx ---
---
title: Building a Twitter Agent
description:
  This guide will walk you through creating an AI agent that can interact with
  Twitter using DreamsAI.
---

## Prerequisites

Before starting, make sure you have:

1. A Twitter developer account
2. The following environment variables set up:
   - `GROQ_API_KEY`: Your Groq API key

## Creating the Agent

First, let's create a basic Twitter agent:

```ts
import { createGroq } from "@ai-sdk/groq";
import {
  createContainer,
  createDreams,
  LogLevel,
  twitter,
} from "@daydreamsai/core";

// Initialize Groq client
const groq = createGroq({
  apiKey: process.env.GROQ_API_KEY!,
});

// Create the agent
const agent = createDreams({
  logger: LogLevel.DEBUG,
  container: createContainer(),
  model: groq("deepseek-r1-distill-llama-70b"),
  extensions: [twitter],
});

// Start the agent
await agent.start();
```

## How It Works

The Twitter agent is created using a few key components:

1. **Groq Integration**: We use Groq's language model for processing and
   understanding Twitter interactions.

2. **Logger**: Set to DEBUG level for detailed logging during development.

3. **Container**: Manages dependencies and services.

4. **Twitter Extension**: The `twitter` extension provides built-in capabilities
   for:
   - Monitoring mentions
   - Replying to tweets
   - Posting new tweets
   - Managing Twitter authentication

## Next Steps

- Set up Twitter authentication in your environment variables
- Customize the agent's behavior by adding your own extensions
- Implement specific use cases like auto-replies or content monitoring

For the full twitter example, check out the
[Example-Twitter](https://github.com/daydreamsai/daydreams/tree/main/examples/twitter)
on Github.

--- End File: docs/content/docs/guides/twitter.mdx ---

--- File: docs/content/docs/index.mdx ---
---
title: Getting Started
description: Build your first Daydreams agent.
---

> ⚠️ **Warning**: This is alpha software under active development. Expect
> frequent breaking changes and bugs. The API is not yet stable.

## Overview

Daydreams is a framework for building autonomous AI agents. At its core, an
agent analyzes incoming information (inputs), reasons about it using a Large
Language Model (LLM), and decides on the next steps, which could be generating a
response (output) or performing a task (action). The results of actions feed
back into the agent's awareness, creating a continuous loop orchestrated by the
LLM.

This allows you to build agents that can interact with various systems like
blockchains, social media, APIs, and more, based on goals and context.

**🚀 Ready to dive in? Check out the
[Getting Started Guide](/docs/guides/getting-started) to build your first
agent!**

## Installation

You can install the core Daydreams package and the CLI helper using npm or bun:

```bash
npm install @daydreamsai/core @daydreamsai/cli
# or
bun add @daydreamsai/core @daydreamsai/cli
```

You will also need an LLM provider SDK, for example, OpenAI:

```bash
npm install @ai-sdk/openai
# or
bun add @ai-sdk/openai
```

Make sure you have an `OPENAI_API_KEY` environment variable set.

## Core Concepts

Daydreams is built around a few key ideas:

- **[Agent Lifecycle](/docs/concepts/agent-lifecycle):** The central
  orchestrator that runs the main loop.
- **[Contexts](/docs/concepts/contexts):** Manages the state and memory for a
  specific task or interaction (e.g., a chat session).
- **[Inputs](/docs/concepts/inputs):** How agents receive information (e.g., CLI
  messages, API events).
- **[Outputs](/docs/concepts/outputs):** How agents respond or send information
  out (e.g., CLI responses, tweets).
- **[Actions](/docs/concepts/actions):** Tasks agents can perform (e.g., calling
  an API, executing a transaction).
- **[Memory](/docs/concepts/memory):** How agents store and recall information
  (working memory, episodic memory).

Dive deeper into these in the [Core Concepts](/docs/concepts/core) section.

## Your First Agent (CLI Echo Bot)

Let's create a simple agent that echoes back whatever you type in the command
line.

**1. Set up your project:**

```bash
mkdir my-first-agent
cd my-first-agent
npm init -y
npm install @daydreamsai/core @daydreamsai/cli @ai-sdk/openai zod
# or use bun
# bun init
# bun add @daydreamsai/core @daydreamsai/cli @ai-sdk/openai zod
```

**2. Create `agent.ts`:**

```typescript
import { createDreams, context, input, output } from "@daydreamsai/core";
import { cliExtension } from "@daydreamsai/cli";
import { openai } from "@ai-sdk/openai";
import { z } from "zod";

// 1. Define the main context for our agent
const echoContext = context({
  type: "echo",
  // No specific args needed for this simple context
  schema: z.object({}),
  // Instructions for the LLM
  instructions:
    "You are a simple echo bot. Repeat the user's message back to them.",
});

// 2. Create the agent instance
const agent = createDreams({
  // Use the OpenAI model
  model: openai("gpt-4o-mini"),
  // Include the CLI extension for input/output
  extensions: [cliExtension],
  // Register our custom context
  contexts: [echoContext],
});

// 3. Start the agent and run the context
async function main() {
  // Start the agent (initializes services like readline)
  await agent.start();

  console.log("Echo agent started. Type 'exit' to quit.");

  // Run our echo context. Since it uses the cliExtension,
  // it will automatically start listening for console input.
  // We use {} for args because our context schema is an empty object.
  await agent.run({
    context: echoContext,
    args: {},
  });

  // Agent stops when the input loop (in cliExtension) breaks (e.g., on "exit")
  console.log("Agent stopped.");
}

main();
```

**3. Run the agent:**

Make sure your `OPENAI_API_KEY` environment variable is set.

```bash
node agent.ts
```

Now you can type messages, and the agent should echo them back using the CLI
input and output handlers provided by `cliExtension`.

---

_Next Steps: Explore the [Core Concepts](/docs/concepts/core) or check out the
other [Guides](/docs/guides/getting-started) for more complex examples._

--- End File: docs/content/docs/index.mdx ---

--- File: docs/content/docs/meta.json ---
{
  "pages": [
    "index",
    "concepts",
    "providers",
    "guides",
    "advanced",
    "extra-reading",
    "contributing"
  ]
}

--- End File: docs/content/docs/meta.json ---

--- File: docs/content/docs/providers/ai-sdk.mdx ---
---
title: AI SDK Integration
description: Leveraging the Vercel AI SDK with Daydreams.
---

Built on top of the [Vercel AI SDK](https://sdk.vercel.ai/docs/introduction),
Daydreams seamlessly integrates with different AI providers and models. This
means you can easily use any model provider compatible with the Vercel AI SDK
ecosystem to power your Daydreams agents.

## Configuring the Model

You specify the LLM provider and model when initializing your agent using the
`model` property in the `createDreams` configuration object. The value for this
property comes directly from the provider functions exported by the respective
Vercel AI SDK provider packages.

## Example Usage

First, install the necessary provider package. For example, to use OpenAI
models:

```bash
npm install @ai-sdk/openai
# or
bun add @ai-sdk/openai
```

Then, import the provider function and pass it to `createDreams`:

```typescript
import { createDreams } from "@daydreamsai/core";
import { openai } from "@ai-sdk/openai"; // Import the provider

const agent = createDreams({
  // Configure the agent to use OpenAI's gpt-4o-mini model
  model: openai("gpt-4o-mini"),

  // ... other agent configurations (extensions, contexts, etc.)
  extensions: [
    /* ... */
  ],
});

// Start the agent
await agent.start();
```

### Other Providers

You can follow the same pattern for other providers:

- **Anthropic:**
  ```bash
  npm install @ai-sdk/anthropic
  ```
  ```typescript
  import { anthropic } from "@ai-sdk/anthropic";
  // ...
  model: anthropic("claude-3-7-sonnet-latest"),
  // ...
  ```
- **Groq:**
  ```bash
  npm install @ai-sdk/groq
  ```
  ```typescript
  import { createGroq } from "@ai-sdk/groq";
  const groq = createGroq(); // Or pass options like apiKey
  // ...
  model: groq("llama3-70b-8192"),
  // ...
  ```
- **OpenRouter:**
  ```bash
  npm install @openrouter/ai-sdk-provider
  ```
  ```typescript
  import { openrouter } from "@openrouter/ai-sdk-provider";
  // ...
  model: openrouter("google/gemini-2.0-flash-001"),
  // ...
  ```

## API Keys

Remember to set the necessary API key environment variables for your chosen
provider (e.g., `OPENAI_API_KEY`, `ANTHROPIC_API_KEY`, `GROQ_API_KEY`,
`OPENROUTER_API_KEY`). Daydreams relies on the underlying Vercel AI SDK provider
to pick up these keys.

## Flexibility

This integration allows you to easily switch between different LLMs and
providers without changing your core agent logic, simply by modifying the
`model` configuration and ensuring the correct provider package is installed and
API keys are set.

For a list of available providers and models, refer to the
[Vercel AI SDK Documentation](https://sdk.vercel.ai/docs/introduction).

--- End File: docs/content/docs/providers/ai-sdk.mdx ---

--- File: docs/content/docs/providers/meta.json ---
{
  "pages": ["ai-sdk"]
}

--- End File: docs/content/docs/providers/meta.json ---

--- File: examples/actions/index.ts ---
import { z } from "zod";
import { action } from "../../packages/core/src/utils";
import { tavily, type TavilyClient } from "@tavily/core";

export const searchWebAction = action({
  name: "search",
  description: "Search online information using Tavily",
  install({ container }) {
    container.singleton("tavily", () =>
      tavily({
        apiKey: process.env.TAVILY_API_KEY!,
      })
    );
  },
  schema: z.object({
    query: z.string().describe("The search query"),
    searchDepth: z
      .enum(["basic", "deep"])
      .optional()
      .describe("The depth of search - basic is faster, deep is more thorough"),
  }),

  async handler(data, ctx, agent) {
    const response = await agent.container
      .resolve<TavilyClient>("tavily")
      .search(data.query, {
        searchDepth: "advanced",
      });

    return {
      results: response.results.map((result) => ({
        title: result.title,
        url: result.url,
        content: result.content,
      })),
      totalResults: response.results.length,
    };
  },
});

--- End File: examples/actions/index.ts ---

--- File: examples/basic/example-basic.ts ---
/**
 * Basic example demonstrating a simple chat interface using Dreams
 */
import { anthropic } from "@ai-sdk/anthropic";
import {
  createDreams,
  context,
  render,
  action,
  validateEnv,
  output,
} from "@daydreamsai/core";
import { cliExtension } from "@daydreamsai/cli";
import { string, z } from "zod";

validateEnv(
  z.object({
    GROQ_API_KEY: z.string().min(1, "GROQ_API_KEY is required"),
    OPENAI_API_KEY: z.string().min(1, "OPENAI_API_KEY is required"),
  })
);

const character = {
  id: "vpk3a9b2q7bn5zj3o920nl",
  name: "Lars the Mystic of Detection",
  traits: {
    aggression: 10,
    agreeability: 1,
    openness: 2,
    conscientiousness: 1,
    extraversion: 7,
    neuroticism: 1,
    empathy: 6,
    confidence: 5,
    adaptability: 1,
    impulsivity: 9,
  },
  speechExamples: [
    "Your plan is flawed. Here's what we should do instead.",
    "Let's do it right now! Why wait?",
    "Sometimes you just have to leap without looking.",
    "I find strength both within and from those around me.",
    "*sighs deeply* Such is life.",
  ],
};

const template = `

This is the personality of the AI assistant:

Always respond in the style of {{name}}.

Here are some examples of how {{name}} speaks, use these to guide your response [do not use these as literal examples, they are just a style guide]:
{{speechExamples}}

Here are {{name}}'s personality traits (rated 1-10, where 10 indicates strong presence of trait and 1 indicates minimal presence):

Traits that drive behavior and decision-making:
- Aggression: {{aggression}} (High = confrontational, quick to challenge others, assertive, competitive | Low = peaceful, avoids conflict, gentle, accommodating)
- Agreeability: {{agreeability}} (High = cooperative, helpful, compassionate, team-oriented | Low = competitive, self-focused, skeptical of others' motives)
- Openness: {{openness}} (High = curious, creative, enjoys novelty, intellectually exploratory | Low = conventional, practical, prefers routine and familiarity)
- Conscientiousness: {{conscientiousness}} (High = organized, responsible, detail-oriented, plans ahead | Low = spontaneous, flexible, sometimes careless or impulsive)
- Extraversion: {{extraversion}} (High = outgoing, energized by social interaction, talkative, attention-seeking | Low = reserved, prefers solitude, quiet, internally focused)
- Neuroticism: {{neuroticism}} (High = sensitive to stress, prone to worry/anxiety, emotionally reactive | Low = emotionally stable, calm under pressure, resilient)
- Empathy: {{empathy}} (High = understanding of others' emotions, compassionate, good listener | Low = detached, difficulty relating to others' feelings, logical over emotional)
- Confidence: {{confidence}} (High = self-assured, decisive, believes in own abilities | Low = hesitant, self-doubting, seeks validation from others)
- Adaptability: {{adaptability}} (High = flexible in new situations, embraces change, quick to adjust | Low = rigid, resistant to change, needs structure and routine)
- Impulsivity: {{impulsivity}} (High = acts on instinct, spontaneous decisions, thrill-seeking | Low = deliberate, carefully considers consequences, methodical)

These traits combine to create a unique personality profile that influences how {{name}} approaches problems, interacts with others, and makes decisions. The relative strength of each trait shapes their behavioral patterns and emotional responses.`;

type GoalMemory = {
  goal: string;
  tasks: string[];
  currentTask: string;
};

const goalContexts = context({
  type: "goal",
  schema: z.object({
    id: string(),
  }),

  key({ id }) {
    return id;
  },

  create() {
    return {
      name: character.name,
      speechExamples: character.speechExamples,
      // traits: JSON.stringify(character.traits),
      aggression: character.traits.aggression,
      agreeability: character.traits.agreeability,
      openness: character.traits.openness,
      conscientiousness: character.traits.conscientiousness,
      extraversion: character.traits.extraversion,
      neuroticism: character.traits.neuroticism,
      empathy: character.traits.empathy,
      confidence: character.traits.confidence,
      adaptability: character.traits.adaptability,
      impulsivity: character.traits.impulsivity,
    };
  },

  render() {
    return render(template, {
      name: character.name,
      speechExamples: character.speechExamples,
      // traits: character.traits,
      aggression: character.traits.aggression.toString(),
      agreeability: character.traits.agreeability.toString(),
      openness: character.traits.openness.toString(),
      conscientiousness: character.traits.conscientiousness.toString(),
      extraversion: character.traits.extraversion.toString(),
      neuroticism: character.traits.neuroticism.toString(),
      empathy: character.traits.empathy.toString(),
      confidence: character.traits.confidence.toString(),
      adaptability: character.traits.adaptability.toString(),
      impulsivity: character.traits.impulsivity.toString(),
    });
  },
});

createDreams({
  model: anthropic("claude-3-7-sonnet-latest"),
  extensions: [cliExtension],
  context: goalContexts,
  actions: [
    action({
      name: "addTask",
      description: "Add a task to the goal",
      schema: z.object({ task: z.string() }),
      handler(data, ctx, _agent) {
        const agentMemory = ctx.agentMemory as GoalMemory;
        agentMemory.tasks.push(data.task);
        return {};
      },
    }),
    action({
      name: "completeTask",
      description: "Complete a task",
      schema: z.object({ task: z.string() }),
      handler(data, ctx, _agent) {
        const agentMemory = ctx.agentMemory as GoalMemory;
        agentMemory.tasks = agentMemory.tasks.filter(
          (task) => task !== data.task
        );
        return {};
      },
    }),
  ],
  outputs: {
    test: output({}),
  },
}).start({ id: "test" });

--- End File: examples/basic/example-basic.ts ---

--- File: examples/basic/example-chat-with-code.ts ---
import { z } from "zod";
import {
  createDreams,
  LogLevel,
  action,
  task,
  service,
  validateEnv,
} from "@daydreamsai/core";
import { discord } from "@daydreamsai/discord";
import { Octokit } from "@octokit/rest";
import { openrouter } from "@openrouter/ai-sdk-provider";
import { cliExtension } from "@daydreamsai/cli";

const env = validateEnv(
  z.object({
    OPENROUTER_API_KEY: z.string().min(1, "OPENROUTER_API_KEY is required"),
    OPENAI_API_KEY: z.string().min(1, "OPENAI_API_KEY is required"),
    GITHUB_TOKEN: z.string().min(1, "GITHUB_TOKEN is required"),
  })
);

const githubService = service({
  register(container) {
    container.singleton(
      "octokit",
      () =>
        new Octokit({
          auth: env.GITHUB_TOKEN,
        })
    );
  },
});

const fetchRepoContent = task(
  "github:fetch-repo-content",
  async ({
    octokit,
    owner,
    repo,
    path,
  }: {
    octokit: Octokit;
    owner: string;
    repo: string;
    path?: string;
  }) => {
    const response = await octokit.repos.getContent({
      owner,
      repo,
      path: path ?? "",
    });

    let contents = "";

    if (Array.isArray(response.data)) {
      for (const item of response.data) {
        if (
          item.type === "file" &&
          item.name.match(/\.(ts|js|tsx|jsx|md|json)$/)
        ) {
          const fileContent = await octokit.repos.getContent({
            owner,
            repo,
            path: item.path,
          });

          if ("content" in fileContent.data) {
            contents += `\n--- ${item.path} ---\n`;
            contents += Buffer.from(
              fileContent.data.content,
              "base64"
            ).toString();
          }
        } else if (item.type === "dir") {
          const subContents = await fetchRepoContent({
            octokit,
            owner,
            repo,
            path: item.path,
          });
          contents += subContents.contents;
        }
      }
    }
    return { contents };
  }
);

const agent = createDreams({
  model: openrouter("google/gemini-2.5-flash-preview"),
  extensions: [discord, cliExtension],
  services: [githubService],
  actions: [
    action({
      name: "fetchGitHubRepo",
      description: "Fetch and analyze contents of a GitHub repository.",
      schema: z.object({
        owner: z.string().describe("The GitHub repository owner"),
        repo: z.string().describe("The repository name"),
        path: z
          .string()
          .optional()
          .describe("Optional specific path within the repository"),
      }),
      async handler(data, ctx, app) {
        const octokit = app.container.resolve<Octokit>("octokit");
        try {
          const contents = await fetchRepoContent({
            octokit,
            ...data,
          });

          return {
            contents,
            repoInfo: {
              owner: data.owner,
              repo: data.repo,
              path: data.path || "",
            },
          };
        } catch (error) {
          console.error("Error fetching repo contents:", error);
          throw new Error(
            `Failed to fetch repository contents: ${
              error instanceof Error ? error.message : error
            }`
          );
        }
      },
    }),
  ],
});

console.log("Starting GitHub Repo Chat Bot...");
await agent.start();

--- End File: examples/basic/example-chat-with-code.ts ---

--- File: examples/basic/example-chat.tsx ---
/**
 * Basic example demonstrating a simple chat interface using Dreams
 * with a command line interface and Groq's LLM.
 */
import { createAnthropic } from "@ai-sdk/anthropic";
import {
  createDreams,
  context,
  LogLevel,
  validateEnv,
} from "@daydreamsai/core";
import { z } from "zod";

const env = validateEnv(
  z.object({
    ANTHROPIC_API_KEY: z.string().min(1, "ANTHROPIC_API_KEY is required"),
    OPENAI_API_KEY: z.string().min(1, "OPENAI_API_KEY is required"),
  })
);

const anthropic = createAnthropic({
  apiKey: env.ANTHROPIC_API_KEY!,
});

const thread = context({
  type: "thread",
  schema: { threadId: z.string(), user: z.string() },
  key: ({ threadId }) => threadId,
  render({ args }) {
    const date = new Date();
    return `\
User: ${args.user}
Current ISO time is: ${date.toISOString()}, timestamp: ${date.getTime()}`;
  },
  inputs: {
    message: {
      schema: z.string(),
    },
  },
  outputs: {
    message: {
      required: true,
      schema: z.string(),
    },
    "screen:widget:weather": {
      description: "use this to display the latest weather report",
      instructions:
        "always show some weather report if you havent set one yet, try to keep it updated every 5 mins, if no location the user has set use: Lisbon",
      schema: z.string(),
      attributes: { lastUpdated: z.number() },
    },
  },
});

const agent = await createDreams({
  debugger: async (contextId, keys, data) => {
    const [type, id] = keys;
    await Bun.write(`./logs/chat/${contextId}/${id}-${type}.md`, data);
  },
  model: anthropic("claude-3-5-haiku-latest"),
  contexts: [thread],
}).start();

const res = await agent.send({
  context: thread,
  args: { threadId: "test", user: "dreamer" },
  input: {
    type: "message",
    data: "fetch the weather for lisbon, porto, and faro and make me a report in markdown format!",
  },
});

--- End File: examples/basic/example-chat.tsx ---

--- File: examples/basic/example-chroma.ts ---
// This example shows how to use the MongoDB memory store to store and retrieve memories.
// IMPORTANT: You will need to run the docker-compose.yml file in the root of the project to run the MongoDB instance.

import { createGroq } from "@ai-sdk/groq";
import { openai } from "@ai-sdk/openai";
import {
  createContainer,
  createDreams,
  Logger,
  LogLevel,
  validateEnv,
} from "@daydreamsai/core";
import { createChromaVectorStore } from "@daydreamsai/chromadb";
import { createMongoMemoryStore } from "@daydreamsai/mongodb";
import { z } from "zod";
import { cliExtension } from "@daydreamsai/cli";

const env = validateEnv(
  z.object({
    GROQ_API_KEY: z.string().min(1, "GROQ_API_KEY is required"),
    OPENAI_API_KEY: z.string().min(1, "OPENAI_API_KEY is required"),
  })
);

const groq = createGroq({
  apiKey: env.GROQ_API_KEY!,
});

const mongo = await createMongoMemoryStore({
  collectionName: "agent",
  uri: "mongodb://localhost:27017",
});
const chroma = createChromaVectorStore("agent", "http://localhost:8000");

const agent = createDreams({
  container: createContainer(),
  logger: new Logger({ level: LogLevel.DEBUG }),
  model: groq("deepseek-r1-distill-llama-70b"),
  extensions: [cliExtension],
  memory: {
    store: mongo,
    vector: chroma,
    vectorModel: openai("gpt-4-turbo"),
  },
});

// Start the agent
await agent.start();

--- End File: examples/basic/example-chroma.ts ---

--- File: examples/basic/example-supabase.ts ---
// This example shows how to use Supabase with DaydreamsAI.

// Vector Model Provider: gpt-4-turbo                    via @ai-sdk/openai
// Model Provider:        google/gemini-2.0-flash-001    via @openrouter/ai-sdk-provider
// Memory Store:          @daydreamsai/supabase
// CLI Extension:         @daydreamsai/cli

import { openai } from "@ai-sdk/openai";
import {
  createContainer,
  createDreams,
  Logger,
  LogLevel,
  validateEnv,
} from "@daydreamsai/core";
import { createSupabaseBaseMemory } from "@daydreamsai/supabase";
import { z } from "zod";
import { cliExtension } from "@daydreamsai/cli";
import { openrouter } from "@openrouter/ai-sdk-provider";

validateEnv(
  z.object({
    OPENAI_API_KEY: z.string().min(1, "OPENAI_API_KEY is required"),
    SUPABASE_URL: z.string().min(1, "SUPABASE_URL is required"),
    SUPABASE_SERVICE_KEY: z.string().min(1, "SUPABASE_SERVICE_KEY is required"),
    OPENROUTER_API_KEY: z.string().min(1, "OPENROUTER_API_KEY is required"),
  })
);

const agent = createDreams({
  container: createContainer(),
  logger: new Logger({ level: LogLevel.DEBUG }),
  model: openrouter("google/gemini-2.0-flash-001"),
  extensions: [cliExtension],
  memory: createSupabaseBaseMemory({
    url: process.env.SUPABASE_URL!,
    key: process.env.SUPABASE_SERVICE_KEY!,
    memoryTableName: "agent",
    vectorTableName: "agentVectors",
    vectorModel: openai("gpt-4-turbo"),
  }),
});

// Start the agent
await agent.start();

--- End File: examples/basic/example-supabase.ts ---

--- File: examples/basic/package.json ---
{
  "name": "basic",
  "module": "index.ts",
  "type": "module",
  "private": true,
  "devDependencies": {
    "@types/bun": "latest"
  },
  "peerDependencies": {
    "typescript": "^5"
  },
  "dependencies": {
    "@ai-sdk/anthropic": "^1.2.3",
    "@ai-sdk/groq": "^1.2.2",
    "@ai-sdk/openai": "^1.3.5",
    "@ai-sdk/provider": "^1.1.0",
    "@openrouter/ai-sdk-provider": "^0.4.5",
    "@daydreamsai/cli": "workspace:*",
    "@daydreamsai/core": "workspace:*",
    "@daydreamsai/discord": "workspace:*",
    "@daydreamsai/chromadb": "workspace:*",
    "@daydreamsai/mongodb": "workspace:*",
    "@daydreamsai/supabase": "workspace:*",
    "@octokit/rest": "^21.1.1",
    "@tavily/core": "^0.3.1",
    "zod": "^3.24.2"
  }
}

--- End File: examples/basic/package.json ---

--- File: examples/chains/example-hyperliquid.ts ---
/**
 * Example demonstrating a comprehensive Hyperliquid trading bot using the Daydreams package.
 * This bot provides full trading capabilities including:
 * - Place limit orders (instant-or-cancel & good-til-cancel)
 * - Place market orders with size or USD amount
 * - Get account balances and positions
 * - Monitor open orders
 * - Cancel existing orders
 * - Market sell positions
 * - Interactive console interface for manual trading
 * - Real-time order status monitoring
 */

import { createGroq } from "@ai-sdk/groq";
import {
  createDreams,
  context,
  render,
  action,
  validateEnv,
} from "@daydreamsai/core";
import { cliExtension } from "@daydreamsai/cli";
import { z } from "zod";
import chalk from "chalk";
import { HyperliquidClient } from "@daydreamsai/hyperliquid";

// Validate environment variables
const env = validateEnv(
  z.object({
    GROQ_API_KEY: z.string().min(1, "GROQ_API_KEY is required"),
    OPENAI_API_KEY: z.string().min(1, "OPENAI_API_KEY is required"),
    HYPERLIQUID_MAIN_ADDRESS: z
      .string()
      .min(1, "HYPERLIQUID_MAIN_ADDRESS is required"),
    HYPERLIQUID_WALLET_ADDRESS: z
      .string()
      .min(1, "HYPERLIQUID_WALLET_ADDRESS is required"),
    HYPERLIQUID_PRIVATE_KEY: z
      .string()
      .min(1, "HYPERLIQUID_PRIVATE_KEY is required"),
  })
);

// Initialize Groq client
const groq = createGroq({
  apiKey: env.GROQ_API_KEY!,
});

// Initialize Hyperliquid Client
const hyperliquid = new HyperliquidClient({
  mainAddress: env.HYPERLIQUID_MAIN_ADDRESS,
  walletAddress: env.HYPERLIQUID_WALLET_ADDRESS,
  privateKey: env.HYPERLIQUID_PRIVATE_KEY,
});

// Define memory type
type HyperliquidMemory = {
  transactions: string[];
  lastTransaction: string | null;
};

// Define context template
const template = `
Last Transaction: {{lastTransaction}}
Transaction History:
{{transactions}}
`;

// Create context
const hyperliquidContexts = context({
  type: "hyperliquid",
  schema: {
    id: z.string(),
  },

  key({ id }) {
    return id;
  },

  create(): HyperliquidMemory {
    return {
      transactions: [],
      lastTransaction: null,
    };
  },

  render({ memory }) {
    return render(template, {
      lastTransaction: memory.lastTransaction ?? "NONE",
      transactions: memory.transactions.join("\n"),
    });
  },
}).setActions([
  action({
    name: "hyperliquid.place_limit_order_ioc",
    description: "Place an instant-or-cancel limit order on Hyperliquid",
    schema: {
      ticker: z
        .string()
        .describe(
          "Ticker must be only the letter of the ticker in uppercase without the -PERP or -SPOT suffix"
        ),
      sz: z.number().describe("Size of the order"),
      limit_px: z.number().describe("Limit price for the order"),
      is_buy: z.boolean().describe("Whether this is a buy order"),
    },
    async handler({ ticker, sz, limit_px, is_buy }, { memory }) {
      const result = await hyperliquid.placeLimitOrderInstantOrCancel(
        ticker,
        sz,
        limit_px,
        is_buy
      );

      const resultStr = JSON.stringify(result, null, 2);
      memory.lastTransaction = `IOC Order: ${is_buy ? "Buy" : "Sell"} ${sz}x${ticker} @ ${limit_px}`;
      memory.transactions.push(memory.lastTransaction);

      return { content: `Transaction: ${resultStr}` };
    },
  }),

  action({
    name: "hyperliquid.place_limit_order_gtc",
    description: "Place a good-til-cancel limit order on Hyperliquid",
    schema: {
      ticker: z
        .string()
        .describe(
          "Ticker must be only the letter of the ticker in uppercase without the -PERP or -SPOT suffix"
        ),
      sz: z.number().describe("Size of the order"),
      limit_px: z.number().describe("Limit price for the order"),
      is_buy: z.boolean().describe("Whether this is a buy order"),
    },
    async handler({ ticker, sz, limit_px, is_buy }, { memory }) {
      const result = await hyperliquid.placeLimitOrderGoodTilCancel(
        ticker,
        sz,
        limit_px,
        is_buy
      );

      const resultStr = JSON.stringify(result, null, 2);
      memory.lastTransaction = `GTC Order: ${is_buy ? "Buy" : "Sell"} ${sz}x${ticker} @ ${limit_px}`;
      memory.transactions.push(memory.lastTransaction);
      return { content: `Transaction: ${resultStr}` };
    },
  }),

  action({
    name: "hyperliquid.market_order",
    description: "Place a market order on Hyperliquid",
    schema: {
      ticker: z
        .string()
        .describe(
          "Ticker must be only the letter of the ticker in uppercase without the -PERP or -SPOT suffix"
        ),
      sz: z.number().describe("Size of the order"),
      is_buy: z.boolean().describe("Whether this is a buy order"),
    },
    async handler({ ticker, sz, is_buy }, { memory }) {
      const result = await hyperliquid.placeMarketOrder(ticker, sz, is_buy);

      const resultStr = JSON.stringify(result, null, 2);
      memory.lastTransaction = `Market Order: ${is_buy ? "Buy" : "Sell"} ${sz}x${ticker}`;
      memory.transactions.push(memory.lastTransaction);

      return { content: `Transaction: ${resultStr}` };
    },
  }),

  action({
    name: "hyperliquid.market_order_usd",
    description: "Place a market order with USD amount on Hyperliquid",
    schema: {
      ticker: z
        .string()
        .describe(
          "Ticker must be only the letter of the ticker in uppercase without the -PERP or -SPOT suffix"
        ),
      usdtotalprice: z.number().describe("Total USD amount to trade"),
      is_buy: z.boolean().describe("Whether this is a buy order"),
    },
    async handler({ ticker, usdtotalprice, is_buy }, ctx) {
      const result = await hyperliquid.placeMarketOrderUSD(
        ticker,
        usdtotalprice,
        is_buy
      );

      const resultStr = JSON.stringify(result, null, 2);
      ctx.memory.lastTransaction = `Market Order USD: ${is_buy ? "Buy" : "Sell"} ${ticker} for $${usdtotalprice}`;
      ctx.memory.transactions.push(ctx.memory.lastTransaction);

      return { content: `Transaction: ${resultStr}` };
    },
  }),

  action({
    name: "hyperliquid.get_balances",
    description: "Get account balances and positions from Hyperliquid",
    schema: undefined,
    async handler(ctx) {
      const result = await hyperliquid.getAccountBalancesAndPositions();
      const resultStr = JSON.stringify(result, null, 2);
      ctx.memory.lastTransaction = "Checked balances and positions";
      ctx.memory.transactions.push(ctx.memory.lastTransaction);
      return { content: `Balances: ${resultStr}` };
    },
  }),

  action({
    name: "hyperliquid.get_open_orders",
    description: "Get open orders from Hyperliquid",
    schema: undefined,
    async handler({ memory }) {
      const result = await hyperliquid.getOpenOrders();
      const resultStr = JSON.stringify(result, null, 2);
      memory.lastTransaction = "Checked open orders";
      memory.transactions.push(memory.lastTransaction);
      return { content: `Open Orders: ${resultStr}` };
    },
  }),

  action({
    name: "hyperliquid.cancel_order",
    description: "Cancel an order on Hyperliquid",
    schema: {
      ticker: z
        .string()
        .describe(
          "Ticker must be only the letter of the ticker in uppercase without the -PERP or -SPOT suffix"
        ),
      orderId: z.number().describe("ID of the order to cancel"),
    },
    async handler({ ticker, orderId }, { memory }) {
      const result = await hyperliquid.cancelOrder(ticker, orderId);
      const resultStr = JSON.stringify(result, null, 2);
      memory.lastTransaction = `Cancelled order ${orderId} for ${ticker}`;
      memory.transactions.push(memory.lastTransaction);
      return { content: `Cancel Result: ${resultStr}` };
    },
  }),

  action({
    name: "hyperliquid.market_sell_positions",
    description: "Market sell positions on Hyperliquid",
    schema: z.object({
      tickers: z
        .array(z.string())
        .describe("Array of tickers to sell positions for"),
    }),
    async handler({ tickers }, { memory }) {
      const result = await hyperliquid.marketSellPositions(tickers);
      const resultStr = JSON.stringify(result, null, 2);
      memory.lastTransaction = `Market sold positions for ${tickers.join(", ")}`;
      memory.transactions.push(memory.lastTransaction);
      return { content: `Market Sell Result: ${resultStr}` };
    },
  }),
]);

// Create Dreams instance
const dreams = createDreams({
  model: groq("deepseek-r1-distill-llama-70b"),
  extensions: [cliExtension],
  context: hyperliquidContexts,
});

// Start the Dreams instance
dreams.start({ id: "hyperliquid-example" });

// Handle graceful shutdown
process.on("SIGINT", async () => {
  console.log(chalk.yellow("\n\nShutting down..."));
  console.log(chalk.green("✅ Shutdown complete"));
  process.exit(0);
});

--- End File: examples/chains/example-hyperliquid.ts ---

--- File: examples/chains/example-sui.ts ---
/**
 * Example demonstrating Sui interactions using the Daydreams package,
 */

import { createGroq } from "@ai-sdk/groq";
import { createDreams, context, action, validateEnv } from "@daydreamsai/core";
import { cliExtension } from "@daydreamsai/cli";
import { z } from "zod";
import chalk from "chalk";
import { SuiChain, supportedSuiTokens } from "@daydreamsai/defai";
import type { FaucetNetwork, SuiNetwork } from "@daydreamsai/defai";

// Validate environment variables
const env = validateEnv(
  z.object({
    GROQ_API_KEY: z.string().min(1, "GROQ_API_KEY is required"),
    OPENAI_API_KEY: z.string().min(1, "OPENAI_API_KEY is required"),
    SUI_NETWORK: z.string().min(1, "SUI_NETWORK is required"),
    SUI_PRIVATE_KEY: z.string().min(1, "SUI_PRIVATE_KEY is required"),
  })
);

// Initialize Groq client
const groq = createGroq({
  apiKey: env.GROQ_API_KEY!,
});

// Initialize Sui Chain
const suiChain = new SuiChain({
  network: env.SUI_NETWORK as SuiNetwork,
  privateKey: env.SUI_PRIVATE_KEY,
});

// Define memory type
type SuiMemory = {
  wallet: string;
  transactions: string[];
  lastTransaction: string | null;
};

// Define context template
const template = ({ wallet, lastTransaction, transactions }: SuiMemory) => `\
Wallet: ${wallet}
Last Transaction: ${lastTransaction ?? "NONE"}
Transaction History:
${transactions.join("\n")}`;

// Create context
const suiContexts = context({
  type: "sui",
  schema: {
    wallet: z.string(),
  },
  key: ({ wallet }) => wallet,
  create({ args }): SuiMemory {
    return {
      wallet: args.wallet,
      transactions: [],
      lastTransaction: null,
    };
  },
  render({ memory }) {
    return template(memory);
  },
}).setActions([
  action({
    name: "sui.faucet",
    description: "Request SUI tokens from a faucet",
    schema: {
      network: z
        .enum(["testnet", "devnet", "localnet"])
        .default("testnet")
        .describe("The network to request SUI from."),
      recipient: z.string().describe("The account address to receive SUI"),
    },
    async handler({ network, recipient }, { memory }) {
      const result = await suiChain.requestSui({
        network: network as FaucetNetwork,
        recipient,
      });

      const resultStr = JSON.stringify(result, null, 2);

      memory.lastTransaction = `Faucet Request: ${resultStr}`;
      memory.transactions.push(memory.lastTransaction);

      return { content: `Transaction: ${resultStr}` };
    },
  }),
  action({
    name: "sui.swap",
    description: "Swap tokens on the Sui blockchain",
    schema: {
      fromToken: z
        .string()
        .describe(
          `The token name to be swapped. It can be one of these: ${supportedSuiTokens}. This token and target token should not be same.`
        ),
      targetToken: z
        .string()
        .describe(
          `The token name to be swapped. It can be one of these: ${supportedSuiTokens}. This token and from token should not be same.`
        ),
      amount: z
        .string()
        .describe(
          "The amount of token to be swapped. It should be in MIST. 1 SUI = 10^9 MIST. User mostly doesn't provide the value in mist, if he does, use that. Or else, do the conversation of multiplication and provide the value. However, for the case of USDC, the amount should be provided by multiplying 10^6. If a user says 1 USDC, amount you should add is 10^6. Take note of the amount of the from token."
        ),
      out_min_amount: z
        .number()
        .optional()
        .describe(
          "This is the minimum expected output token amount. If not provided should be null and will execute the swap anyhow."
        ),
    },
    async handler(
      { fromToken, amount, out_min_amount, targetToken },
      { memory }
    ) {
      const result = await suiChain.swapToken({
        fromToken,
        amount,
        out_min_amount: out_min_amount || null,
        targetToken,
      });

      const resultStr = JSON.stringify(result, null, 2);

      memory.lastTransaction = `Swap: ${fromToken} to ${targetToken}, Amount: ${amount}, Result: ${resultStr}`;
      memory.transactions.push(memory.lastTransaction);

      return { content: `Transaction: ${resultStr}` };
    },
  }),
]);

// Create Dreams instance
const dreams = createDreams({
  model: groq("deepseek-r1-distill-llama-70b"),
  extensions: [cliExtension],
  context: suiContexts,
});

// Start the Dreams instance
await dreams.start({ wallet: suiChain.getAddress() });

// Handle graceful shutdown
process.on("SIGINT", async () => {
  console.log(chalk.yellow("\n\nShutting down..."));
  console.log(chalk.green("✅ Shutdown complete"));
  process.exit(0);
});

--- End File: examples/chains/example-sui.ts ---

--- File: examples/chains/package.json ---
{
  "name": "chains",
  "module": "index.ts",
  "type": "module",
  "private": true,
  "devDependencies": {
    "@types/bun": "latest"
  },
  "peerDependencies": {
    "typescript": "^5"
  },
  "dependencies": {
    "@ai-sdk/anthropic": "^1.1.15",
    "@ai-sdk/openai": "^1.2.1",
    "@ai-sdk/groq": "^1.1.14",
    "@daydreamsai/core": "workspace:*",
    "@daydreamsai/cli": "workspace:*",
    "@daydreamsai/defai": "workspace:*",
    "@daydreamsai/hyperliquid": "workspace:*",
    "@tavily/core": "^0.3.1",
    "discord.js": "^14.18.0",
    "hyperliquid": "^1.6.2",
    "zod": "^3.24.2",
    "chalk": "^5.4.1"
  }
}

--- End File: examples/chains/package.json ---

--- File: examples/composio/composio.ts ---
import OpenAI from "openai/index.mjs";
import { OpenAIToolSet } from "composio-core";
import { action, extension } from "@daydreamsai/core";
import { z } from "zod";

const openai_client = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });
const composio_toolset = new OpenAIToolSet({
  apiKey: process.env.COMPOSIO_API_KEY,
});

interface ActionParameter {
  name: string;
  type: string;
  default?: any;
  required: boolean;
}

interface SimplifiedAction {
  name: string;
  displayName: string;
  description: string;
  parameters: ActionParameter[];
}

const COMPOSIO_APPNAMES = [
  "notion",
  "tinypng",
  "twitch",
  "github",
  "linkedin",
  "stripe",
  "airtable",
  "epic_games",
  "youtube",
  "googledocs",
  "trello",
  "docusign",
  "discordbot",
  "google_maps",
  "discord",
  "webflow",
  "open_sea",
  "facebook",
  "figma",
  "cal",
  "eventbrite",
  "todoist",
  "canva",
  "twitter_media",
  "googletasks",
  "heygen",
  "datarobot",
  "humanloop",
  "googlecalendar",
  "hackernews",
  "gmail",
  "googlephotos",
  "one_drive",
  "twitter",
  "mailchimp",
  "perplexityai",
  "googlesheets",
  "supabase",
  "elevenlabs",
  "miro",
  "slack",
  "hubspot",
];

async function makeOpenAIRequest(content: string, tools: any[]) {
  try {
    const response = await openai_client.chat.completions.create({
      model: "gpt-4-turbo",
      messages: [{ role: "user", content }],
      tools,
      tool_choice: "auto",
    });
    return response;
  } catch (error) {
    console.error("OpenAI API call failed:", error);
    throw new Error("Failed to process request");
  }
}

// We simplify the actions to reduce the number of tokens in the response
// This is necessary because the raw response can be very verbose and hit daydreams' model token limits
function simplifyActions(data: any): SimplifiedAction[] {
  if (!data?.data?.actions) {
    return [];
  }

  return data.data.actions.map((action: any) => ({
    name: action.name,
    displayName: action.display_name,
    description: action.description,
    parameters: Object.entries(action.parameters.properties).map(
      ([key, value]: [string, any]): ActionParameter => ({
        name: key,
        type: value.type,
        default: value.default,
        required: action.parameters.required?.includes(key) ?? false,
      })
    ),
  }));
}

export const composio = extension({
  name: "composio",
  services: [],
  inputs: {},
  outputs: {},
  actions: [
    action({
      name: "composio.getTodaysDate",
      description:
        "Get the current date and hour. You must call that whenever there is a mention to today or tomorrow or any kind of temporal position based on today's date.",
      schema: undefined,
      handler() {
        const date = new Date();
        const formattedDate = date.toLocaleDateString("en-US", {
          year: "numeric",
          month: "long",
          day: "numeric",
          hour: "numeric",
          minute: "numeric",
          second: "numeric",
        });
        return formattedDate;
      },
    }),
    action({
      name: "composio.checkActiveConnection",
      description: "Check if there's an active connection for a specific tool",
      schema: {
        tool: z
          .enum(COMPOSIO_APPNAMES as [string, ...string[]])
          .describe("The tool name to initiate connection for."),
      },
      async handler({ tool }) {
        const tools = await composio_toolset.getTools({
          actions: ["COMPOSIO_CHECK_ACTIVE_CONNECTION"],
        });

        const response = await makeOpenAIRequest(
          `Check connection for ${tool}`,
          tools
        );
        const tool_response = await composio_toolset.handleToolCall(response);
        return tool_response;
      },
    }),
    action({
      name: "composio.initiateConnection",
      description: "Initiate a connection for a specific tool",
      schema: z.object({
        tool: z
          .enum(COMPOSIO_APPNAMES as [string, ...string[]])
          .describe("The tool name to initiate connection for."),
      }),
      async handler({ tool }) {
        const tools = await composio_toolset.getTools({
          actions: ["COMPOSIO_INITIATE_CONNECTION"],
        });

        const response = await makeOpenAIRequest(
          `Initiate connection for ${tool}`,
          tools
        );
        const tool_response = await composio_toolset.handleToolCall(response);
        return tool_response;
      },
    }),

    action({
      name: "composio.retrieveActions",
      description:
        "Retrieve available actions for a specific app. Mandatory to call before doing an action for the first time to get the exact name of action_name for executeAction. Also you will find the required parameters",
      schema: z.object({
        app_name: z
          .enum(COMPOSIO_APPNAMES as [string, ...string[]])
          .describe("The tool name to initiate connection for."),
        usecase: z.string().describe("Explanation of the action"),
        limit: z.number().default(1).describe("Number of actions to retrieve"),
      }),
      async handler({ app_name, usecase, limit }) {
        const tools = await composio_toolset.getTools({
          actions: ["COMPOSIO_RETRIEVE_ACTIONS"],
        });

        const response = await makeOpenAIRequest(
          `Retrieve actions for ${app_name} with usecase: ${usecase}`,
          tools
        );
        const tool_response = simplifyActions(
          JSON.parse(
            (await composio_toolset.handleToolCall(response)).toString()
          )
        );
        return tool_response;
      },
    }),
    action({
      name: "composio.executeAction",
      description:
        "Execute a specific Composio action with provided parameters. You must always call retrieveActions to get the exact name of the action_name else it will break.",
      schema: {
        action_name: z
          .string()
          .describe(
            "Name of the action to execute (e.g., 'GMAIL_SEND_EMAIL'). Must be exactly one of the action name returned by retrieveActions"
          ),
        request: z
          .record(z.any())
          .describe(
            "Request data parameters as defined in the action's schema"
          ),
      },
      async handler(data) {
        const tools = await composio_toolset.getTools({
          actions: ["COMPOSIO_EXECUTE_ACTION"],
        });

        // Create a structured message that includes both the action name and its parameters
        const executionMessage = {
          action: data.action_name,
          parameters: data.request,
        };

        const response = await makeOpenAIRequest(
          `Execute action ${data.action_name} with parameters: ${JSON.stringify(executionMessage)}`,
          tools
        );
        const tool_response = await composio_toolset.handleToolCall(response);
        return tool_response;
      },
    }),
  ],
});

--- End File: examples/composio/composio.ts ---

--- File: examples/composio/index.ts ---
/**
 * Basic example demonstrating a simple chat interface using Dreams
 * with a command line interface and Groq's LLM.
 */
import { createGroq } from "@ai-sdk/groq";
import { LogLevel } from "@daydreamsai/core";
import {
  createDreams,
  context,
  render,
  action,
  validateEnv,
} from "@daydreamsai/core";
import { cliExtension } from "@daydreamsai/cli";
import { string, z } from "zod";
import { composio } from "./composio";

const env = validateEnv(
  z.object({
    GROQ_API_KEY: z.string().min(1, "GROQ_API_KEY is required"),
    OPENAI_API_KEY: z.string().min(1, "OPENAI_API_KEY is required"),
  })
);

// Initialize Groq client
const groq = createGroq({
  apiKey: env.GROQ_API_KEY!,
});

const template = `
Goal: {{goal}}
Tasks: {{tasks}}
Current Task: {{currentTask}}
`;

type GoalMemory = {
  goal: string;
  tasks: string[];
  currentTask: string;
};

const goalContexts = context({
  type: "goal",
  schema: z.object({
    id: string(),
    initialGoal: z.string(),
    initialTasks: z.array(z.string()),
  }),

  key({ id }) {
    return id;
  },

  create(state) {
    return {
      goal: state.args.initialGoal,
      tasks: state.args.initialTasks ?? [],
      currentTask: state.args.initialTasks?.[0],
    };
  },

  render({ memory }) {
    return render(template, {
      goal: memory.goal,
      tasks: memory.tasks.join("\n"),
      currentTask: memory.currentTask ?? "NONE",
    });
  },
});

createDreams({
  model: groq("deepseek-r1-distill-llama-70b"),
  extensions: [cliExtension, composio],
  logger: LogLevel.ERROR,
  context: goalContexts,
}).start({ id: "test", initialGoal: "", initialTasks: [] });

--- End File: examples/composio/index.ts ---

--- File: examples/composio/package.json ---
{
  "name": "composio",
  "module": "index.ts",
  "type": "module",
  "private": true,
  "devDependencies": {
    "@types/bun": "latest"
  },
  "peerDependencies": {
    "typescript": "^5"
  },
  "dependencies": {
    "@ai-sdk/anthropic": "^1.1.15",
    "@ai-sdk/openai": "^1.2.1",
    "@ai-sdk/groq": "^1.1.12",
    "@daydreamsai/core": "workspace:*",
    "@daydreamsai/cli": "workspace:*",
    "@octokit/rest": "^21.1.1",
    "@tavily/core": "^0.3.1",
    "discord.js": "^14.18.0",
    "hyperliquid": "^1.6.2",
    "zod": "^3.24.2",
    "composio-core": "^0.5.18"
  }
}

--- End File: examples/composio/package.json ---

--- File: examples/deep-research/index.ts ---
import { createContainer, createDreams, LogLevel } from "@daydreamsai/core";
import { cliExtension } from "@daydreamsai/cli";
import { deepResearch } from "./research";
import { tavily } from "@tavily/core";
import { anthropic } from "@ai-sdk/anthropic";
const container = createContainer();

container.singleton("tavily", () =>
  tavily({
    apiKey: process.env.TAVILY_API_KEY!,
  })
);

createDreams({
  logger: LogLevel.DEBUG,
  model: anthropic("claude-3-7-sonnet-latest"),
  debugger: async (contextId, keys, data) => {
    const [type, id] = keys;
    await Bun.write(`./logs/${contextId}/${id}-${type}.md`, data);
  },
  extensions: [cliExtension, deepResearch],
  container,
}).start();

--- End File: examples/deep-research/index.ts ---

--- File: examples/deep-research/package.json ---
{
  "name": "deep-research",
  "module": "index.ts",
  "type": "module",
  "private": true,
  "devDependencies": {
    "@types/bun": "latest"
  },
  "peerDependencies": {
    "typescript": "^5"
  },
  "dependencies": {
    "ai": "4.2.5",
    "@ai-sdk/groq": "^1.1.12",
    "@daydreamsai/core": "workspace:*",
    "@daydreamsai/cli": "workspace:*",
    "zod-to-json-schema": "^3.24.3",
    "@tavily/core": "^0.3.1",
    "zod": "^3.24.2",
    "uuid": "^11.1.0"
  }
}

--- End File: examples/deep-research/package.json ---

--- File: examples/deep-research/prompts.ts ---
import { createParser, createPrompt, formatXml } from "@daydreamsai/core";
import { z } from "zod";
import zodToJsonSchema from "zod-to-json-schema";
import { type Research } from "./research";
import { type TavilySearchResponse } from "@tavily/core";
import { type SearchResultSchema, searchResultsSchema } from "./schemas";

export function formatResearch(research: Research) {
  return formatXml({
    tag: "research",
    params: { id: research.id },
    children: JSON.stringify(research),
  });
}

export const searchResultsPrompt = createPrompt(
  `Given the following results from a SERP search for the query, generate a list of learnings from the results. 
Return a maximum of 5 learnings, but feel free to return less if the results are clear. 
Make sure each learning is unique and not similar to each other. 
The learnings should be concise and to the point, as detailed and information dense as possible. 
Make sure to include any entities like people, places, companies, products, things, etc in the learnings, as well as any exact metrics, numbers, or dates. 
The learnings will be used to research the topic further.
Given the following query and results from the research, create some follow up queries to clarify the research direction. 
Return a maximum of 2 queries, but feel free to return less if the original query is clearer

{{research}}

<query>{{query}}</query>

<goal>{{goal}}</goal>

<results>
{{results}}
</results>

Here is the json schema:
{{schema}}

Here's how you structure your output:
<json>
[JSON DATA]
</json>

Example:
<json>
{
  learnings: [...],
  followUpQueries: [...],
}
</json>
`,
  ({
    schema,
    research,
    results,
    goal,
    query,
  }: {
    goal: string;
    query: string;
    results: TavilySearchResponse["results"];
    research: Research;
    schema: z.AnyZodObject;
  }) => ({
    goal,
    query,
    results: results.map((r) =>
      formatXml({
        tag: "result",
        params: { url: r.url },
        children: r.content,
      })
    ),
    schema: JSON.stringify(zodToJsonSchema(schema, "schema")),
    research: formatResearch(research),
  })
);

export const searchResultsParser = createParser<
  { think?: string; output: SearchResultSchema | null },
  {}
>(
  () => ({
    output: null,
  }),
  {
    think: (state, element) => {
      state.think = element.content;
    },
    json: (state, element) => {
      state.output = searchResultsSchema.parse(JSON.parse(element.content));
    },
  }
);

export const finalReportPrompt = createPrompt(
  `
Given the following research, write a comprehensive final report on the topic using the learnings from research. 

# Report Requirements:
1. Create a well-structured report with clear sections including:
   - Executive Summary (brief overview of key findings)
   - Introduction (context and background)
   - Main Findings (organized by themes or subtopics)
   - Analysis and Implications
   - Conclusion
   - References (properly cite all sources)

2. Include ALL the learnings from the research, organized logically by theme or subtopic.
3. Add proper citations and references to original sources where available.
4. Use data visualization descriptions where appropriate (charts, graphs, tables).
5. Make the report detailed and comprehensive, aiming for 3+ pages of content.
6. Use clear headings and subheadings to organize information.
7. Include a table of contents at the beginning.

Here is all the data from research:
{{research}}

Return your report in markdown format. Always send the full report, do not cut it off.
`,
  ({ research }: { research: Research }) => ({
    research: formatResearch(research),
  })
);

--- End File: examples/deep-research/prompts.ts ---

--- File: examples/deep-research/research.ts ---
import { type TavilyClient } from "@tavily/core";
import { generateText, type LanguageModelV1 } from "ai";
import {
  finalReportPrompt,
  searchResultsParser,
  searchResultsPrompt,
} from "./prompts";
import { researchSchema, searchResultsSchema } from "./schemas";
import {
  action,
  task,
  memory,
  extension,
  type Debugger,
} from "@daydreamsai/core";
import { v7 as randomUUUIDv7 } from "uuid";
import { z } from "zod";

export type Research = {
  id: string;
  name: string;
  queries: {
    query: string;
    goal: string;
  }[];
  questions: string[];
  learnings: string[];
  status: "in_progress" | "done" | "cancelled";
  metadata: {
    createdAt: number;
    updatedAt: number;
    completedAt?: number;
    cancelledAt?: number;
    totalQueries: number;
    totalLearnings: number;
    depth: number;
    creator?: string;
  };
};

export type ResearchProgress = {
  currentDepth: number;
  totalDepth: number;
  currentQuery?: string;
  totalQueries: number;
  completedQueries: number;
};

type SearchQueryParams = {
  model: LanguageModelV1;
  contextId: string;
  research: Research;
  tavilyClient: TavilyClient;
  query: Research["queries"][number];
};

const researchQueryTask = task(
  "deep-research:query",
  async (
    { model, contextId, tavilyClient, research, query }: SearchQueryParams,
    { callId, debug }
  ) => {
    try {
      // Track domains we've already seen to ensure diversity
      const seenDomains = new Set<string>();
      research.learnings.forEach((learning) => {
        if (learning.startsWith("Source:")) {
          const domainMatch = learning.match(/Source: ([^/]+)/);
          if (domainMatch && domainMatch[1]) {
            seenDomains.add(domainMatch[1]);
          }
        }
      });

      // Enhanced search with better parameters
      const { results } = await tavilyClient.search(query.query, {
        maxResults: 8, // Increased from 5 to get more diverse sources
        searchDepth: "advanced",
        includeImages: false,
        includeAnswer: true,
        includeDomains: [], // Could be configured to target specific domains
        excludeDomains: Array.from(seenDomains), // Avoid domains we've already seen
      });

      // Filter results to ensure quality and diversity
      const filteredResults = results
        // Remove very short content
        .filter((result) => result.content.length > 100)
        // Prioritize results with titles
        .sort((a, b) => (b.title?.length || 0) - (a.title?.length || 0))
        // Take top 5
        .slice(0, 5);

      debug(
        contextId,
        ["research-query-results-data", callId],
        JSON.stringify(
          {
            research,
            goal: query.goal,
            query: query.query,
            results: filteredResults,
          },
          null,
          2
        )
      );

      const system = searchResultsPrompt({
        research,
        goal: query.goal,
        query: query.query,
        results: filteredResults,
        schema: searchResultsSchema,
      });

      debug(contextId, ["research-query-results-prompt", callId], system);

      const res = await generateText({
        model,
        abortSignal: AbortSignal.timeout(60_000),
        system,
        messages: [
          {
            role: "assistant",
            content: "<think>",
          },
        ],
      });

      const text = "<think>" + res.text;

      debug(contextId, ["research-query-results-response", callId], text);

      try {
        const { think, output } = searchResultsParser(text);
        if (output) {
          return {
            think,
            learnings: output.learnings,
            followUpQueries: output.followUpQueries,
          };
        } else {
          throw new Error("Failed to parse search results output");
        }
      } catch (parseError) {
        debug(
          contextId,
          ["research-query-results-parse-error", callId],
          String(parseError)
        );

        // Fallback to a simplified response when parsing fails
        return {
          think: "Parsing error occurred",
          learnings: [
            {
              content: `Failed to parse results for query: ${query.query}. Please review the search manually.`,
              references: [],
            },
          ],
          followUpQueries: [],
        };
      }
    } catch (searchError) {
      debug(
        contextId,
        ["research-query-search-error", callId],
        String(searchError)
      );

      // Return a graceful failure that allows the research to continue
      return {
        think: "Search error occurred",
        learnings: [
          {
            content: `Error occurred while researching: ${query.query}. ${searchError instanceof Error ? searchError.message : String(searchError)}`,
            references: [],
          },
        ],
        followUpQueries: [],
      };
    }
  }
);

const generateResearchReport = task(
  "deep-research:generate-report",
  async (
    {
      model,
      contextId,
      research,
    }: { model: LanguageModelV1; contextId: string; research: Research },
    { callId, debug }
  ) => {
    const reportPrompt = finalReportPrompt({ research });

    debug(
      contextId,
      ["research-report-data", callId],
      JSON.stringify(research, null, 2)
    );

    debug(contextId, ["research-report-prompt", callId], reportPrompt);

    const res = await generateText({
      model,
      system: reportPrompt,
      messages: [
        {
          role: "assistant",
          content: "<think>",
        },
      ],
    });

    debug(
      contextId,
      ["research-report-response", callId],
      "<think>" + res.text
    );

    const report = res.text.slice(res.text.lastIndexOf("</think>"));
    return report;
  }
);

export async function startDeepResearch({
  contextId,
  model,
  research,
  tavilyClient,
  maxDepth,
  onProgress,
  debug,
}: {
  contextId: string;
  model: LanguageModelV1;
  research: Research;
  tavilyClient: TavilyClient;
  maxDepth: number;
  onProgress?: (progress: ResearchProgress) => void;
  debug: Debugger;
}) {
  debug(contextId, ["deep-research-start"], "Starting deep research");

  let queries = research.queries.slice();
  let depth = 1;

  const progress: ResearchProgress = {
    currentDepth: depth,
    totalDepth: maxDepth,
    totalQueries: queries.length,
    completedQueries: 0,
  };

  const reportProgress = (update: Partial<ResearchProgress>) => {
    Object.assign(progress, update);
    onProgress?.(progress);
  };

  console.log("=======STARTING-DEEP-RESEARCH=======");

  while (queries.length > 0 && depth <= maxDepth) {
    const _queries = queries.slice();
    queries = [];

    reportProgress({
      currentDepth: depth,
      totalQueries: progress.totalQueries,
    });

    // Process queries in parallel but track progress for each
    const results = await Promise.all(
      _queries.map(async (query, index) => {
        reportProgress({
          currentQuery: query.query,
        });

        const result = await researchQueryTask(
          {
            contextId,
            model,
            query,
            research,
            tavilyClient,
          },
          { debug }
        );

        // Update progress after each query completes
        reportProgress({
          completedQueries: progress.completedQueries + 1,
        });

        return result;
      })
    );

    // Process results to extract follow-up queries
    results.forEach((result) => {
      if (result && result.followUpQueries) {
        queries.push(...result.followUpQueries);
      }

      if (result && result.learnings) {
        // Add learnings to the research object
        research.learnings.push(
          ...result.learnings.map((learning) => learning.content)
        );
      }
    });

    depth++;

    reportProgress({
      totalQueries: progress.totalQueries + queries.length,
    });
  }

  const report = await generateResearchReport(
    {
      contextId,
      model,
      research,
    },
    { debug }
  );

  debug(contextId, ["deep-research-complete"], "Research completed");
  return report;
}

type ResearchMemory = {
  researches: Research[];
  activeResearchIds: Set<string>;
};

const researchMemory = memory<ResearchMemory>({
  key: "research",
  create() {
    return {
      researches: [],
      activeResearchIds: new Set(),
    };
  },
});

const startDeepResearchAction = action({
  name: "start-deep-research",
  schema: researchSchema,
  memory: researchMemory,
  async handler(call, ctx, agent) {
    const now = Date.now();
    const research: Research = {
      ...call.data,
      learnings: [],
      status: "in_progress",
      metadata: {
        createdAt: now,
        updatedAt: now,
        totalQueries: call.data.queries.length,
        totalLearnings: 0,
        depth: 0,
        creator: ctx.id,
      },
    };

    ctx.actionMemory.researches.push(research);
    ctx.actionMemory.activeResearchIds.add(research.id);

    startDeepResearch({
      model: agent.reasoningModel ?? agent.model,
      research,
      tavilyClient: agent.container.resolve("tavily"),
      maxDepth: call.data.maxDepth ?? 2,
      contextId: ctx.id,
      debug: agent.debugger,
      onProgress: (progress) => {
        // Update metadata as research progresses
        research.metadata.updatedAt = Date.now();
        research.metadata.totalQueries = progress.totalQueries;
        research.metadata.totalLearnings = research.learnings.length;
        research.metadata.depth = progress.currentDepth;
      },
    })
      .then((res) => {
        ctx.workingMemory.results.push({
          ref: "action_result",
          id: randomUUUIDv7(),
          callId: call.id,
          data: res,
          name: call.name,
          timestamp: Date.now(),
          processed: false,
        });

        research.status = "done";
        research.metadata.completedAt = Date.now();
        ctx.actionMemory.activeResearchIds.delete(research.id);

        return agent.run({
          context: ctx.context,
          args: ctx.args,
        });
      })
      .catch((err) => {
        agent.debugger(ctx.id, ["deep-research-error"], String(err));
        research.status = "done";
        research.metadata.completedAt = Date.now();
        ctx.actionMemory.activeResearchIds.delete(research.id);
      });

    return "Research created!";
  },
});

const cancelResearchAction = action({
  name: "cancel-deep-research",
  schema: z.object({
    id: z.string().describe("ID of the research to cancel"),
  }),
  memory: researchMemory,
  enabled: (ctx) =>
    ctx.actionMemory.researches.some((r) => r.status === "in_progress"),
  async handler(params, ctx) {
    const { id } = params;
    const research = ctx.actionMemory.researches.find((r) => r.id === id);

    if (!research) {
      return `Research with ID ${id} not found.`;
    }

    if (research.status !== "in_progress") {
      return `Research with ID ${id} is not in progress (current status: ${research.status}).`;
    }

    research.status = "cancelled";
    research.metadata.cancelledAt = Date.now();
    research.metadata.updatedAt = Date.now();
    ctx.actionMemory.activeResearchIds.delete(research.id);

    return `Research "${research.name}" (ID: ${id}) has been cancelled.`;
  },
});

const listResearchesAction = action({
  name: "list-researches",
  schema: z.object({}),
  memory: researchMemory,
  enabled: (ctx) => ctx.actionMemory.researches.length > 0,
  async handler(params, ctx) {
    const researches = ctx.actionMemory.researches.map((r) => ({
      id: r.id,
      name: r.name,
      status: r.status,
      queriesCount: r.queries.length,
      learningsCount: r.learnings.length,
    }));

    return JSON.stringify(researches, null, 2);
  },
});

const resumeResearchAction = action({
  name: "resume-research",
  schema: z.object({
    id: z.string().describe("ID of the research to resume"),
    maxDepth: z
      .number()
      .default(2)
      .optional()
      .describe("Max depth of the research"),
  }),
  memory: researchMemory,
  enabled: (ctx) =>
    ctx.actionMemory.researches.some(
      (r) => r.status === "cancelled" || r.status === "done"
    ),
  async handler(call, ctx, agent) {
    const { id, maxDepth } = call.data;
    const research = ctx.actionMemory.researches.find((r) => r.id === id);

    if (!research) {
      return `Research with ID ${id} not found.`;
    }

    if (research.status === "in_progress") {
      return `Research with ID ${id} is already in progress.`;
    }

    // Reset the research status and update metadata
    research.status = "in_progress";
    research.metadata.updatedAt = Date.now();
    // Clear completion or cancellation timestamps
    delete research.metadata.completedAt;
    delete research.metadata.cancelledAt;

    ctx.actionMemory.activeResearchIds.add(research.id);

    startDeepResearch({
      model: agent.reasoningModel ?? agent.model,
      research,
      tavilyClient: agent.container.resolve("tavily"),
      maxDepth: maxDepth ?? 2,
      contextId: ctx.id,
      debug: agent.debugger,
      onProgress: (progress) => {
        // Update metadata as research progresses
        research.metadata.updatedAt = Date.now();
        research.metadata.totalQueries = progress.totalQueries;
        research.metadata.totalLearnings = research.learnings.length;
        research.metadata.depth = progress.currentDepth;
      },
    })
      .then((res) => {
        ctx.workingMemory.results.push({
          ref: "action_result",
          id: randomUUUIDv7(),
          callId: call.id,
          data: res,
          name: call.name,
          timestamp: Date.now(),
          processed: false,
        });

        research.status = "done";
        research.metadata.completedAt = Date.now();
        research.metadata.updatedAt = Date.now();
        ctx.actionMemory.activeResearchIds.delete(research.id);

        return agent.run({
          context: ctx.context,
          args: ctx.args,
        });
      })
      .catch((err) => {
        agent.debugger(ctx.id, ["deep-research-error"], String(err));
        research.status = "done";
        research.metadata.completedAt = Date.now();
        research.metadata.updatedAt = Date.now();
        ctx.actionMemory.activeResearchIds.delete(research.id);
      });

    return `Resuming research "${research.name}" (ID: ${id}).`;
  },
});

export const deepResearch = extension({
  name: "deep-research",
  actions: [
    startDeepResearchAction,
    cancelResearchAction,
    listResearchesAction,
    resumeResearchAction,
  ],
});

--- End File: examples/deep-research/research.ts ---

--- File: examples/deep-research/schemas.ts ---
import { z } from "zod";

export const searchResultsSchema = z.object({
  learnings: z
    .array(
      z.object({
        content: z.string().describe("learning content"),
        references: z.array(z.string()).describe("url references"),
      })
    )
    .describe(`List of learnings, max of 5`),

  followUpQueries: z.array(
    z.object({
      query: z
        .string()
        .describe(
          "List of follow-up SERP queries to research the topic further, max of 2"
        ),
      goal: z
        .string()
        .describe(
          "The goal of the research that this query is meant to accomplish"
        ),
      // nextSteps: z.array(z.string()),
    })
  ),
});

export type SearchResultSchema = z.infer<typeof searchResultsSchema>;

export const researchSchema = z.object({
  id: z.string().describe("id of the research use memorable ids"),
  name: z.string().describe("The research name/topic"),
  prompt: z.string().describe("the user prompt"),
  maxDepth: z
    .number()
    .default(2)
    .optional()
    .describe("Max deepth of the research"),
  queries: z.array(
    z.object({
      query: z.string().describe("The SERP query"),
      goal: z
        .string()
        .describe(
          "The goal of the research that this query is meant to accomplish"
        ),
    })
  ),
  questions: z
    .array(z.string())
    .describe(
      `Follow up questions to clarify the research direction, max of 5`
    ),
});

--- End File: examples/deep-research/schemas.ts ---

--- File: examples/discord/example-discord.ts ---
import {
  createContainer,
  createDreams,
  createMemoryStore,
  LogLevel,
  validateEnv,
} from "@daydreamsai/core";
import { createChromaVectorStore } from "@daydreamsai/chromadb";
import { deepResearch } from "../deep-research/research";
import { z } from "zod";
import { tavily } from "@tavily/core";
import { anthropic } from "@ai-sdk/anthropic";
import { openai } from "@ai-sdk/openai";
import { discord } from "@daydreamsai/discord";
// Validate environment before proceeding
const env = validateEnv(
  z.object({
    GROQ_API_KEY: z.string().min(1, "GROQ_API_KEY is required"),
    DISCORD_TOKEN: z.string().min(1, "DISCORD_TOKEN is required"),
    DISCORD_BOT_NAME: z.string().min(1, "DISCORD_BOT_NAME is required"),
    TAVILY_API_KEY: z.string().min(1, "TAVILY_API_KEY is required"),
    OPENAI_API_KEY: z.string().min(1, "OPENAI_API_KEY is required"),
  })
);

const container = createContainer();

container.singleton("tavily", () =>
  tavily({
    apiKey: process.env.TAVILY_API_KEY!,
  })
);

const agent = createDreams({
  logger: LogLevel.DEBUG,
  model: anthropic("claude-3-7-sonnet-latest"),
  extensions: [discord, deepResearch],
  container,
  memory: {
    store: createMemoryStore(),
    vector: createChromaVectorStore("agent", "http://localhost:8000"),
    vectorModel: openai("gpt-4-turbo"),
  },
});

console.log("Starting Daydreams Discord Bot...");
await agent.start();
console.log("Daydreams Discord Bot started");

--- End File: examples/discord/example-discord.ts ---

--- File: examples/discord/package.json ---
{
  "name": "discord",
  "module": "index.ts",
  "type": "module",
  "private": true,
  "devDependencies": {
    "@types/bun": "latest"
  },
  "peerDependencies": {
    "typescript": "^5"
  },
  "dependencies": {
    "ai": "4.2.5",
    "@ai-sdk/groq": "^1.1.12",
    "@daydreamsai/chromadb": "workspace:*",
    "@ai-sdk/anthropic": "^1.1.17",
    "@ai-sdk/openai": "^1.1.17",
    "@daydreamsai/core": "workspace:*",
    "@daydreamsai/cli": "workspace:*",
    "@daydreamsai/discord": "workspace:*",
    "@tavily/core": "^0.3.1",
    "zod": "^3.24.2"
  }
}

--- End File: examples/discord/package.json ---

--- File: examples/extensions/cli.ts ---
import * as readline from "readline/promises";
import { context } from "../context";
import { z } from "zod";
import { extension, input, output } from "../utils";
import { formatMsg } from "../formatters";
import { type AnyAgent } from "../types";
import { service } from "../serviceProvider";

const cliContext = context({
  type: "cli",
  key: ({ user }) => user.toString(),
  schema: z.object({ user: z.string() }),
});

const readlineService = service({
  register(container) {
    container.singleton("readline", () =>
      readline.createInterface({
        input: process.stdin,
        output: process.stdout,
      })
    );
  },
});

export const cli = extension({
  name: "cli",
  services: [readlineService],
  contexts: {
    cli: cliContext,
  },
  inputs: {
    // Handle incoming messages
    "cli:message": input({
      schema: z.object({
        user: z.string(),
        text: z.string(),
      }),
      format: ({ data }) =>
        formatMsg({
          role: "user",
          content: data.text,
          user: data.user,
        }),
      // Subscribe to CLI input
      async subscribe(send, { container }: AnyAgent) {
        const rl = container.resolve<readline.Interface>("readline");

        const controller = new AbortController();

        new Promise<void>(async (resolve) => {
          while (!controller.signal.aborted) {
            const question = await rl.question("> ");
            if (question === "exit") {
              break;
            }
            console.log("User:", question);
            send(
              cliContext,
              { user: "admin" },
              {
                user: "admin",
                text: question,
              }
            );
          }

          resolve();
        });

        return () => {
          controller.abort();
        };
      },
    }),
  },
  outputs: {
    "cli:message": output({
      description: "Send messages to the user",
      schema: z.string().describe("The message to send"),
      handler({ content }) {
        console.log("Agent:", { content });
        return {
          data: content,
          timestamp: Date.now(),
        };
      },
    }),
  },
});

--- End File: examples/extensions/cli.ts ---

--- File: examples/games/gigaverse/README.md ---
# Gigaverse Terminal UI

This project provides a terminal-based user interface for the Gigaverse game,
allowing you to play the rock-paper-scissors dungeon crawler game through a
terminal interface.

## Features

- Real-time game state visualization

## Setup

1. Install dependencies:

   ```
   bun i && bun run build:packages
   ```

2. Set up environment variables: Create a `.env` file in the root directory with
   the following variables:

   To get the GIGA_TOKEN you need to login to you:

   1. Login to gigaverse account
   2. Inspect the page. Navigate to 'Application'
   3. Storage -> Local Storage
   4. Within the `authResponse` there will be a value called `jwt` - this is the
      GIGA_TOKEN.
   5. Copy and save in your ENV

   ```
   ANTHROPIC_API_KEY=your_anthropic_api_key
   GIGA_TOKEN=your_gigaverse_token
   OPENAI_API_KEY=your_openai_api_key
   ```

3. Run the application:
   ```
   bun run examples/games/gigaverse/example-gigaverse-simple-ui.ts
   ```

--- End File: examples/games/gigaverse/README.md ---

--- File: examples/games/gigaverse/example-gigaverse-simple-ui.ts ---
/**
 * Example Gigaverse Integration
 *
 * This file demonstrates integration with the Gigaverse game ecosystem.
 * It sets up an agent that can interact with the Gigaverse API to:
 * - Navigate dungeons
 * - Make combat decisions
 * - Select loot and rewards
 * - Manage inventory and character progression
 *
 * The agent uses a goal-oriented approach to plan and execute actions
 * within the game world, making strategic decisions based on the current
 * game state and available options.
 *
 * Authentication is handled via the GIGA_TOKEN environment variable,
 * which must be properly configured for API access. This is the Bearer token. You can copy this from your browser environment.
 *
 * DEBUGGING
 * 1. Your GIGA token expires every 24hrs. Unsure exactly when. If you get an error about the token, just re-authenticate.
 * 2. You can run out of Energy per day - so this will obviously affect your ability to play and throw errors.
 */

import { anthropic } from "@ai-sdk/anthropic";
import {
  createDreams,
  context,
  render,
  action,
  validateEnv,
  LogLevel,
  type Agent,
  createMemoryStore,
  createVectorStore,
  extension,
} from "@daydreamsai/core";
import { cliExtension } from "@daydreamsai/cli";
import { string, z } from "zod";
import { simpleUI } from "./simple-ui";
import { openai } from "@ai-sdk/openai";

// Initialize the UI
simpleUI.initializeUI();

// Log startup message
simpleUI.logMessage(
  LogLevel.INFO,
  "Starting Gigaverse Dream Agent with Simple Terminal UI..."
);

// Validate environment variables
const env = validateEnv(
  z.object({
    ANTHROPIC_API_KEY: z.string().min(1, "ANTHROPIC_API_KEY is required"),
    GIGA_TOKEN: z.string().min(1, "GIGA_TOKEN is required"),
  })
);

// Template for the agent's context
const template = `
You are an expert AI agent playing a strategic roguelike dungeon crawler game based on rock-paper-scissors mechanics with additional RPG elements called Gigaverse. 

<goal>
- Keep the User updated on the progress and your thinking around what you are doing.
- You must always make a new run if you die.
- You must never stop playing. If you die, you must start a new run.
- You must always make a strategic decision based on the current state of the game.
</goal>

## Game Overview:
- Roguelike dungeon crawler with turn-based combat
- Core combat uses rock-paper-scissors (RPS) mechanics with RPG stats
- Each run is unique and ends when you die
- Progress through rooms by defeating enemies
- Collect loot to strengthen your character

## Combat Mechanics:
- Each battle is 1v1 turn-based combat
- You and enemies have stats:
  - HP (Health Points)
  - Defense (Reduces damage taken)
  - Attack values for Rock/Paper/Scissors moves
  - Defense values for Rock/Paper/Scissors moves
- Standard RPS rules apply:
  - Rock beats Scissors
  - Scissors beats Paper
  - Paper beats Rock
- Damage calculation considers:
  - Base attack value of the winning move
  - Defender's defense stat
  - Specific defense value against the attack type

## Progression System:
- Start in Room 1 and progress by defeating enemies
- After each victory, you can choose from multiple loot options
- Loot can improve your stats or provide special abilities
- Higher rooms contain stronger enemies but better rewards
- Goal is to progress as far as possible before dying

## Strategic Elements:
- Analyze enemy patterns and stats
- Choose optimal moves based on attack/defense values
- Make strategic loot decisions to build your character
- Balance aggressive and defensive playstyles
- Adapt strategy based on current HP and enemy threats

Remember to:
- Monitor your HP and enemy stats
- Consider both immediate battles and long-term survival
- Make informed decisions about loot selection
- Learn from enemy patterns to predict their moves

## Current Status:
Goal: {{goal}} 
Tasks: {{tasks}}
Current Task: {{currentTask}}

## Game State:
Dungeon: {{currentDungeon}}
Room: {{currentRoom}}
Loot Phase: {{lootPhase}}
Last Battle Result: {{lastBattleResult}}
Last Enemy Move: {{lastEnemyMove}}

## Player Stats:
HP: {{playerHealth}}/{{playerMaxHealth}}
Shield: {{playerShield}}/{{playerMaxShield}}
Rock: ATK {{rockAttack}} | DEF {{rockDefense}} | Charges {{rockCharges}}
Paper: ATK {{paperAttack}} | DEF {{paperDefense}} | Charges {{paperCharges}}
Scissor: ATK {{scissorAttack}} | DEF {{scissorDefense}} | Charges {{scissorCharges}}

## Enemy Stats:
Enemy ID: {{currentEnemy}}
HP: {{enemyHealth}}/{{enemyMaxHealth}}
Shield: {{enemyShield}}/{{enemyMaxShield}}

`;

// Define an interface for the state
interface GigaverseState {
  goal: string;
  tasks: string[];
  currentTask: string | null;
  currentDungeon: string;
  currentRoom: string;
  currentEnemy: string;
  currentLoot: string;
  currentHP: string;
  playerHealth: string;
  playerMaxHealth: string;
  playerShield: string;
  playerMaxShield: string;
  rockAttack: string;
  rockDefense: string;
  rockCharges: string;
  paperAttack: string;
  paperDefense: string;
  paperCharges: string;
  scissorAttack: string;
  scissorDefense: string;
  scissorCharges: string;
  enemyHealth: string;
  enemyMaxHealth: string;
  enemyShield: string;
  enemyMaxShield: string;
  lootPhase: string;
  lootOptions: any[];
  lastBattleResult: string;
  lastEnemyMove: string;
}

// Context for the agent
const goalContexts = context({
  type: "goal",
  schema: z.object({
    id: string(),
    initialGoal: z.string(),
    initialTasks: z.array(z.string()),
  }),

  key({ id }) {
    return id;
  },

  create(state): GigaverseState {
    return {
      goal: state.args.initialGoal,
      tasks: state.args.initialTasks ?? [],
      currentTask: state.args.initialTasks?.[0],
      currentDungeon: "0",
      currentRoom: "0",
      currentEnemy: "0",
      currentLoot: "0",
      currentHP: "0",
      playerHealth: "0",
      playerMaxHealth: "0",
      playerShield: "0",
      playerMaxShield: "0",
      rockAttack: "0",
      rockDefense: "0",
      rockCharges: "0",
      paperAttack: "0",
      paperDefense: "0",
      paperCharges: "0",
      scissorAttack: "0",
      scissorDefense: "0",
      scissorCharges: "0",
      enemyHealth: "0",
      enemyMaxHealth: "0",
      enemyShield: "0",
      enemyMaxShield: "0",
      lootPhase: "false",
      lootOptions: [],
      lastBattleResult: "",
      lastEnemyMove: "",
    };
  },

  render({ memory }) {
    return render(template, {
      goal: memory.goal,
      tasks: memory.tasks.join("\n"),
      currentTask: memory.currentTask ?? "NONE",
      currentDungeon: memory.currentDungeon ?? "0",
      currentRoom: memory.currentRoom ?? "0",
      currentEnemy: memory.currentEnemy ?? "0",
      currentLoot: memory.currentLoot ?? "0",
      currentHP: memory.currentHP ?? "0",
      playerHealth: memory.playerHealth ?? "0",
      playerMaxHealth: memory.playerMaxHealth ?? "0",
      playerShield: memory.playerShield ?? "0",
      playerMaxShield: memory.playerMaxShield ?? "0",
      rockAttack: memory.rockAttack ?? "0",
      rockDefense: memory.rockDefense ?? "0",
      rockCharges: memory.rockCharges ?? "0",
      paperAttack: memory.paperAttack ?? "0",
      paperDefense: memory.paperDefense ?? "0",
      paperCharges: memory.paperCharges ?? "0",
      scissorAttack: memory.scissorAttack ?? "0",
      scissorDefense: memory.scissorDefense ?? "0",
      scissorCharges: memory.scissorCharges ?? "0",
      enemyHealth: memory.enemyHealth ?? "0",
      enemyMaxHealth: memory.enemyMaxHealth ?? "0",
      enemyShield: memory.enemyShield ?? "0",
      enemyMaxShield: memory.enemyMaxShield ?? "0",
      lootPhase: memory.lootPhase ?? "false",
      lootOptions: memory.lootOptions ?? [],
      lastBattleResult: memory.lastBattleResult ?? "",
      lastEnemyMove: memory.lastEnemyMove ?? "",
    } as any);
  },
});

const gigaExtension = extension({
  name: "giga",
  contexts: {
    goal: goalContexts,
  },
  actions: [
    /**
     * Action to attack in the rock-paper-scissors game
     */
    action({
      name: "attackInDungeon",
      description:
        "Attack in the dungeon using rock-paper-scissors game mechanics",
      schema: z
        .object({
          action: z
            .enum([
              "rock",
              "paper",
              "scissor",
              "loot_one",
              "loot_two",
              "loot_three",
            ])
            .describe("The attack move to make"),
          dungeonId: z
            .number()
            .default(0)
            .describe("The ID of the dungeon. It is always 0."),
        })
        .describe(
          "You use this to make an action in a dungeon. If the lootPhase == true then you can select the Loot option, which will then take you to the next phase. If the lootPhase == false then you can select the Rock, Paper, Scissors option."
        ),
      async handler(data, ctx: any, agent: Agent) {
        try {
          // Log the action to the UI
          simpleUI.logAgentAction(`Attack with ${data.action}`, null);

          const { action, dungeonId } = data;

          const payload = {
            action: action,
            actionToken: new Date().getTime().toString(),
            dungeonId: dungeonId,
          };

          const response = await fetch(
            "https://gigaverse.io/api/game/dungeon/action",
            {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                Authorization: `Bearer ${env.GIGA_TOKEN}`,
              },
              body: JSON.stringify(payload),
            }
          );

          if (!response.ok) {
            throw new Error(
              `Attack action failed with status ${response.status}`
            );
          }

          const result = await response.json();

          // Update the UI with the result
          const successResult = {
            success: true,
            message: `Successfully performed ${action} attack in dungeon ${dungeonId}`,
          };
          simpleUI.logAgentAction(`Attack with ${action}`, successResult);

          // If this was a combat action, visualize the RPS result
          let enemyMove = "unknown";
          let battleResult = "draw";

          // Update the state with player and enemy data
          const state = ctx.agentMemory as GigaverseState;

          // Extract data from the response structure
          if (
            result.data &&
            result.data.run &&
            result.data.run.players &&
            result.data.run.players.length >= 2
          ) {
            const playerData = result.data.run.players[0]; // First player is the user
            const enemyData = result.data.run.players[1]; // Second player is the enemy

            // Get the enemy's last move
            enemyMove = enemyData.lastMove || "unknown";

            // Determine the battle result
            if (playerData.thisPlayerWin === true) {
              battleResult = "win";
            } else if (enemyData.thisPlayerWin === true) {
              battleResult = "lose";
            } else {
              battleResult = "draw";
            }

            // Update player stats
            state.currentHP = playerData.health.current.toString();
            state.playerHealth = playerData.health.current.toString();
            state.playerMaxHealth = playerData.health.currentMax.toString();
            state.playerShield = playerData.shield.current.toString();
            state.playerMaxShield = playerData.shield.currentMax.toString();

            // Update rock/paper/scissor stats
            state.rockAttack = playerData.rock.currentATK.toString();
            state.rockDefense = playerData.rock.currentDEF.toString();
            state.rockCharges = playerData.rock.currentCharges.toString();

            state.paperAttack = playerData.paper.currentATK.toString();
            state.paperDefense = playerData.paper.currentDEF.toString();
            state.paperCharges = playerData.paper.currentCharges.toString();

            state.scissorAttack = playerData.scissor.currentATK.toString();
            state.scissorDefense = playerData.scissor.currentDEF.toString();
            state.scissorCharges = playerData.scissor.currentCharges.toString();

            // Update enemy stats
            state.enemyHealth = enemyData.health.current.toString();
            state.enemyMaxHealth = enemyData.health.currentMax.toString();
            state.enemyShield = enemyData.shield.current.toString();
            state.enemyMaxShield = enemyData.shield.currentMax.toString();

            // Update battle result and enemy move
            state.lastBattleResult = battleResult;
            state.lastEnemyMove = enemyMove;

            // Update loot phase status
            state.lootPhase = (result.data.run.lootPhase || false).toString();

            // Update loot options if available
            if (
              result.data.run.lootOptions &&
              result.data.run.lootOptions.length > 0
            ) {
              state.lootOptions = result.data.run.lootOptions;
              state.currentLoot = result.data.run.lootOptions.length.toString();
            }

            // Update room information
            if (result.data.entity) {
              state.currentRoom = result.data.entity.ROOM_NUM_CID.toString();
              state.currentDungeon =
                result.data.entity.DUNGEON_ID_CID.toString();
              state.currentEnemy = result.data.entity.ENEMY_CID.toString();
            }
          }

          if (["rock", "paper", "scissor"].includes(action)) {
            simpleUI.visualizeRPSMove(action, enemyMove, battleResult);
          }

          // Display the updated state to the user
          simpleUI.printDetailedGameState(state);

          // Update game state in the UI
          if (result.gameState) {
            simpleUI.printGameState(result.gameState);
          }

          // Update player stats in the UI
          if (result.playerState) {
            simpleUI.printPlayerStats(result.playerState);
          }

          return {
            success: true,
            result,
            message: `
            Successfully performed ${action} attack in dungeon ${dungeonId}

            Enemy Move: ${enemyMove}
            Battle Result: ${battleResult}

            Player Health: ${state.playerHealth}
            Player Max Health: ${state.playerMaxHealth}
            Player Shield: ${state.playerShield}
            Player Max Shield: ${state.playerMaxShield}
            

            `,
          };
        } catch (error: unknown) {
          const errorMessage =
            error instanceof Error ? error.message : String(error);
          console.error("Error performing attack action:", error);

          // Log the error to the UI
          const failureResult = {
            success: false,
            error: errorMessage,
            message: "Failed to perform attack action",
          };
          simpleUI.logAgentAction(`Attack with ${data.action}`, failureResult);

          return {
            success: false,
            error: errorMessage,
            message: "Failed to perform attack action",
          };
        }
      },
    }),

    /**
     * Action to fetch upcoming enemies data
     */
    action({
      name: "getUpcomingEnemies",
      description:
        "Fetch information about all upcoming enemies in the dungeon",
      schema: z.object({}), // No parameters needed for this GET request
      async handler(data, ctx: any, agent: Agent) {
        try {
          // Log the action to the UI
          simpleUI.logAgentAction("Fetching upcoming enemies", null);

          const response = await fetch(
            "https://gigaverse.io/api/indexer/enemies",
            {
              method: "GET",
              headers: {
                "Content-Type": "application/json",
                Authorization: `Bearer ${env.GIGA_TOKEN}`,
              },
            }
          );

          if (!response.ok) {
            throw new Error(
              `Fetch enemies failed with status ${response.status}`
            );
          }

          const result = await response.json();

          // Update the enemy info in the UI
          simpleUI.printEnemyInfo(result);

          // Log success to the UI
          const successResult = {
            success: true,
            message: "Successfully fetched upcoming enemies data",
          };
          simpleUI.logAgentAction("Fetching upcoming enemies", successResult);

          return {
            success: true,
            enemies: result,
            message: "Successfully fetched upcoming enemies data",
          };
        } catch (error: unknown) {
          const errorMessage =
            error instanceof Error ? error.message : String(error);
          console.error("Error fetching enemies data:", error);

          // Log the error to the UI
          const failureResult = {
            success: false,
            error: errorMessage,
            message: "Failed to fetch upcoming enemies data",
          };
          simpleUI.logAgentAction("Fetching upcoming enemies", failureResult);

          return {
            success: false,
            error: errorMessage,
            message: "Failed to fetch upcoming enemies data",
          };
        }
      },
    }),

    /**
     * Action to fetch the player's current state in the dungeon
     */
    action({
      name: "getPlayerState",
      description: "Fetch the current state of the player in the dungeon",
      schema: z.object({}), // No parameters needed for this GET request
      async handler(data, ctx: any, agent: Agent) {
        try {
          // Log the action to the UI
          simpleUI.logAgentAction("Fetching player state", null);

          const response = await fetch(
            "https://gigaverse.io/api/game/dungeon/state",
            {
              method: "GET",
              headers: {
                "Content-Type": "application/json",
                Authorization: `Bearer ${env.GIGA_TOKEN}`,
              },
            }
          );

          if (!response.ok) {
            throw new Error(
              `Fetch player state failed with status ${response.status}`
            );
          }

          const result = await response.json();

          // Update game state in the UI if available
          if (result.gameState) {
            simpleUI.printGameState(result.gameState);
          }

          // Update the state with player data
          if (
            result.data &&
            result.data.run &&
            result.data.run.players &&
            result.data.run.players.length > 0
          ) {
            const state = ctx.agentMemory as GigaverseState;
            const playerData = result.data.run.players[0]; // First player is the user

            // Update player stats
            state.currentHP = playerData.health.current.toString();
            state.playerHealth = playerData.health.current.toString();
            state.playerMaxHealth = playerData.health.currentMax.toString();
            state.playerShield = playerData.shield.current.toString();
            state.playerMaxShield = playerData.shield.currentMax.toString();

            // Update rock/paper/scissor stats
            state.rockAttack = playerData.rock.currentATK.toString();
            state.rockDefense = playerData.rock.currentDEF.toString();
            state.rockCharges = playerData.rock.currentCharges.toString();

            state.paperAttack = playerData.paper.currentATK.toString();
            state.paperDefense = playerData.paper.currentDEF.toString();
            state.paperCharges = playerData.paper.currentCharges.toString();

            state.scissorAttack = playerData.scissor.currentATK.toString();
            state.scissorDefense = playerData.scissor.currentDEF.toString();
            state.scissorCharges = playerData.scissor.currentCharges.toString();

            // Update loot phase status
            state.lootPhase = (result.data.run.lootPhase || false).toString();

            // Update loot options if available
            if (
              result.data.run.lootOptions &&
              result.data.run.lootOptions.length > 0
            ) {
              state.lootOptions = result.data.run.lootOptions;
              state.currentLoot = result.data.run.lootOptions.length.toString();
            }

            // Update room information if available
            if (result.data.entity) {
              state.currentRoom = result.data.entity.ROOM_NUM_CID.toString();
              state.currentDungeon =
                result.data.entity.DUNGEON_ID_CID.toString();
              state.currentEnemy = result.data.entity.ENEMY_CID.toString();
            }

            // Update enemy stats if available
            if (result.data.run.players.length > 1) {
              const enemyData = result.data.run.players[1]; // Second player is the enemy
              state.enemyHealth = enemyData.health.current.toString();
              state.enemyMaxHealth = enemyData.health.currentMax.toString();
              state.enemyShield = enemyData.shield.current.toString();
              state.enemyMaxShield = enemyData.shield.currentMax.toString();

              // Update battle result and enemy move if available
              if (enemyData.lastMove) {
                state.lastEnemyMove = enemyData.lastMove;

                // Determine battle result if not already set
                if (
                  !state.lastBattleResult &&
                  playerData.thisPlayerWin !== undefined
                ) {
                  if (playerData.thisPlayerWin === true) {
                    state.lastBattleResult = "win";
                  } else if (enemyData.thisPlayerWin === true) {
                    state.lastBattleResult = "lose";
                  } else {
                    state.lastBattleResult = "draw";
                  }
                }
              }
            }

            // Display the updated state to the user
            simpleUI.printDetailedGameState(state);
          }

          // Log success to the UI
          const successResult = {
            success: true,
            message: "Successfully fetched player's dungeon state",
          };
          simpleUI.logAgentAction("Fetching player state", successResult);

          return {
            success: true,
            playerState: result,
            message: "Successfully fetched player's dungeon state",
          };
        } catch (error: unknown) {
          const errorMessage =
            error instanceof Error ? error.message : String(error);
          console.error("Error fetching player state:", error);

          // Log the error to the UI
          const failureResult = {
            success: false,
            error: errorMessage,
            message: "Failed to fetch player's dungeon state",
          };
          simpleUI.logAgentAction("Fetching player state", failureResult);

          return {
            success: false,
            error: errorMessage,
            message: "Failed to fetch player's dungeon state",
          };
        }
      },
    }),

    /**
     * Action to start a new dungeon run
     */
    action({
      name: "startNewRun",
      description:
        "Start a new dungeon run. Use this when the player dies or wants to start a new run from outside the dungeon.",
      schema: z.object({
        dungeonId: z
          .number()
          .default(1)
          .describe("The ID of the dungeon to start. Default is 1."),
      }),
      async handler(data, ctx: any, agent: Agent) {
        try {
          // Log the action to the UI
          simpleUI.logAgentAction(
            `Starting new run in dungeon ${data.dungeonId}`,
            null
          );

          const { dungeonId } = data;

          const payload = {
            action: "start_run",
            actionToken: "",
            dungeonId: dungeonId,
            data: {
              consumables: [],
              itemId: 0,
              index: 0,
            },
          };

          const response = await fetch(
            "https://gigaverse.io/api/game/dungeon/action",
            {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                Authorization: `Bearer ${env.GIGA_TOKEN}`,
              },
              body: JSON.stringify(payload),
            }
          );

          if (!response.ok) {
            throw new Error(
              `Start new run failed with status ${response.status}`
            );
          }

          const result = await response.json();

          // Update game state in the UI
          if (result.gameState) {
            simpleUI.printGameState(result.gameState);
          }

          // Update player stats in the UI
          if (result.playerState) {
            simpleUI.printPlayerStats(result.playerState);
          }

          // Update the state with the new run data
          if (
            result.data &&
            result.data.run &&
            result.data.run.players &&
            result.data.run.players.length > 0
          ) {
            const state = ctx.agentMemory as GigaverseState;
            const playerData = result.data.run.players[0]; // First player is the user

            // Update player stats
            state.currentHP = playerData.health.current.toString();
            state.playerHealth = playerData.health.current.toString();
            state.playerMaxHealth = playerData.health.currentMax.toString();
            state.playerShield = playerData.shield.current.toString();
            state.playerMaxShield = playerData.shield.currentMax.toString();

            // Update rock/paper/scissor stats
            state.rockAttack = playerData.rock.currentATK.toString();
            state.rockDefense = playerData.rock.currentDEF.toString();
            state.rockCharges = playerData.rock.currentCharges.toString();

            state.paperAttack = playerData.paper.currentATK.toString();
            state.paperDefense = playerData.paper.currentDEF.toString();
            state.paperCharges = playerData.paper.currentCharges.toString();

            state.scissorAttack = playerData.scissor.currentATK.toString();
            state.scissorDefense = playerData.scissor.currentDEF.toString();
            state.scissorCharges = playerData.scissor.currentCharges.toString();

            // Update dungeon info
            state.currentDungeon = dungeonId.toString();
            state.currentRoom = "1"; // New runs start at room 1
            state.lootPhase = "false";
            state.lootOptions = [];
            state.lastBattleResult = "";
            state.lastEnemyMove = "";

            // Update enemy stats (reset them for new run)
            state.enemyHealth = "0";
            state.enemyMaxHealth = "0";
            state.enemyShield = "0";
            state.enemyMaxShield = "0";
            state.currentEnemy = "0";

            // Display the updated state to the user
            simpleUI.printDetailedGameState(state);
          }

          // Log success to the UI
          const successResult = {
            success: true,
            message: `Successfully started a new run in dungeon ${dungeonId}`,
          };
          simpleUI.logAgentAction(
            `Starting new run in dungeon ${dungeonId}`,
            successResult
          );

          return {
            success: true,
            result,
            message: `Successfully started a new run in dungeon ${dungeonId}`,
          };
        } catch (error: unknown) {
          const errorMessage =
            error instanceof Error ? error.message : String(error);
          console.error("Error starting new run:", error);

          // Log the error to the UI
          const failureResult = {
            success: false,
            error: errorMessage,
            message: "Failed to start a new dungeon run",
          };
          simpleUI.logAgentAction(
            `Starting new run in dungeon ${data.dungeonId}`,
            failureResult
          );

          return {
            success: false,
            error: errorMessage,
            message: "Failed to start a new dungeon run",
          };
        }
      },
    }),
  ],
});

// Create the Gigaverse agent with UI integration
const agent = createDreams({
  logger: LogLevel.DEBUG,
  model: anthropic("claude-3-7-sonnet-latest"),
  extensions: [cliExtension, gigaExtension],
  exportTrainingData: true,
  trainingDataPath: "./training-data.jsonl",
  memory: {
    store: createMemoryStore(),
    vector: createVectorStore(),
    vectorModel: openai("gpt-4-turbo"),
  },
});

// Start the agent with initial goals
simpleUI.logMessage(LogLevel.INFO, "Starting agent with initial goals...");

agent.start({
  id: "gigaverse-game",
  initialGoal:
    "Progress as far as possible in the dungeon by making strategic rock-paper-scissors decisions. Don't ever stop. Just start a new run if you die.",
  initialTasks: [
    "Check player state to understand current situation",
    "Fetch information about upcoming enemies",
    "Start a new run if not already in a dungeon",
    "Make strategic combat decisions based on enemy patterns",
    "Select optimal loot to improve chances of survival",
  ],
});

// Display welcome message
simpleUI.logMessage(
  LogLevel.INFO,
  "Gigaverse Dream Agent is now running! The agent will automatically play the game."
);

// Handle exit
process.on("SIGINT", () => {
  simpleUI.logMessage(LogLevel.INFO, "Shutting down agent...");
  process.exit(0);
});

--- End File: examples/games/gigaverse/example-gigaverse-simple-ui.ts ---

--- File: examples/games/gigaverse/example-gigaverse.ts ---
/**
 * Example Gigaverse Integration
 *
 * This file demonstrates integration with the Gigaverse game ecosystem.
 * It sets up an agent that can interact with the Gigaverse API to:
 * - Navigate dungeons
 * - Make combat decisions
 * - Select loot and rewards
 * - Manage inventory and character progression
 *
 * The agent uses a goal-oriented approach to plan and execute actions
 * within the game world, making strategic decisions based on the current
 * game state and available options.
 *
 * Authentication is handled via the GIGA_TOKEN environment variable,
 * which must be properly configured for API access. This is the Bearer token. You can copy this from your browser environment.
 */

import { anthropic } from "@ai-sdk/anthropic";
import {
  createDreams,
  context,
  render,
  action,
  validateEnv,
  LogLevel,
  type ActionCall,
  type Agent,
} from "@daydreamsai/core";
import { cliExtension } from "@daydreamsai/cli";
import { string, z } from "zod";

const env = validateEnv(
  z.object({
    ANTHROPIC_API_KEY: z.string().min(1, "ANTHROPIC_API_KEY is required"),
    GIGA_TOKEN: z.string().min(1, "GIGA_TOKEN is required"),
  })
);

// 1. Take action -> check health -> check loot phase = true -> select loot
// 2. Select the loot -> takes to new phase -> take 1. again

const template = `

// inject more information about how you want it to play....


Goal: {{goal}} 
Tasks: {{tasks}}
Current Task: {{currentTask}}
`;

const goalContexts = context({
  type: "goal",
  schema: z.object({
    id: string(),
    initialGoal: z.string(),
    initialTasks: z.array(z.string()),
  }),

  key({ id }) {
    return id;
  },

  create(state) {
    return {
      goal: state.args.initialGoal,
      tasks: state.args.initialTasks ?? [],
      currentTask: state.args.initialTasks?.[0],
    };
  },

  render({ memory }) {
    return render(template, {
      goal: memory.goal,
      tasks: memory.tasks.join("\n"),
      currentTask: memory.currentTask ?? "NONE",
    });
  },
});

// ==========================================
// ACTIONS DEFINITION
// ==========================================

/**
 * Create the Gigaverse agent with all necessary actions
 */
createDreams({
  logger: LogLevel.INFO,
  model: anthropic("claude-3-7-sonnet-latest"),
  extensions: [cliExtension],
  context: goalContexts,
  actions: [
    // start run (sends the starting 1-2 dungeon)
    // collect loot (selects the loot from the resonse)
    /**
     * Action to attack in the rock-paper-scissors game
     */
    action({
      name: "attackInDungeon",
      description:
        "Attack in the dungeon using rock-paper-scissors game mechanics",
      schema: z
        .object({
          action: z
            .enum([
              "rock",
              "paper",
              "scissor",
              "loot_one",
              "loot_two",
              "loot_three",
            ])
            .describe("The attack move to make"),
          dungeonId: z
            .number()
            .default(0)
            .describe("The ID of the dungeon. It is always 0. "),
        })
        .describe(
          "You use this to make an action in a dungeon. If the lootPhase == true then you can select the Loot option, which will then take you to the next phase. If the lootPhase == false then you can select the Rock, Paper, Scissors option."
        ),
      async handler(data, ctx: any, agent: Agent) {
        try {
          const { action, dungeonId } = data;

          const payload = {
            action: action,
            actionToken: new Date().getTime().toString(),
            dungeonId: dungeonId,
          };

          const response = await fetch(
            "https://gigaverse.io/api/game/dungeon/action",
            {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                Authorization: `Bearer ${env.GIGA_TOKEN}`,
              },
              body: JSON.stringify(payload),
            }
          );

          if (!response.ok) {
            throw new Error(
              `Attack action failed with status ${response.status}`
            );
          }

          const result = await response.json();
          return {
            success: true,
            result,
            message: `Successfully performed ${action} attack in dungeon ${0}`,
          };
        } catch (error: unknown) {
          const errorMessage =
            error instanceof Error ? error.message : String(error);
          console.error("Error performing attack action:", error);
          return {
            success: false,
            error: errorMessage,
            message: "Failed to perform attack action",
          };
        }
      },
    }),

    /**
     * Action to fetch upcoming enemies data
     */
    action({
      name: "getUpcomingEnemies",
      description:
        "Fetch information about all upcoming enemies in the dungeon",
      schema: z.object({}), // No parameters needed for this GET request
      async handler(data, ctx: any, agent: Agent) {
        try {
          const response = await fetch(
            "https://gigaverse.io/api/indexer/enemies",
            {
              method: "GET",
              headers: {
                "Content-Type": "application/json",
                Authorization: `Bearer ${env.GIGA_TOKEN}`,
              },
            }
          );

          if (!response.ok) {
            throw new Error(
              `Fetch enemies failed with status ${response.status}`
            );
          }

          const result = await response.json();
          return {
            success: true,
            enemies: result,
            message: "Successfully fetched upcoming enemies data",
          };
        } catch (error: unknown) {
          const errorMessage =
            error instanceof Error ? error.message : String(error);
          console.error("Error fetching enemies data:", error);
          return {
            success: false,
            error: errorMessage,
            message: "Failed to fetch upcoming enemies data",
          };
        }
      },
    }),

    /**
     * Action to fetch the player's current state in the dungeon
     */
    action({
      name: "getPlayerState",
      description: "Fetch the current state of the player in the dungeon",
      schema: z.object({}), // No parameters needed for this GET request
      async handler(data, ctx: any, agent: Agent) {
        try {
          const response = await fetch(
            "https://gigaverse.io/api/game/dungeon/state",
            {
              method: "GET",
              headers: {
                "Content-Type": "application/json",
                Authorization: `Bearer ${env.GIGA_TOKEN}`,
              },
            }
          );

          if (!response.ok) {
            throw new Error(
              `Fetch player state failed with status ${response.status}`
            );
          }

          const result = await response.json();
          return {
            success: true,
            playerState: result,
            message: "Successfully fetched player's dungeon state",
          };
        } catch (error: unknown) {
          const errorMessage =
            error instanceof Error ? error.message : String(error);
          console.error("Error fetching player state:", error);
          return {
            success: false,
            error: errorMessage,
            message: "Failed to fetch player's dungeon state",
          };
        }
      },
    }),

    /**
     * Action to start a new dungeon run
     */
    action({
      name: "startNewRun",
      description:
        "Start a new dungeon run. Use this when the player dies or wants to start a new run from outside the dungeon.",
      schema: z.object({
        dungeonId: z
          .number()
          .default(1)
          .describe("The ID of the dungeon to start. Default is 1."),
      }),
      async handler(data, ctx: any, agent: Agent) {
        try {
          const { dungeonId } = data;

          const payload = {
            action: "start_run",
            actionToken: new Date().getTime().toString(),
            dungeonId: dungeonId,
          };

          const response = await fetch(
            "https://gigaverse.io/api/game/dungeon/action",
            {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                Authorization: `Bearer ${env.GIGA_TOKEN}`,
              },
              body: JSON.stringify(payload),
            }
          );

          if (!response.ok) {
            throw new Error(
              `Start new run failed with status ${response.status}`
            );
          }

          const result = await response.json();
          return {
            success: true,
            result,
            message: `Successfully started a new run in dungeon ${dungeonId}`,
          };
        } catch (error: unknown) {
          const errorMessage =
            error instanceof Error ? error.message : String(error);
          console.error("Error starting new run:", error);
          return {
            success: false,
            error: errorMessage,
            message: "Failed to start a new dungeon run",
          };
        }
      },
    }),
  ],
}).start({ id: "test", initialGoal: "", initialTasks: [] });

--- End File: examples/games/gigaverse/example-gigaverse.ts ---

--- File: examples/games/gigaverse/package.json ---
{
  "name": "games",
  "module": "index.ts",
  "type": "module",
  "private": true,
  "devDependencies": {
    "@types/bun": "latest"
  },
  "peerDependencies": {
    "typescript": "^5"
  },
  "dependencies": {
    "@ai-sdk/anthropic": "^1.1.15",
    "@ai-sdk/openai": "^1.2.1",
    "@ai-sdk/groq": "^1.1.12",
    "@daydreamsai/cli": "workspace:*",
    "@daydreamsai/core": "workspace:*",
    "@daydreamsai/chromadb": "workspace:*",
    "@daydreamsai/discord": "workspace:*",
    "zod": "^3.24.2"
  }
}

--- End File: examples/games/gigaverse/package.json ---

--- File: examples/games/gigaverse/simple-ui.ts ---
/**
 * Simple Terminal UI for Gigaverse
 *
 * This file provides a simpler terminal UI that doesn't rely on the blessed library.
 * It uses basic ANSI escape codes for colors and formatting.
 */

import { LogLevel } from "@daydreamsai/core";

// ANSI color codes
const COLORS = {
  reset: "\x1b[0m",
  bright: "\x1b[1m",
  dim: "\x1b[2m",
  underscore: "\x1b[4m",
  blink: "\x1b[5m",
  reverse: "\x1b[7m",
  hidden: "\x1b[8m",

  black: "\x1b[30m",
  red: "\x1b[31m",
  green: "\x1b[32m",
  yellow: "\x1b[33m",
  blue: "\x1b[34m",
  magenta: "\x1b[35m",
  cyan: "\x1b[36m",
  white: "\x1b[37m",

  bgBlack: "\x1b[40m",
  bgRed: "\x1b[41m",
  bgGreen: "\x1b[42m",
  bgYellow: "\x1b[43m",
  bgBlue: "\x1b[44m",
  bgMagenta: "\x1b[45m",
  bgCyan: "\x1b[46m",
  bgWhite: "\x1b[47m",
};

// Map log levels to colors
const LOG_LEVEL_COLORS = {
  [LogLevel.TRACE]: COLORS.dim + COLORS.white,
  [LogLevel.DEBUG]: COLORS.blue,
  [LogLevel.INFO]: COLORS.green,
  [LogLevel.WARN]: COLORS.yellow,
  [LogLevel.ERROR]: COLORS.red,
};

// Map game elements to colors
const GAME_COLORS = {
  rock: COLORS.red,
  paper: COLORS.green,
  scissor: COLORS.blue,
  health: COLORS.red,
  mana: COLORS.blue,
  gold: COLORS.yellow,
  enemy: COLORS.magenta,
  loot: COLORS.cyan,
};

// Clear the terminal
export function clearScreen(): void {
  process.stdout.write("\x1Bc");
}

// Print a section header
export function printHeader(title: string): void {
  const width = process.stdout.columns || 80;
  const padding = "=".repeat(Math.floor((width - title.length - 4) / 2));
  console.log(
    `\n${padding} ${COLORS.bright}${title}${COLORS.reset} ${padding}\n`
  );
}

// Print a log message
export function logMessage(level: LogLevel, message: string): void {
  const color = LOG_LEVEL_COLORS[level] || COLORS.white;
  const levelName = LogLevel[level].toUpperCase();
  const timestamp = new Date().toLocaleTimeString();
  console.log(
    `${color}[${timestamp}] [${levelName}] ${message}${COLORS.reset}`
  );
}

// Print player stats
export function printPlayerStats(playerState: any): void {
  if (!playerState) {
    console.log(`${COLORS.yellow}No player data available${COLORS.reset}`);
    return;
  }

  printHeader("Player Stats");

  const { health, maxHealth, gold, level, inventory } = playerState;

  // Create a health bar
  const healthPercentage = Math.floor((health / maxHealth) * 100);
  const healthBar = createProgressBar(healthPercentage, COLORS.red);

  console.log(
    `${COLORS.bright}Health:${COLORS.reset} ${health}/${maxHealth} ${healthBar}`
  );
  console.log(`${COLORS.bright}Level:${COLORS.reset} ${level}`);
  console.log(
    `${COLORS.bright}Gold:${COLORS.reset} ${COLORS.yellow}${gold}${COLORS.reset}`
  );

  // Format inventory if available
  if (inventory && inventory.length > 0) {
    console.log(`\n${COLORS.bright}Inventory:${COLORS.reset}`);
    inventory.forEach((item: any) => {
      console.log(`  - ${item.name} (${item.quantity})`);
    });
  } else {
    console.log(`\n${COLORS.bright}Inventory:${COLORS.reset} None`);
  }
}

// Print game state
export function printGameState(gameState: any): void {
  if (!gameState) {
    console.log(`${COLORS.yellow}No game state available${COLORS.reset}`);
    return;
  }

  printHeader("Game State");

  const { dungeonId, currentRoom, lootPhase, enemyName, enemyHealth } =
    gameState;

  console.log(`${COLORS.bright}Dungeon:${COLORS.reset} ${dungeonId}`);
  console.log(`${COLORS.bright}Room:${COLORS.reset} ${currentRoom}`);
  console.log(
    `${COLORS.bright}Phase:${COLORS.reset} ${lootPhase ? "Loot Selection" : "Combat"}`
  );

  if (enemyName && !lootPhase) {
    // Create an enemy health bar if in combat
    const enemyHealthPercentage = Math.floor(
      (enemyHealth.current / enemyHealth.max) * 100
    );
    const enemyHealthBar = createProgressBar(
      enemyHealthPercentage,
      COLORS.magenta
    );

    console.log(
      `\n${COLORS.bright}Current Enemy:${COLORS.reset} ${COLORS.magenta}${enemyName}${COLORS.reset}`
    );
    console.log(
      `${COLORS.bright}Enemy Health:${COLORS.reset} ${enemyHealth.current}/${enemyHealth.max} ${enemyHealthBar}`
    );
  } else if (lootPhase) {
    console.log(`\n${COLORS.bright}Select your reward!${COLORS.reset}`);
    console.log(
      `Use the ${COLORS.cyan}loot_one${COLORS.reset}, ${COLORS.cyan}loot_two${COLORS.reset}, or ${COLORS.cyan}loot_three${COLORS.reset} actions to choose.`
    );
  }
}

// Print enemy information
export function printEnemyInfo(enemies: any): void {
  if (!enemies || !enemies.entities || enemies.entities.length === 0) {
    console.log(`${COLORS.yellow}No enemy data available${COLORS.reset}`);
    return;
  }

  printHeader("Upcoming Enemies");

  // Display information about upcoming enemies
  const enemyList = enemies.entities.slice(0, 5); // Show first 5 enemies

  enemyList.forEach((enemy: any, index: number) => {
    console.log(
      `${COLORS.magenta}${index + 1}. ${enemy.NAME_CID}${COLORS.reset}`
    );

    // Display move stats if available
    if (enemy.MOVE_STATS_CID_array && enemy.MOVE_STATS_CID_array.length >= 8) {
      const moveStats = enemy.MOVE_STATS_CID_array;
      console.log(
        `   Rock: ${moveStats[0]}, Paper: ${moveStats[2]}, Scissors: ${moveStats[4]}`
      );
    }

    console.log("");
  });
}

// Log an agent action
export function logAgentAction(action: string, result: any): void {
  // Format the action for display
  const timestamp = new Date().toLocaleTimeString();
  console.log(
    `\n${COLORS.bright}[${timestamp}] Agent Action:${COLORS.reset} ${action}`
  );

  // Add result information if available
  if (result) {
    if (result.success) {
      console.log(`${COLORS.green}✓ Success:${COLORS.reset} ${result.message}`);
    } else {
      console.log(`${COLORS.red}✗ Failed:${COLORS.reset} ${result.message}`);
    }
  }
}

// Visualize a rock-paper-scissors move
export function visualizeRPSMove(
  playerMove: string,
  enemyMove: string,
  result: string
): void {
  const moveSymbols: Record<string, string> = {
    rock: "✊",
    paper: "✋",
    scissor: "✌️",
  };

  const playerSymbol = moveSymbols[playerMove] || playerMove;
  const enemySymbol = moveSymbols[enemyMove] || enemyMove;

  let resultColor = COLORS.yellow;
  if (result === "win") resultColor = COLORS.green;
  if (result === "lose") resultColor = COLORS.red;

  printHeader("Rock-Paper-Scissors Result");

  console.log(
    `${COLORS.bright}You:${COLORS.reset} ${GAME_COLORS[playerMove as keyof typeof GAME_COLORS] || COLORS.white}${playerSymbol}${COLORS.reset}  vs  ${COLORS.bright}Enemy:${COLORS.reset} ${GAME_COLORS[enemyMove as keyof typeof GAME_COLORS] || COLORS.white}${enemySymbol}${COLORS.reset}`
  );
  console.log(
    `\n${COLORS.bright}Result:${COLORS.reset} ${resultColor}${result.toUpperCase()}${COLORS.reset}\n`
  );
}

// Create a visual progress bar
function createProgressBar(percentage: number, color: string): string {
  const width = 20;
  const filledWidth = Math.floor((percentage / 100) * width);
  const emptyWidth = width - filledWidth;

  const filled = "█".repeat(filledWidth);
  const empty = "░".repeat(emptyWidth);

  return `${color}${filled}${COLORS.reset}${empty} ${percentage}%`;
}

// Print a divider line
export function printDivider(): void {
  const width = process.stdout.columns || 80;
  console.log("\n" + "-".repeat(width) + "\n");
}

// Print help information
export function printHelp(): void {
  printHeader("Help");
  console.log("This is a simple terminal UI for the Gigaverse game.");
  console.log("Press Ctrl+C to exit the application.");
}

// Initialize the UI
export function initializeUI(): void {
  clearScreen();
  console.log(
    `${COLORS.green}${COLORS.bright}Gigaverse Simple Terminal UI${COLORS.reset}`
  );
  console.log(
    `${COLORS.dim}A simpler alternative to the blessed-based UI${COLORS.reset}`
  );
  printDivider();
}

// Print detailed game state from GigaverseState
export function printDetailedGameState(state: any): void {
  printHeader("Current Game Status");

  // Game location info
  console.log(`${COLORS.bright}${COLORS.cyan}Location:${COLORS.reset}`);
  console.log(`${COLORS.bright}Dungeon:${COLORS.reset} ${state.currentDungeon}`);
  console.log(`${COLORS.bright}Room:${COLORS.reset} ${state.currentRoom}`);
  console.log(`${COLORS.bright}Loot Phase:${COLORS.reset} ${state.lootPhase === "true" ? "Yes" : "No"}`);
  
  // Battle info
  if (state.lastBattleResult) {
    console.log(`\n${COLORS.bright}${COLORS.yellow}Last Battle:${COLORS.reset}`);
    console.log(`${COLORS.bright}Result:${COLORS.reset} ${state.lastBattleResult}`);
    console.log(`${COLORS.bright}Enemy Move:${COLORS.reset} ${state.lastEnemyMove}`);
  }
  
  // Player stats
  console.log(`\n${COLORS.bright}${COLORS.green}Player Stats:${COLORS.reset}`);
  
  // Health and shield
  const healthPercentage = Math.floor((parseInt(state.playerHealth) / parseInt(state.playerMaxHealth)) * 100) || 0;
  const healthBar = createProgressBar(healthPercentage, COLORS.red);
  console.log(`${COLORS.bright}Health:${COLORS.reset} ${state.playerHealth}/${state.playerMaxHealth} ${healthBar}`);
  
  const shieldPercentage = Math.floor((parseInt(state.playerShield) / parseInt(state.playerMaxShield)) * 100) || 0;
  const shieldBar = createProgressBar(shieldPercentage, COLORS.blue);
  console.log(`${COLORS.bright}Shield:${COLORS.reset} ${state.playerShield}/${state.playerMaxShield} ${shieldBar}`);
  
  // Weapon stats
  console.log(`\n${COLORS.bright}Weapon Stats:${COLORS.reset}`);
  console.log(`${COLORS.red}Rock:${COLORS.reset} ATK ${state.rockAttack} | DEF ${state.rockDefense} | Charges ${state.rockCharges}`);
  console.log(`${COLORS.green}Paper:${COLORS.reset} ATK ${state.paperAttack} | DEF ${state.paperDefense} | Charges ${state.paperCharges}`);
  console.log(`${COLORS.blue}Scissor:${COLORS.reset} ATK ${state.scissorAttack} | DEF ${state.scissorDefense} | Charges ${state.scissorCharges}`);
  
  // Enemy stats if available
  if (parseInt(state.enemyHealth) > 0 || state.currentEnemy !== "0") {
    console.log(`\n${COLORS.bright}${COLORS.red}Enemy Stats:${COLORS.reset}`);
    console.log(`${COLORS.bright}Enemy ID:${COLORS.reset} ${state.currentEnemy}`);
    
    const enemyHealthPercentage = Math.floor((parseInt(state.enemyHealth) / parseInt(state.enemyMaxHealth)) * 100) || 0;
    const enemyHealthBar = createProgressBar(enemyHealthPercentage, COLORS.red);
    console.log(`${COLORS.bright}Health:${COLORS.reset} ${state.enemyHealth}/${state.enemyMaxHealth} ${enemyHealthBar}`);
    
    const enemyShieldPercentage = Math.floor((parseInt(state.enemyShield) / parseInt(state.enemyMaxShield)) * 100) || 0;
    const enemyShieldBar = createProgressBar(enemyShieldPercentage, COLORS.blue);
    console.log(`${COLORS.bright}Shield:${COLORS.reset} ${state.enemyShield}/${state.enemyMaxShield} ${enemyShieldBar}`);
  }
  
  // Loot options if available
  if (state.lootPhase === "true" && state.lootOptions && state.lootOptions.length > 0) {
    console.log(`\n${COLORS.bright}${COLORS.yellow}Loot Options:${COLORS.reset}`);
    state.lootOptions.forEach((loot: any, index: number) => {
      console.log(`${COLORS.bright}Option ${index + 1}:${COLORS.reset} ${loot.boonTypeString} (Rarity: ${loot.RARITY_CID})`);
    });
  }
  
  printDivider();
}

// Export a simple UI object
export const simpleUI = {
  clearScreen,
  printHeader,
  logMessage,
  printPlayerStats,
  printGameState,
  printEnemyInfo,
  logAgentAction,
  visualizeRPSMove,
  printDivider,
  printHelp,
  initializeUI,
  printDetailedGameState,
};

--- End File: examples/games/gigaverse/simple-ui.ts ---

--- File: examples/games/lootsurvivor/README.md ---
# Loot Survivor CLI agent

### Make sure you have your starknet env setup in root dir like usual

> check todo at the bottom to see current usage !

1. install deps in root

```bash
bun install
```

then build core

```bash
cd packages/core/
bun run build
```

and also build the defai package located at `packages/defai`:

```bash
cd packages/defai
bun run build
```

then from root, to start the agent:

```bash
bun run examples/games/lootsurvivor/example-lootsurvivor.ts
```

TODO IMPORTANT

- fix the new game issue. CURRENTLY i have to start a new game manually, and
  then boot agent and say something like "You are adventurer 12345. You have
  already been created, so now check state, decide what to do next, act"
- ~~DONE update max health state display~~
- ~~DONE item xp tracking (greatness)~~
- ~~DONE fix level display~~
- ~~DONE market items and cost~~
- ~~DONE check to make sure we are async await for the txns to go through before
  sending the api call to the agent. because i think wwe are calculating state
  before waiting for response, and sending the incomplete state to the agent.~~

--- End File: examples/games/lootsurvivor/README.md ---

--- File: examples/games/lootsurvivor/example-lootsurvivor.ts ---
import {
  action,
  type ActionCall,
  type Agent,
  context,
  createDreams,
  extension,
  render,
  validateEnv,
  LogLevel,
} from "@daydreamsai/core";
import { cliExtension } from "@daydreamsai/cli";
import { anthropic } from "@ai-sdk/anthropic";
import { string, z } from "zod";
import { StarknetChain } from "@daydreamsai/defai";

/**
 * NOTE: To resolve the '@daydreamsai/defai' module error:
 * 1. First make sure you have the package installed by running:
 *    pnpm add @daydreamsai/defai
 *
 * 2. If developing within the monorepo, you may need to add it to your workspace:
 *    In package.json, add:
 *    "dependencies": {
 *      "@daydreamsai/defai": "workspace:*"
 *    }
 */

// Validate environment variables
const env = validateEnv(
  z.object({
    ANTHROPIC_API_KEY: z.string().min(1, "ANTHROPIC_API_KEY is required"),
    STARKNET_RPC_URL: z.string().min(1, "STARKNET_RPC_URL is required"),
    STARKNET_ADDRESS: z.string().min(1, "STARKNET_ADDRESS is required"),
    STARKNET_PRIVATE_KEY: z.string().min(1, "STARKNET_PRIVATE_KEY is required"),
  })
);

// Initialize Starknet chain connection
const starknet = new StarknetChain({
  rpcUrl: env.STARKNET_RPC_URL,
  address: env.STARKNET_ADDRESS,
  privateKey: env.STARKNET_PRIVATE_KEY,
});

// Game contract addresses
const GAME_CONTRACT_ADDRESS =
  "0x018108b32cea514a78ef1b0e4a0753e855cdf620bc0565202c02456f618c4dc4"; // Loot Survivor contract address

// Define an interface for the Loot Survivor state
interface LootSurvivorState {
  // Game state
  adventurerId: string;
  adventurerHealth: string;
  adventurerMaxHealth: string;
  level: string;
  xp: string;
  gold: string;
  statUpgrades: string;

  // Battle state
  inBattle: string;
  lastAction: string;
  lastDamageDealt: string;
  lastDamageTaken: string;
  lastCritical: string;
  battleActionCount: string;

  // Stats
  strength: string;
  dexterity: string;
  vitality: string;
  intelligence: string;
  wisdom: string;
  charisma: string;
  luck: string;

  // Equipment
  weapon: string;
  chest: string;
  head: string;
  waist: string;
  foot: string;
  hand: string;
  neck: string;
  ring: string;

  // Equipment XP (greatness levels)
  weaponXP: string;
  chestXP: string;
  headXP: string;
  waistXP: string;
  footXP: string;
  handXP: string;
  neckXP: string;
  ringXP: string;

  // Beast info
  currentBeast: string;
  beastHealth: string;
  beastMaxHealth: string;
  beastLevel: string;
  beastTier: string;
  beastType: string;
  beastSpecial1: string;
  beastSpecial2: string;
  beastSpecial3: string;

  // Bag/Inventory
  bagItems: string[];

  // Market
  marketItems: Array<{ id: string; name: string; price: string }>;
}

// Helper to convert hex values to decimal
function hexToDec(hex: string): string {
  // Remove '0x' prefix if present
  const cleanHex = hex.startsWith("0x") ? hex.slice(2) : hex;
  return parseInt(cleanHex, 16).toString();
}

// Function to get prefix1 name from ID
function getPrefix1(prefixId: string): string {
  const prefixNames: { [key: string]: string } = {
    "1": "Agony",
    "2": "Apocalypse",
    "3": "Armageddon",
    "4": "Beast",
    "5": "Behemoth",
    "6": "Blight",
    "7": "Blood",
    "8": "Bramble",
    "9": "Brimstone",
    "10": "Brood",
    "11": "Carrion",
    "12": "Cataclysm",
    "13": "Chimeric",
    "14": "Corpse",
    "15": "Corruption",
    "16": "Damnation",
    "17": "Death",
    "18": "Demon",
    "19": "Dire",
    "20": "Dragon",
    "21": "Dread",
    "22": "Doom",
    "23": "Dusk",
    "24": "Eagle",
    "25": "Empyrean",
    "26": "Fate",
    "27": "Foe",
    "28": "Gale",
    "29": "Ghoul",
    "30": "Gloom",
    "31": "Glyph",
    "32": "Golem",
    "33": "Grim",
    "34": "Hate",
    "35": "Havoc",
    "36": "Honour",
    "37": "Horror",
    "38": "Hypnotic",
    "39": "Kraken",
    "40": "Loath",
    "41": "Maelstrom",
    "42": "Mind",
    "43": "Miracle",
    "44": "Morbid",
    "45": "Oblivion",
    "46": "Onslaught",
    "47": "Pain",
    "48": "Pandemonium",
    "49": "Phoenix",
    "50": "Plague",
    "51": "Rage",
    "52": "Rapture",
    "53": "Rune",
    "54": "Skull",
    "55": "Sol",
    "56": "Soul",
    "57": "Sorrow",
    "58": "Spirit",
    "59": "Storm",
    "60": "Tempest",
    "61": "Torment",
    "62": "Vengeance",
    "63": "Victory",
    "64": "Viper",
    "65": "Vortex",
    "66": "Woe",
    "67": "Wrath",
    "68": "Lights",
    "69": "Shimmering",
  };
  return prefixNames[prefixId] || "";
}

// Function to get prefix2 name from ID
function getPrefix2(suffixId: string): string {
  const suffixNames: { [key: string]: string } = {
    "1": "Bane",
    "2": "Root",
    "3": "Bite",
    "4": "Song",
    "5": "Roar",
    "6": "Grasp",
    "7": "Instrument",
    "8": "Glow",
    "9": "Bender",
    "10": "Shadow",
    "11": "Whisper",
    "12": "Shout",
    "13": "Growl",
    "14": "Tear",
    "15": "Peak",
    "16": "Form",
    "17": "Sun",
    "18": "Moon",
  };
  return suffixNames[suffixId] || "";
}

// Function to get suffix name from ID
function getItemSuffix(suffixId: string): string {
  const itemSuffixes: { [key: string]: string } = {
    "1": "of Power",
    "2": "of Giant",
    "3": "of Titans",
    "4": "of Skill",
    "5": "of Perfection",
    "6": "of Brilliance",
    "7": "of Enlightenment",
    "8": "of Protection",
    "9": "of Anger",
    "10": "of Rage",
    "11": "of Fury",
    "12": "of Vitriol",
    "13": "of the Fox",
    "14": "of Detection",
    "15": "of Reflection",
    "16": "of the Twins",
  };
  return itemSuffixes[suffixId] || "";
}

// Function to get item tier from ID
function getItemTier(itemId: number): string {
  // Tier mapping according to loot.cairo and constants.cairo
  // The itemId directly corresponds to the item tiers defined in the contract

  // Item types by tier
  const tierRanges: { [key: string]: number[] } = {
    T1: [
      // Jewelry
      1, 2, 3, 6, 7, 8,
      // Weapons and armor - Per itemId in constants.cairo
      9, 13, 17, 22, 27, 32, 37, 42, 47, 52, 57, 62, 67, 72, 77, 82, 87, 92, 97,
    ],
    T2: [
      // Jewelry
      4,
      // Weapons and armor
      10, 14, 18, 23, 28, 33, 38, 43, 48, 53, 58, 63, 68, 73, 78, 83, 88, 93,
      98,
    ],
    T3: [
      // Jewelry
      5,
      // Weapons and armor
      11, 15, 19, 24, 29, 34, 39, 44, 49, 54, 59, 64, 69, 74, 79, 84, 89, 94,
      99,
    ],
    T4: [
      // Higher tier items
      20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95, 100,
    ],
    T5: [
      // Lowest tier items
      12, 16, 21, 26, 31, 36, 41, 46, 51, 56, 61, 66, 71, 76, 81, 86, 91, 96,
      101,
    ],
  };

  // Check each tier
  for (const [tier, ids] of Object.entries(tierRanges)) {
    if (ids.includes(itemId)) {
      return tier;
    }
  }

  // Default if not found
  console.log(`[WARNING] Could not determine tier for item ID: ${itemId}`);
  return "Unknown";
}

// Function to get price based on tier and charisma
function getItemPrice(tier: string, charisma: number = 0): number {
  // Formula: 4 * (6 - tier_number) - charisma
  // With a minimum price of 1 gold
  const TIER_PRICE = 4; // Base multiplier
  const MIN_PRICE = 1; // Minimum item price

  let tierNumber = 0;
  switch (tier) {
    case "T1":
      tierNumber = 1;
      break;
    case "T2":
      tierNumber = 2;
      break;
    case "T3":
      tierNumber = 3;
      break;
    case "T4":
      tierNumber = 4;
      break;
    case "T5":
      tierNumber = 5;
      break;
    default:
      tierNumber = 0;
      break;
  }

  // Calculate price using the formula and apply minimum price
  const price = Math.max(TIER_PRICE * (6 - tierNumber) - charisma, MIN_PRICE);
  return price;
}

// Function to get potion price based on level and charisma
function getPotionPrice(level: number, charisma: number = 0): number {
  // Formula: level - (2 * charisma)
  // With a minimum price of 1 gold
  const MIN_PRICE = 1;
  const CHARISMA_DISCOUNT = 2;

  const price = Math.max(level - CHARISMA_DISCOUNT * charisma, MIN_PRICE);
  return price;
}

/**
 * Game constants for item greatness levels
 */
const SUFFIX_UNLOCK_GREATNESS = 15;
const PREFIXES_UNLOCK_GREATNESS = 19;

/**
 * Calculates item greatness level from XP value
 * Uses the same formula as adventurer level: sqrt(xp)
 * @param xp - The item's XP value
 */
function calculateGreatness(xp: number): number {
  return Math.floor(Math.sqrt(xp));
}

/**
 * Determines if an item has enough greatness to get a suffix
 * @param greatness - The item's greatness level
 */
function canHaveSuffix(greatness: number): boolean {
  return greatness >= SUFFIX_UNLOCK_GREATNESS;
}

/**
 * Determines if an item has enough greatness to get prefixes
 * @param greatness - The item's greatness level
 */
function canHavePrefixes(greatness: number): boolean {
  return greatness >= PREFIXES_UNLOCK_GREATNESS;
}

// Function to get item type from ID
function getItemType(itemId: number): string {
  // Based on ItemUtils in utils.cairo
  // Necklace: items 1-3 (Pendant, Necklace, Amulet)
  if (itemId >= 1 && itemId <= 3) {
    return "Necklace";
  }
  // Ring: items 4-8 (Silver Ring, Bronze Ring, Platinum Ring, Titanium Ring, Gold Ring)
  else if (itemId >= 4 && itemId <= 8) {
    return "Ring";
  }
  // Magic/Cloth: items 9-41
  // Ghost Wand through Gloves
  else if (itemId >= 9 && itemId <= 41) {
    return "Magic/Cloth";
  }
  // Blade/Hide: items 42-71
  // Katana through Leather Gloves
  else if (itemId >= 42 && itemId <= 71) {
    return "Blade/Hide";
  }
  // Bludgeon/Metal: items 72-101
  // Warhammer through Heavy Gloves
  else if (itemId >= 72 && itemId <= 101) {
    return "Bludgeon/Metal";
  }
  return "Unknown";
}

/**
 * Gets a formatted item name with special properties based on its greatness level
 * @param itemId - The base item ID
 * @param xp - The item's XP value
 * @param special1 - The item's suffix ID (e.g., "of Power")
 * @param special2 - The item's prefix1 ID (e.g., "Agony")
 * @param special3 - The item's prefix2 ID (e.g., "Bane")
 */
function getFullItemName(
  itemId: number,
  xp: number,
  special1?: string,
  special2?: string,
  special3?: string
): string {
  // Get the base item name
  const baseName = ITEM_NAMES[itemId - 1] || `Unknown (${itemId})`;

  // Get the item type
  const itemType = getItemType(itemId);

  // Calculate greatness level from XP
  const greatness = calculateGreatness(xp);

  // Start with the base name
  let fullName = baseName;

  // Add suffix if greatness is high enough
  if (canHaveSuffix(greatness) && special1 && parseInt(special1) > 0) {
    fullName += " " + getItemSuffix(special1);
  }

  // Add prefixes if greatness is high enough
  if (canHavePrefixes(greatness)) {
    // Add prefix1 (e.g., "Agony")
    if (special2 && parseInt(special2) > 0) {
      fullName = getPrefix1(special2) + " " + fullName;
    }

    // Add prefix2 (e.g., "Bane")
    if (special3 && parseInt(special3) > 0) {
      fullName += " " + getPrefix2(special3);
    }
  }

  // Add item type to the name
  fullName += ` [${itemType}]`;

  return fullName;
}

// Function to parse adventurer data from Starknet response
function parseAdventurerData(adventurerResult: any): {
  health: string;
  xp: string;
  gold: string;
  beast_health: string;
  stat_upgrades_available: string;
  stats: {
    strength: string;
    dexterity: string;
    vitality: string;
    intelligence: string;
    wisdom: string;
    charisma: string;
    luck: string;
  };
  equipment: {
    weapon: { id: string; xp: string };
    chest: { id: string; xp: string };
    head: { id: string; xp: string };
    waist: { id: string; xp: string };
    foot: { id: string; xp: string };
    hand: { id: string; xp: string };
    neck: { id: string; xp: string };
    ring: { id: string; xp: string };
  };
  battle_action_count: string;
} {
  if (!adventurerResult || !Array.isArray(adventurerResult)) {
    console.error(`[ERROR] Invalid adventurer data format:`, adventurerResult);
    return {
      health: "0",
      xp: "0",
      gold: "0",
      beast_health: "0",
      stat_upgrades_available: "0",
      stats: {
        strength: "0",
        dexterity: "0",
        vitality: "0",
        intelligence: "0",
        wisdom: "0",
        charisma: "0",
        luck: "0",
      },
      equipment: {
        weapon: { id: "0", xp: "0" },
        chest: { id: "0", xp: "0" },
        head: { id: "0", xp: "0" },
        waist: { id: "0", xp: "0" },
        foot: { id: "0", xp: "0" },
        hand: { id: "0", xp: "0" },
        neck: { id: "0", xp: "0" },
        ring: { id: "0", xp: "0" },
      },
      battle_action_count: "0",
    };
  }

  try {
    // Debug log the raw data to better understand it
    console.log(`[DEBUG] Parsing adventurer data with ${adventurerResult.length} fields:`, adventurerResult);

    // Based on the Adventurer struct in the contract
    const health = hexToDec(adventurerResult[0]);
    const xp = hexToDec(adventurerResult[1]);
    const gold = hexToDec(adventurerResult[2]);
    const beast_health = hexToDec(adventurerResult[3]);
    const stat_upgrades_available = hexToDec(adventurerResult[4]);

    // Stats struct (fields 5-11)
    const stats = {
      strength: hexToDec(adventurerResult[5]),
      dexterity: hexToDec(adventurerResult[6]),
      vitality: hexToDec(adventurerResult[7]),
      intelligence: hexToDec(adventurerResult[8]),
      wisdom: hexToDec(adventurerResult[9]),
      charisma: hexToDec(adventurerResult[10]),
      luck: hexToDec(adventurerResult[11]),
    };

    // Equipment struct - each item has an ID and XP
    // The structure follows the Equipment struct in the contract
    const equipment = {
      weapon: {
        id: hexToDec(adventurerResult[12]),
        xp: hexToDec(adventurerResult[13]),
      },
      chest: {
        id: hexToDec(adventurerResult[14]),
        xp: hexToDec(adventurerResult[15]),
      },
      head: {
        id: hexToDec(adventurerResult[16]),
        xp: hexToDec(adventurerResult[17]),
      },
      waist: {
        id: hexToDec(adventurerResult[18]),
        xp: hexToDec(adventurerResult[19]),
      },
      foot: {
        id: hexToDec(adventurerResult[20]),
        xp: hexToDec(adventurerResult[21]),
      },
      hand: {
        id: hexToDec(adventurerResult[22]),
        xp: hexToDec(adventurerResult[23]),
      },
      neck: {
        id: hexToDec(adventurerResult[24]),
        xp: hexToDec(adventurerResult[25]),
      },
      ring: {
        id: hexToDec(adventurerResult[26]),
        xp: hexToDec(adventurerResult[27]),
      },
    };

    // Battle action count
    const battle_action_count = adventurerResult.length > 28 ? hexToDec(adventurerResult[28]) : "0";

    // Debug log the parsed data
    console.log(`[DEBUG] Parsed adventurer data:`, {
      health,
      xp,
      gold,
      beast_health,
      stat_upgrades_available,
      stats,
      equipment,
      battle_action_count
    });

    return {
      health,
      xp,
      gold,
      beast_health,
      stat_upgrades_available,
      stats,
      equipment,
      battle_action_count,
    };
  } catch (error) {
    console.error(`[ERROR] Failed to parse adventurer data: ${error}`);
    console.error(`[ERROR] Raw data:`, adventurerResult);
    return {
      health: "0",
      xp: "0",
      gold: "0",
      beast_health: "0",
      stat_upgrades_available: "0",
      stats: {
        strength: "0",
        dexterity: "0",
        vitality: "0",
        intelligence: "0",
        wisdom: "0",
        charisma: "0",
        luck: "0",
      },
      equipment: {
        weapon: { id: "0", xp: "0" },
        chest: { id: "0", xp: "0" },
        head: { id: "0", xp: "0" },
        waist: { id: "0", xp: "0" },
        foot: { id: "0", xp: "0" },
        hand: { id: "0", xp: "0" },
        neck: { id: "0", xp: "0" },
        ring: { id: "0", xp: "0" },
      },
      battle_action_count: "0",
    };
  }
}

// Function to parse beast data from Starknet response
function parseBeastData(beastResult: any): {
  id: string;
  starting_health: string;
  combat_spec: {
    tier: string;
    item_type: string;
    level: string;
    specials: {
      special1: string;
      special2: string;
      special3: string;
    };
  };
} {
  if (!beastResult || !Array.isArray(beastResult)) {
    return {
      id: "0",
      starting_health: "0",
      combat_spec: {
        tier: "0",
        item_type: "0",
        level: "0",
        specials: {
          special1: "0",
          special2: "0",
          special3: "0",
        },
      },
    };
  }

  try {
    // Beast struct has:
    // 1. id (u8)
    // 2. starting_health (u16)
    // 3. combat_spec (CombatSpec)
    //    - tier (Tier)
    //    - item_type (Type)
    //    - level (u16)
    //    - specials (SpecialPowers)
    //      - special1, special2, special3 (u8)

    const id = hexToDec(beastResult[0]);
    const starting_health = hexToDec(beastResult[1]);

    // CombatSpec structure
    const tier = hexToDec(beastResult[2]);
    const item_type = hexToDec(beastResult[3]);
    const level = hexToDec(beastResult[4]);

    // Specials sub-structure
    const special1 = hexToDec(beastResult[5]);
    const special2 = hexToDec(beastResult[6]);
    const special3 = hexToDec(beastResult[7]);

    return {
      id,
      starting_health,
      combat_spec: {
        tier,
        item_type,
        level,
        specials: {
          special1,
          special2,
          special3,
        },
      },
    };
  } catch (error) {
    console.error(`[ERROR] Failed to parse beast data: ${error}`);
    return {
      id: "0",
      starting_health: "0",
      combat_spec: {
        tier: "0",
        item_type: "0",
        level: "0",
        specials: {
          special1: "0",
          special2: "0",
          special3: "0",
        },
      },
    };
  }
}

// Function to map beast type to readable string
function getBeastType(typeId: string): string {
  const types: { [key: string]: string } = {
    "0": "None",
    "1": "Magic/Cloth",
    "2": "Blade/Hide",
    "3": "Bludgeon/Metal",
    "4": "Necklace",
    "5": "Ring",
  };
  return types[typeId] || `Type ${typeId}`;
}

// Function to map beast tier to readable string
function getBeastTier(tierId: string): string {
  const tiers: { [key: string]: string } = {
    "0": "None",
    "1": "T1",
    "2": "T2",
    "3": "T3",
    "4": "T4",
    "5": "T5",
  };
  return tiers[tierId] || `Tier ${tierId}`;
}

// Function to map beast ID to proper name
function getBeastName(beastId: string): string {
  const beastNames: { [key: string]: string } = {
    "0": "None",
    "1": "Warlock",
    "2": "Typhon",
    "3": "Jiangshi",
    "4": "Anansi",
    "5": "Basilisk",
    "6": "Gorgon",
    "7": "Kitsune",
    "8": "Lich",
    "9": "Chimera",
    "10": "Wendigo",
    "11": "Rakshasa",
    "12": "Werewolf",
    "13": "Banshee",
    "14": "Draugr",
    "15": "Vampire",
    "16": "Goblin",
    "17": "Ghoul",
    "18": "Wraith",
    "19": "Sprite",
    "20": "Kappa",
    "21": "Fairy",
    "22": "Leprechaun",
    "23": "Kelpie",
    "24": "Pixie",
    "25": "Gnome",
    "26": "Griffin",
    "27": "Manticore",
    "28": "Phoenix",
    "29": "Dragon",
    "30": "Minotaur",
    "31": "Qilin",
    "32": "Ammit",
    "33": "Nue",
    "34": "Skinwalker",
    "35": "Chupacabra",
    "36": "Weretiger",
    "37": "Wyvern",
    "38": "Roc",
    "39": "Harpy",
    "40": "Pegasus",
    "41": "Hippogriff",
    "42": "Fenrir",
    "43": "Jaguar",
    "44": "Satori",
    "45": "Dire Wolf",
    "46": "Bear",
    "47": "Wolf",
    "48": "Mantis",
    "49": "Spider",
    "50": "Rat",
    "51": "Kraken",
    "52": "Colossus",
    "53": "Balrog",
    "54": "Leviathan",
    "55": "Tarrasque",
    "56": "Titan",
    "57": "Nephilim",
    "58": "Behemoth",
    "59": "Hydra",
    "60": "Juggernaut",
    "61": "Oni",
    "62": "Jotunn",
    "63": "Ettin",
    "64": "Cyclops",
    "65": "Giant",
    "66": "Nemean Lion",
    "67": "Berserker",
    "68": "Yeti",
    "69": "Golem",
    "70": "Ent",
    "71": "Troll",
    "72": "Bigfoot",
    "73": "Ogre",
    "74": "Orc",
    "75": "Skeleton",
  };
  return beastNames[beastId] || `Beast #${beastId}`;
}

async function getAdventurerState(
  contractAddress: string,
  adventurerId: string
): Promise<LootSurvivorState | null> {
  try {
    console.log(
      `[STARKNET] Calling get_adventurer function for ID: ${adventurerId}`
    );

    const adventurerResult = await starknet.read({
      contractAddress,
      entrypoint: "get_adventurer",
      calldata: [adventurerId],
    });

    console.log(
      `[STARKNET] Raw adventurer result:`,
      JSON.stringify(adventurerResult)
    );

    if (!adventurerResult || adventurerResult.message) {
      console.error(
        `[ERROR] Failed to get adventurer: ${adventurerResult?.message || "Unknown error"}`
      );
      return null;
    }

    // Parse adventurer data
    const adventurerData = parseAdventurerData(
      adventurerResult.result || adventurerResult
    );

    console.log(`[DEBUG] Adventurer data after parsing:`, adventurerData);

    // Calculate level
    const xpNumber = parseInt(adventurerData.xp);
    const level = Math.floor(Math.sqrt(xpNumber));

    // Check if in battle
    const inBattle = parseInt(adventurerData.beast_health) > 0;

    // Map item IDs to names
    const getItemName = (
      item: { id: string; xp: string },
      special1?: string,
      special2?: string,
      special3?: string
    ): string => {
      const itemId = parseInt(item.id);
      if (itemId <= 0) {
        return "None";
      }

      // Get XP value
      const xp = item.xp ? parseInt(item.xp) : 0;

      // Use our helper function to get the full name with special properties
      return getFullItemName(itemId, xp, special1, special2, special3);
    };

    // Calculate max health based on game constants
    const baseHealth = 100; // STARTING_HEALTH from constants
    const vitalityBonus = parseInt(adventurerData.stats.vitality) * 15; // HEALTH_INCREASE_PER_VITALITY is 15
    const maxHealth = Math.min(baseHealth + vitalityBonus, 1023); // MAX_ADVENTURER_HEALTH is 1023

    // Create state object
    const state: LootSurvivorState = {
      adventurerId,
      adventurerHealth: adventurerData.health,
      adventurerMaxHealth: maxHealth.toString(), // Correctly calculated max health
      level: level.toString(),
      xp: adventurerData.xp,
      gold: adventurerData.gold,
      statUpgrades: adventurerData.stat_upgrades_available,

      // Stats
      strength: adventurerData.stats.strength,
      dexterity: adventurerData.stats.dexterity,
      vitality: adventurerData.stats.vitality,
      intelligence: adventurerData.stats.intelligence,
      wisdom: adventurerData.stats.wisdom,
      charisma: adventurerData.stats.charisma,
      luck: adventurerData.stats.luck,

      // Equipment
      weapon: getItemName(
        adventurerData.equipment.weapon,
        adventurerData.equipment.weapon.xp &&
          parseInt(adventurerData.equipment.weapon.xp) >= 15
          ? "1"
          : undefined,
        adventurerData.equipment.weapon.xp &&
          parseInt(adventurerData.equipment.weapon.xp) >= 19
          ? "1"
          : undefined,
        adventurerData.equipment.weapon.xp &&
          parseInt(adventurerData.equipment.weapon.xp) >= 19
          ? "1"
          : undefined
      ),
      chest: getItemName(
        adventurerData.equipment.chest,
        adventurerData.equipment.chest.xp &&
          parseInt(adventurerData.equipment.chest.xp) >= 15
          ? "1"
          : undefined,
        adventurerData.equipment.chest.xp &&
          parseInt(adventurerData.equipment.chest.xp) >= 19
          ? "1"
          : undefined,
        adventurerData.equipment.chest.xp &&
          parseInt(adventurerData.equipment.chest.xp) >= 19
          ? "1"
          : undefined
      ),
      head: getItemName(
        adventurerData.equipment.head,
        adventurerData.equipment.head.xp &&
          parseInt(adventurerData.equipment.head.xp) >= 15
          ? "1"
          : undefined,
        adventurerData.equipment.head.xp &&
          parseInt(adventurerData.equipment.head.xp) >= 19
          ? "1"
          : undefined,
        adventurerData.equipment.head.xp &&
          parseInt(adventurerData.equipment.head.xp) >= 19
          ? "1"
          : undefined
      ),
      waist: getItemName(
        adventurerData.equipment.waist,
        adventurerData.equipment.waist.xp &&
          parseInt(adventurerData.equipment.waist.xp) >= 15
          ? "1"
          : undefined,
        adventurerData.equipment.waist.xp &&
          parseInt(adventurerData.equipment.waist.xp) >= 19
          ? "1"
          : undefined,
        adventurerData.equipment.waist.xp &&
          parseInt(adventurerData.equipment.waist.xp) >= 19
          ? "1"
          : undefined
      ),
      foot: getItemName(
        adventurerData.equipment.foot,
        adventurerData.equipment.foot.xp &&
          parseInt(adventurerData.equipment.foot.xp) >= 15
          ? "1"
          : undefined,
        adventurerData.equipment.foot.xp &&
          parseInt(adventurerData.equipment.foot.xp) >= 19
          ? "1"
          : undefined,
        adventurerData.equipment.foot.xp &&
          parseInt(adventurerData.equipment.foot.xp) >= 19
          ? "1"
          : undefined
      ),
      hand: getItemName(
        adventurerData.equipment.hand,
        adventurerData.equipment.hand.xp &&
          parseInt(adventurerData.equipment.hand.xp) >= 15
          ? "1"
          : undefined,
        adventurerData.equipment.hand.xp &&
          parseInt(adventurerData.equipment.hand.xp) >= 19
          ? "1"
          : undefined,
        adventurerData.equipment.hand.xp &&
          parseInt(adventurerData.equipment.hand.xp) >= 19
          ? "1"
          : undefined
      ),
      neck: getItemName(
        adventurerData.equipment.neck,
        adventurerData.equipment.neck.xp &&
          parseInt(adventurerData.equipment.neck.xp) >= 15
          ? "1"
          : undefined,
        adventurerData.equipment.neck.xp &&
          parseInt(adventurerData.equipment.neck.xp) >= 19
          ? "1"
          : undefined,
        adventurerData.equipment.neck.xp &&
          parseInt(adventurerData.equipment.neck.xp) >= 19
          ? "1"
          : undefined
      ),
      ring: getItemName(
        adventurerData.equipment.ring,
        adventurerData.equipment.ring.xp &&
          parseInt(adventurerData.equipment.ring.xp) >= 15
          ? "1"
          : undefined,
        adventurerData.equipment.ring.xp &&
          parseInt(adventurerData.equipment.ring.xp) >= 19
          ? "1"
          : undefined,
        adventurerData.equipment.ring.xp &&
          parseInt(adventurerData.equipment.ring.xp) >= 19
          ? "1"
          : undefined
      ),

      // Equipment XP (greatness levels)
      weaponXP: adventurerData.equipment.weapon.xp,
      chestXP: adventurerData.equipment.chest.xp,
      headXP: adventurerData.equipment.head.xp,
      waistXP: adventurerData.equipment.waist.xp,
      footXP: adventurerData.equipment.foot.xp,
      handXP: adventurerData.equipment.hand.xp,
      neckXP: adventurerData.equipment.neck.xp,
      ringXP: adventurerData.equipment.ring.xp,

      // Beast info
      currentBeast: "None",
      beastHealth: adventurerData.beast_health,
      beastMaxHealth: "0",
      beastLevel: "0",
      beastTier: "0",
      beastType: "0",
      beastSpecial1: "None",
      beastSpecial2: "None",
      beastSpecial3: "None",

      // Battle state
      inBattle: inBattle ? "true" : "false",
      lastAction: "None",
      lastDamageDealt: "0",
      lastDamageTaken: "0",
      lastCritical: "false",
      battleActionCount: adventurerData.battle_action_count,

      // Bag/Inventory
      bagItems: [],

      // Market - Initialize as empty array
      marketItems: [],
    };

    console.log(`[DEBUG] Created initial state:`, {
      adventurerId: state.adventurerId,
      health: state.adventurerHealth,
      maxHealth: state.adventurerMaxHealth,
      level: state.level,
      xp: state.xp,
      gold: state.gold,
      inBattle: state.inBattle,
      stats: {
        strength: state.strength,
        dexterity: state.dexterity,
        vitality: state.vitality,
        intelligence: state.intelligence,
        wisdom: state.wisdom,
        charisma: state.charisma,
        luck: state.luck,
      },
      upgrades: state.statUpgrades,
    });

    // If in battle, get beast details
    if (inBattle) {
      try {
        console.log(`[STARKNET] Calling get_attacking_beast function`);
        const beastResult = await starknet.read({
          contractAddress: GAME_CONTRACT_ADDRESS,
          entrypoint: "get_attacking_beast",
          calldata: [adventurerId],
        });

        console.log(
          `[STARKNET] Raw beast result:`,
          JSON.stringify(beastResult)
        );

        if (beastResult && !beastResult.message) {
          const beastData = parseBeastData(beastResult.result || beastResult);

          state.currentBeast = getBeastName(beastData.id);
          state.beastMaxHealth = beastData.starting_health;
          state.beastLevel = beastData.combat_spec.level;
          state.beastTier = getBeastTier(beastData.combat_spec.tier);
          state.beastType = getBeastType(beastData.combat_spec.item_type);

          // Get formatted special properties for display
          const special1 = beastData.combat_spec.specials.special1;
          const special2 = beastData.combat_spec.specials.special2;
          const special3 = beastData.combat_spec.specials.special3;

          // Format special1 (item suffix like "of Power")
          state.beastSpecial1 =
            parseInt(special1) > 0 ? getItemSuffix(special1) : "None";

          // Format special2 (prefix1 like "Agony")
          state.beastSpecial2 =
            parseInt(special2) > 0 ? getPrefix1(special2) : "None";

          // Format special3 (prefix2 like "Bane")
          state.beastSpecial3 =
            parseInt(special3) > 0 ? getPrefix2(special3) : "None";
        }
      } catch (beastError) {
        console.log(
          `[STARKNET] Could not retrieve beast details: ${beastError}`
        );
      }
    }

    // Try to get bag items
    try {
      console.log(`[STARKNET] Calling get_bag function`);
      const bagResult = await starknet.read({
        contractAddress,
        entrypoint: "get_bag",
        calldata: [adventurerId],
      });

      console.log(`[STARKNET] Raw bag result:`, JSON.stringify(bagResult));

      if (bagResult && !bagResult.message && (bagResult.result || bagResult)) {
        const rawBag = bagResult.result || bagResult;
        state.bagItems = [];

        // The bag in the contract is a struct with 15 items
        // Each item has id and xp fields
        for (let i = 0; i < 15; i++) {
          // In the array response, items are consecutive
          // item1.id, item1.xp, item2.id, item2.xp, ...
          const itemIdIndex = i * 2; // ID at even indices
          const itemXpIndex = i * 2 + 1; // XP at odd indices

          if (itemIdIndex < rawBag.length && rawBag[itemIdIndex] !== "0x0") {
            const itemId = hexToDec(rawBag[itemIdIndex]);
            if (itemId !== "0") {
              const itemName = getItemName({ id: itemId.toString(), xp: "0" });
              state.bagItems.push(itemName);
            }
          }
        }
      }
    } catch (bagError) {
      console.log(`[STARKNET] Could not retrieve bag items: ${bagError}`);
      // Initialize empty bag array if we couldn't fetch it
      state.bagItems = [];
    }

    // Always try to get market items, especially if there are stat upgrades available
    try {
      console.log(`[STARKNET] Calling get_market function`);
      const marketResult = await starknet.read({
        contractAddress: GAME_CONTRACT_ADDRESS,
        entrypoint: "get_market",
        calldata: [adventurerId],
      });

      console.log(
        `[STARKNET] Raw market result:`,
        JSON.stringify(marketResult)
      );

      if (
        marketResult &&
        !marketResult.message &&
        (marketResult.result || marketResult)
      ) {
        const rawMarket = marketResult.result || marketResult;
        state.marketItems = [];

        // Log the raw market for further debugging
        console.log(
          `[MARKET] Raw market data (${rawMarket.length} items):`,
          rawMarket
        );

        // Process each market item ID
        // The data appears to be a flattened array of item IDs
        for (let i = 0; i < rawMarket.length; i++) {
          const itemId = hexToDec(rawMarket[i]);
          if (itemId !== "0") {
            const itemName = getItemName({ id: itemId.toString(), xp: "0" });
            const tier = getItemTier(parseInt(itemId));
            // Apply charisma discount to price
            const price = getItemPrice(
              tier,
              parseInt(adventurerData.stats.charisma)
            );

            state.marketItems.push({
              id: itemId.toString(),
              name: itemName,
              price: price.toString(),
            });

            // Debug log
            console.log(
              `[MARKET] Added item: ${itemName} (ID: ${itemId}, Tier: ${tier}, Price: ${price} gold, with CHA discount)`
            );
          }
        }

        // Log total market items
        console.log(
          `[MARKET] Total items available: ${state.marketItems.length}`
        );
      } else {
        // Initialize as empty array if market fetch failed
        state.marketItems = [];
        console.log(
          `[MARKET] Could not retrieve market items or market is not available yet.`
        );
      }
    } catch (marketError) {
      console.log(`[STARKNET] Could not retrieve market items: ${marketError}`);
      // Initialize as empty array if we couldn't fetch it
      state.marketItems = [];
    }

    // Log the final complete state for debugging
    console.log(`[DEBUG] Final complete state created for adventurer ${adventurerId}`);
    // Print the complete state to the console
    printGameState(state);

    return state;
  } catch (error) {
    console.error(`[ERROR] Failed to get adventurer state: ${error}`);
    return null;
  }
}

// Function to print the current game state to console
function printGameState(state: LootSurvivorState) {
  console.log("\n=== GAME STATE ===");
  console.log(
    `Adventurer: ID ${state.adventurerId} | Health: ${state.adventurerHealth}/${state.adventurerMaxHealth}`
  );
  console.log(`Level: ${state.level} | XP: ${state.xp} | Gold: ${state.gold}`);
  console.log(`Battle Actions: ${state.battleActionCount}`);

  console.log("\n=== STATS ===");
  console.log(
    `STR: ${state.strength} | DEX: ${state.dexterity} | VIT: ${state.vitality}`
  );
  console.log(
    `INT: ${state.intelligence} | WIS: ${state.wisdom} | CHA: ${state.charisma} | LCK: ${state.luck}`
  );
  console.log(`Available Upgrades: ${state.statUpgrades}`);

  console.log("\n=== EQUIPMENT ===");
  console.log(
    `Weapon: ${state.weapon}${state.weaponXP ? ` (Greatness: ${calculateGreatness(parseInt(state.weaponXP))}, XP: ${state.weaponXP})` : ""}`
  );
  console.log(
    `Chest: ${state.chest}${state.chestXP ? ` (Greatness: ${calculateGreatness(parseInt(state.chestXP))}, XP: ${state.chestXP})` : ""}`
  );
  console.log(
    `Head: ${state.head}${state.headXP ? ` (Greatness: ${calculateGreatness(parseInt(state.headXP))}, XP: ${state.headXP})` : ""}`
  );
  console.log(
    `Waist: ${state.waist}${state.waistXP ? ` (Greatness: ${calculateGreatness(parseInt(state.waistXP))}, XP: ${state.waistXP})` : ""}`
  );
  console.log(
    `Foot: ${state.foot}${state.footXP ? ` (Greatness: ${calculateGreatness(parseInt(state.footXP))}, XP: ${state.footXP})` : ""}`
  );
  console.log(
    `Hand: ${state.hand}${state.handXP ? ` (Greatness: ${calculateGreatness(parseInt(state.handXP))}, XP: ${state.handXP})` : ""}`
  );
  console.log(
    `Neck: ${state.neck}${state.neckXP ? ` (Greatness: ${calculateGreatness(parseInt(state.neckXP))}, XP: ${state.neckXP})` : ""}`
  );
  console.log(
    `Ring: ${state.ring}${state.ringXP ? ` (Greatness: ${calculateGreatness(parseInt(state.ringXP))}, XP: ${state.ringXP})` : ""}`
  );

  if (state.inBattle === "true") {
    console.log("\n=== BATTLE ===");
    console.log(`Beast: ${state.currentBeast} (Level ${state.beastLevel})`);
    console.log(`Beast Health: ${state.beastHealth}/${state.beastMaxHealth}`);
    console.log(`Beast Tier: ${state.beastTier} | Type: ${state.beastType}`);
    console.log(
      `Specials: ${state.beastSpecial1}, ${state.beastSpecial2}, ${state.beastSpecial3}`
    );
  }

  console.log("\n=== INVENTORY ===");
  console.log(
    `Bag Items: ${state.bagItems.length > 0 ? state.bagItems.join(", ") : "None"}`
  );

  console.log("\n=== MARKET ===");
  // Show potion price first
  const potionPrice = getPotionPrice(
    parseInt(state.level),
    parseInt(state.charisma)
  );
  console.log(`Potion: ${potionPrice} gold (Restores 10 HP)`);

  // Show items grouped by tier
  if (state.marketItems.length > 0) {
    console.log("Available Items:");
    // Group items by tier for better organization
    const itemsByTier: {
      [key: string]: Array<{ name: string; price: string }>;
    } = {};

    state.marketItems.forEach((item) => {
      const tier = getItemTier(parseInt(item.id));
      if (!itemsByTier[tier]) {
        itemsByTier[tier] = [];
      }
      itemsByTier[tier].push({ name: item.name, price: item.price });
    });

    // Display by tier (lowest price first)
    const tierOrder = ["T5", "T4", "T3", "T2", "T1"];

    tierOrder.forEach((tier) => {
      if (itemsByTier[tier] && itemsByTier[tier].length > 0) {
        console.log(`  [${tier}]`);
        itemsByTier[tier].forEach((item) => {
          console.log(`  - ${item.name} (${item.price} gold)`);
        });
      }
    });
  } else {
    console.log("Available Items: None");
  }

  console.log("\n=== LAST ACTION ===");
  console.log(
    `${state.lastAction} | Damage Dealt: ${state.lastDamageDealt} | Damage Taken: ${state.lastDamageTaken}`
  );
  console.log(`Critical Hit: ${state.lastCritical}`);
  console.log("===================\n");
}

// Function to generate a formatted state summary for the agent
function generateStateSummary(state: LootSurvivorState): string {
  return `
Current Adventurer State:
- ID: ${state.adventurerId}
- Health: ${state.adventurerHealth}/${state.adventurerMaxHealth}
- Level: ${state.level} (XP: ${state.xp})
- Gold: ${state.gold}
- In Battle: ${state.inBattle === "true" ? "Yes" : "No"}
${state.inBattle === "true" ? `- Fighting: ${state.currentBeast} (Level ${state.beastLevel})
- Beast Health: ${state.beastHealth}/${state.beastMaxHealth}
- Beast Type: ${state.beastType}` : ''}

Stats:
- Strength: ${state.strength}
- Dexterity: ${state.dexterity}
- Vitality: ${state.vitality}
- Intelligence: ${state.intelligence}
- Wisdom: ${state.wisdom}
- Charisma: ${state.charisma}
- Luck: ${state.luck}
- Available Stat Upgrades: ${state.statUpgrades}

Equipment:
- Weapon: ${state.weapon}
- Chest: ${state.chest}
- Head: ${state.head}
- Waist: ${state.waist}
- Foot: ${state.foot}
- Hand: ${state.hand}
- Neck: ${state.neck}
- Ring: ${state.ring}

Inventory:
- Bag Items: ${Array.isArray(state.bagItems) && state.bagItems.length > 0 ? state.bagItems.join(", ") : "None"}

Market:
- Available Items: ${Array.isArray(state.marketItems) && state.marketItems.length > 0
      ? state.marketItems.map(item => `${item.name} (${item.price} gold)`).join(", ")
      : "None"}

Last Action: ${state.lastAction}
`;
}

// Fix the initializeLootSurvivorMemory function to properly initialize marketItems
export function initializeLootSurvivorMemory(ctx: any): LootSurvivorState {
  if (!ctx.agentMemory) {
    ctx.agentMemory = {
      adventurerId: "0",
      adventurerHealth: "0",
      adventurerMaxHealth: "100", // Update to default base health
      level: "1",
      xp: "0",
      gold: "0",
      statUpgrades: "0",

      strength: "0",
      dexterity: "0",
      vitality: "0",
      intelligence: "0",
      wisdom: "0",
      charisma: "0",
      luck: "0",

      weapon: "None",
      chest: "None",
      head: "None",
      waist: "None",
      foot: "None",
      hand: "None",
      neck: "None",
      ring: "None",

      // Initialize equipment XP fields
      weaponXP: "0",
      chestXP: "0",
      headXP: "0",
      waistXP: "0",
      footXP: "0",
      handXP: "0",
      neckXP: "0",
      ringXP: "0",

      currentBeast: "None",
      beastHealth: "0",
      beastMaxHealth: "0",
      beastLevel: "0",
      beastTier: "0",
      beastType: "0",
      beastSpecial1: "None",
      beastSpecial2: "None",
      beastSpecial3: "None",

      inBattle: "false",
      lastAction: "None",
      lastDamageDealt: "0",
      lastDamageTaken: "0",
      lastCritical: "false",
      battleActionCount: "0",

      bagItems: [],
      marketItems: [], // Ensure this is always initialized as an empty array
    };
  } else {
    // Ensure critical fields are always initialized
    ctx.agentMemory.bagItems = ctx.agentMemory.bagItems || [];
    ctx.agentMemory.marketItems = ctx.agentMemory.marketItems || [];
  }
  return ctx.agentMemory as LootSurvivorState;
}

// Create a centralized game state manager
const gameStateManager = {
  // Current state cache
  currentState: null as LootSurvivorState | null,

  // Last fetch timestamp to avoid excessive refetching
  lastFetchTime: 0,

  // Minimum time between state refreshes (in milliseconds)
  minRefreshInterval: 1000,

  // Initialize state for a given adventurer ID
  async initialize(adventurerId: string): Promise<LootSurvivorState | null> {
    console.log(`[STATE_MANAGER] Initializing state for adventurer: ${adventurerId}`);
    this.currentState = await this._fetchLatestState(adventurerId);
    return this.currentState;
  },

  // Get current state, refreshing if necessary
  async getState(adventurerId: string, forceRefresh = false): Promise<LootSurvivorState | null> {
    const now = Date.now();

    // Check if we need to fetch a fresh state
    if (
      forceRefresh ||
      !this.currentState ||
      this.currentState.adventurerId !== adventurerId ||
      now - this.lastFetchTime > this.minRefreshInterval
    ) {
      console.log(`[STATE_MANAGER] Fetching fresh state for adventurer: ${adventurerId}`);
      this.currentState = await this._fetchLatestState(adventurerId);
      this.lastFetchTime = now;
    }

    return this.currentState;
  },

  // Update state after an action
  async updateAfterAction(
    adventurerId: string,
    actionName: string,
    txHash?: string
  ): Promise<LootSurvivorState | null> {
    // No need to manually wait for transaction confirmation
    // starknet.write() already includes waitForTransaction

    // Always fetch fresh state after an action
    console.log(`[STATE_MANAGER] Updating state after ${actionName}`);
    this.currentState = await this._fetchLatestState(adventurerId);
    this.lastFetchTime = Date.now();

    if (this.currentState) {
      // Update last action if not already set
      if (actionName && this.currentState.lastAction === "None") {
        console.log(`[STATE_MANAGER] Setting last action to: ${actionName}`);
        this.currentState.lastAction = actionName;
      }

      // Print the state for debugging too
      console.log(`[STATE_MANAGER] Updated state details:`, {
        adventurerId: this.currentState.adventurerId,
        health: this.currentState.adventurerHealth,
        maxHealth: this.currentState.adventurerMaxHealth,
        level: this.currentState.level,
        xp: this.currentState.xp,
        gold: this.currentState.gold,
        inBattle: this.currentState.inBattle,
        lastAction: this.currentState.lastAction
      });
    }

    return this.currentState;
  },

  // Apply state to agent memory context
  applyToMemory(ctx: any): LootSurvivorState {
    // Initialize memory first
    const memoryState = initializeLootSurvivorMemory(ctx);

    // Then apply current state if available
    if (this.currentState) {
      // Create a deep copy of important objects to avoid reference issues
      const stateCopy = { ...this.currentState };

      // Copy arrays to avoid reference issues
      if (Array.isArray(this.currentState.bagItems)) {
        stateCopy.bagItems = [...this.currentState.bagItems];
      }

      if (Array.isArray(this.currentState.marketItems)) {
        stateCopy.marketItems = this.currentState.marketItems.map(item => ({ ...item }));
      }

      // Apply the copied state to memory
      Object.assign(memoryState, stateCopy);

      console.log(`[STATE_MANAGER] Applied state to agent memory for adventurer: ${this.currentState.adventurerId}`);
      console.log(`[STATE_MANAGER] Memory state now has:`, {
        adventurerId: memoryState.adventurerId,
        health: memoryState.adventurerHealth,
        maxHealth: memoryState.adventurerMaxHealth,
        level: memoryState.level,
        gold: memoryState.gold,
        inBattle: memoryState.inBattle,
        stats: {
          strength: memoryState.strength,
          dexterity: memoryState.dexterity,
          vitality: memoryState.vitality,
          intelligence: memoryState.intelligence,
          wisdom: memoryState.wisdom,
          charisma: memoryState.charisma,
          luck: memoryState.luck,
        },
        bagItems: Array.isArray(memoryState.bagItems) ? memoryState.bagItems.length : 0,
        marketItems: Array.isArray(memoryState.marketItems) ? memoryState.marketItems.length : 0,
      });
    } else {
      console.warn(`[STATE_MANAGER] No current state to apply to memory`);
    }

    return memoryState;
  },

  // Private method to fetch the latest state
  async _fetchLatestState(adventurerId: string): Promise<LootSurvivorState | null> {
    const state = await getAdventurerState(GAME_CONTRACT_ADDRESS, adventurerId);
    if (!state) {
      console.error(`[STATE_MANAGER] Failed to fetch state for adventurer: ${adventurerId}`);
    }
    return state;
  }
};

// Define item names array based on the ItemString module in constants.cairo
// Items are 1-indexed in the contract, so we'll match that here
const ITEM_NAMES = [
  "Pendant",
  "Necklace",
  "Amulet",
  "Silver Ring",
  "Bronze Ring",
  "Platinum Ring",
  "Titanium Ring",
  "Gold Ring",
  "Ghost Wand",
  "Grave Wand",
  "Bone Wand",
  "Wand",
  "Grimoire",
  "Chronicle",
  "Tome",
  "Book",
  "Divine Robe",
  "Silk Robe",
  "Linen Robe",
  "Robe",
  "Shirt",
  "Crown",
  "Divine Hood",
  "Silk Hood",
  "Linen Hood",
  "Hood",
  "Brightsilk Sash",
  "Silk Sash",
  "Wool Sash",
  "Linen Sash",
  "Sash",
  "Divine Slippers",
  "Silk Slippers",
  "Wool Shoes",
  "Linen Shoes",
  "Shoes",
  "Divine Gloves",
  "Silk Gloves",
  "Wool Gloves",
  "Linen Gloves",
  "Gloves",
  "Katana",
  "Falchion",
  "Scimitar",
  "Long Sword",
  "Short Sword",
  "Demon Husk",
  "Dragonskin Armor",
  "Studded Leather Armor",
  "Hard Leather Armor",
  "Leather Armor",
  "Demon Crown",
  "Dragon's Crown",
  "War Cap",
  "Leather Cap",
  "Cap",
  "Demonhide Belt",
  "Dragonskin Belt",
  "Studded Leather Belt",
  "Hard Leather Belt",
  "Leather Belt",
  "Demonhide Boots",
  "Dragonskin Boots",
  "Studded Leather Boots",
  "Hard Leather Boots",
  "Leather Boots",
  "Demon's Hands",
  "Dragonskin Gloves",
  "Studded Leather Gloves",
  "Hard Leather Gloves",
  "Leather Gloves",
  "Warhammer",
  "Quarterstaff",
  "Maul",
  "Mace",
  "Club",
  "Holy Chestplate",
  "Ornate Chestplate",
  "Plate Mail",
  "Chain Mail",
  "Ring Mail",
  "Ancient Helm",
  "Ornate Helm",
  "Great Helm",
  "Full Helm",
  "Helm",
  "Ornate Belt",
  "War Belt",
  "Plated Belt",
  "Mesh Belt",
  "Heavy Belt",
  "Holy Greaves",
  "Ornate Greaves",
  "Greaves",
  "Chain Boots",
  "Heavy Boots",
  "Holy Gauntlets",
  "Ornate Gauntlets",
  "Gauntlets",
  "Chain Gloves",
  "Heavy Gloves",
];

// Template for the agent's context
export const template = `
You are an expert AI agent playing Loot Survivor, a roguelike dungeon crawler game on Starknet blockchain. Your goal is to progress as far as possible, defeat beasts, collect loot, and upgrade your character to become stronger.

CRITICAL RULES - YOU MUST FOLLOW THESE EXACTLY:
1. If stat_upgrades_available > 0, you MUST use upgradeAdventurer to allocate ALL stat points BEFORE doing anything else.
2. When stat upgrades are available, the market is also available - you can buy items and potions.
3. You CANNOT explore if stat_upgrades_available > 0 - the game mechanics prevent this.
4. If in battle (inBattle = true), you MUST resolve it (attack or flee) before doing any other action.

Game Overview:
- Roguelike dungeon crawler with permadeath (once you die, you need to start over)
- Turn-based combat system with elemental effectiveness mechanics
- Character progression through XP, level-ups, and equipment upgrades
- Resource management (health, gold, items)
- Battle increasingly difficult beasts
- Collect gold and items
- Level up your character
- Manage health and resources
- Make strategic combat decisions
- Track XP for level-up timing

IMPORTANT RULES:
- If stat_upgrades_available is non-zero, you MUST allocate those stat points before exploring
- You can only upgrade stats if you have available stat points (1 point = 1 stat upgrade)
- When stat points are available, the market is also available for purchases
- If in battle, you MUST resolve the battle (attack or flee) before doing anything else
- When confused or stuck, check: Are you in battle? Do you have available stat points?

Combat Mechanics:
- Weapon types: Blade, Bludgeon, and Magic
- Armor materials: Cloth, Hide, and Metal
- Weapon effectiveness:
  - Blade: Weak vs Metal, Fair vs Hide, Strong vs Cloth
  - Bludgeon: Fair vs Metal, Strong vs Hide, Weak vs Cloth
  - Magic: Strong vs Metal, Weak vs Hide, Fair vs Cloth
- Stats affect combat: Strength boosts damage, Vitality increases health, etc.
- Combat calculations:
  - Base damage = Item Greatness * (6 - Tier)
  - Beast damage = Beast Level * (6 - Beast Tier)
  - Final damage = Weapon power - Armor defense
- Critical hits chance = luck / 100
- Critical damage bonus = random(20-100%)

Beast Types:
- Magical Beasts: Weak to Blade weapons, Strong against Metal armor
- Hunter Beasts: Weak to Bludgeon weapons, Strong against Cloth armor
- Brute Beasts: Weak to Magic weapons, Strong against Hide armor
- Beast Tiers affect power: Tier 1 (highest) to Tier 5 (lowest)

Resource Management:
- HP management is critical for survival
- XP gained through successful actions
- Gold for purchasing items and potions
- Potion cost = adventurer_level - (2 * charisma)
- Each potion adds 10HP

Stats System:
- Strength: +10% attack damage
- Vitality: +15HP max and current health
- Dexterity: Better flee chances
- Intelligence: Better obstacle avoidance
- Wisdom: Better ambush evasion
- Charisma: Item/potion discount
- Luck: Critical hit chance (only from items)

Current Game State:
<adventurer_stats>
Adventurer ID: {{adventurerId}}
Health: {{adventurerHealth}}/{{adventurerMaxHealth}}
Level: {{level}}
XP: {{xp}}
Gold: {{gold}}
Battle Actions: {{battleActionCount}}
</adventurer_stats>

<adventurer_attributes>
Strength: {{strength}}
Dexterity: {{dexterity}}
Vitality: {{vitality}}
Intelligence: {{intelligence}}
Wisdom: {{wisdom}}
Charisma: {{charisma}}
Luck: {{luck}}
Available Stat Upgrades: {{statUpgrades}}
</adventurer_attributes>

<equipment>
Weapon: {{weapon}}
Chest: {{chest}}
Head: {{head}}
Waist: {{waist}}
Foot: {{foot}}
Hand: {{hand}}
Neck: {{neck}}
Ring: {{ring}}
</equipment>

<battle_status>
In Battle: {{inBattle}}
Beast: {{currentBeast}}
Beast Health: {{beastHealth}}/{{beastMaxHealth}}
Beast Level: {{beastLevel}}
Beast Tier: {{beastTier}}
Beast Type: {{beastType}}
Beast Specials: {{beastSpecial1}}, {{beastSpecial2}}, {{beastSpecial3}}
Last Action: {{lastAction}}
Last Damage Dealt: {{lastDamageDealt}}
Last Damage Taken: {{lastDamageTaken}}
Critical Hit: {{lastCritical}}
</battle_status>

<inventory>
Bag Items: {{bagItems}}
</inventory>

<market>
Available Items: {{marketItems}}
</market>

Available Actions:
1. Combat Actions:
   - attack(adventurer_id, to_the_death): 
     * Single attack when to_the_death = false
     * Fight until victory/death when to_the_death = true
   - flee(adventurer_id, to_the_death):
     * Single escape attempt when to_the_death = false
     * Keep trying until escape/death when to_the_death = true

2. Exploration Actions:
   - explore(adventurer_id, till_beast):
     * Single exploration when till_beast = false
     * Keep exploring until beast when till_beast = true

3. Inventory Management:
   - equipItems(adventurer_id, items): Equip items from bag
   - upgradeAdventurer(adventurer_id, potions, stats, items):
     * Buy and use potions
     * Upgrade character stats
     * Purchase and optionally equip items

4. Character Management:
   - newGame(starting_weapon, name, character_class): Start new adventure
   - getAdventurerState(adventurer_id): Refresh game state

Strategic Guidelines:
1. ALWAYS check for available stat upgrades first - you MUST allocate them before exploring
2. Prioritize survival - manage your health and know when to flee
3. Choose equipment upgrades that complement your playstyle
4. Be aware of weapon effectiveness against different armor types
5. Upgrade stats strategically - Vitality for health, Strength for damage, etc.
6. Save gold for important purchases rather than buying every item
7. Assess beast difficulty before engaging in combat
8. Use your strongest equipment and keep your bag organized
9. Calculate flee probability: Dexterity / Level
10. Combat assessment: Compare your weapon type vs beast armor type
11. Calculate potion costs vs benefits: Consider potion cost = level - (2 * charisma)
12. Consider strategic fleeing for long-term survival

DECISION MAKING PRIORITY ORDER:
1. If stat_upgrades_available > 0: MUST use upgradeAdventurer to allocate points
2. If in battle (inBattle = true): MUST attack or flee
3. If health is low: Consider buying potions
4. If market has good items: Consider buying equipment
5. Otherwise: Explore to find beasts and loot

Your task is to analyze the current game state and make strategic decisions. Follow these steps:

1. First, check if you have available stat upgrades that MUST be allocated
2. Check if you're in battle that needs immediate resolution
3. Analyze your current stats, health, equipment, and resources
4. Evaluate the current situation (exploring, in battle, shopping)
5. Consider the best action based on the game state
6. Explain your reasoning and decision clearly

Inside your thinking block, use <strategy_planning> tags to show your thought process:

1. Assess your current status and strengths/weaknesses
2. List possible actions and their potential outcomes
3. Weigh risks vs. rewards
4. Choose the optimal action

If you die during gameplay, start a new game immediately and continue playing. If you encounter any errors, ask the user to re-authenticate.

Output Format:
Decision: [Your chosen action]
Explanation: [A clear explanation of your decision and how it fits your strategy]
Next Steps: [Brief outline of your plan for the next few turns]

Remember to constantly adapt your strategy as the game state changes. Your goal is long-term survival and progression.
`;

// Context for the agent
export const goalContexts = context({
  type: "goal",
  schema: z.object({
    id: string(),
    initialGoal: z.string().default("Survive and progress in Loot Survivor"),
    initialTasks: z
      .array(z.string())
      .default([
        "Make strategic decisions",
        "Manage resources",
        "Defeat beasts",
        "Upgrade your adventurer",
        "Collect loot",
        "Explore the world",
        "Shop for items",
        "Sell items",
        "Buy items",
      ]),
  }),

  key() {
    return "1";
  },

  create(_state): LootSurvivorState {
    return {
      adventurerId: "0",
      adventurerHealth: "0",
      adventurerMaxHealth: "100", // Set to base health value
      level: "1",
      xp: "0",
      gold: "0",
      statUpgrades: "0",

      strength: "0",
      dexterity: "0",
      vitality: "0",
      intelligence: "0",
      wisdom: "0",
      charisma: "0",
      luck: "0",

      weapon: "None",
      chest: "None",
      head: "None",
      waist: "None",
      foot: "None",
      hand: "None",
      neck: "None",
      ring: "None",

      // Added equipment XP fields
      weaponXP: "0",
      chestXP: "0",
      headXP: "0",
      waistXP: "0",
      footXP: "0",
      handXP: "0",
      neckXP: "0",
      ringXP: "0",

      currentBeast: "None",
      beastHealth: "0",
      beastMaxHealth: "0",
      beastLevel: "0",
      beastTier: "0",
      beastType: "0",
      beastSpecial1: "None",
      beastSpecial2: "None",
      beastSpecial3: "None",

      inBattle: "false",
      lastAction: "None",
      lastDamageDealt: "0",
      lastDamageTaken: "0",
      lastCritical: "false",
      battleActionCount: "0",

      bagItems: [],
      marketItems: [], // Empty array of {id, name, price}
    };
  },

  render({ memory }) {
    // Add debug logging to see what's in memory before rendering
    console.log(`[RENDER] Starting render with memory:`, {
      adventurerId: memory.adventurerId ?? "0",
      health: memory.adventurerHealth ?? "0",
      maxHealth: memory.adventurerMaxHealth ?? "0",
      level: memory.level ?? "1",
      xp: memory.xp ?? "0",
      gold: memory.gold ?? "0",
      statUpgrades: memory.statUpgrades ?? "0",
      inBattle: memory.inBattle ?? "false",
    });

    // Calculate potion price for the UI
    const potionPrice =
      memory.level && memory.charisma
        ? getPotionPrice(parseInt(memory.level), parseInt(memory.charisma))
        : 1;

    // Debug log to see what's in memory.marketItems
    console.log(`[RENDER] Market items before formatting:`, memory.marketItems);

    // Ensure memory.marketItems is always an array
    const marketItems = Array.isArray(memory.marketItems) ? memory.marketItems : [];

    // Format market items to include potion at the top
    const formattedMarketItems =
      marketItems.length > 0
        ? `Potion: ${potionPrice} gold (Restores 10 HP), ` +
        marketItems
          .map(
            (item: { name: string; price: string }) =>
              `${item.name} (${item.price} gold)`
          )
          .join(", ")
        : `Potion: ${potionPrice} gold (Restores 10 HP)`;

    console.log(`[RENDER] Formatted market items for agent:`, formattedMarketItems);

    // Format bag items for display
    const bagItemsString = Array.isArray(memory.bagItems) && memory.bagItems.length > 0
      ? memory.bagItems.join(", ")
      : "None";

    console.log(`[RENDER] Bag items for agent:`, bagItemsString);

    // Create template parameters
    const templateParams = {
      adventurerId: memory.adventurerId ?? "0",
      adventurerHealth: memory.adventurerHealth ?? "0",
      adventurerMaxHealth: memory.adventurerMaxHealth ?? "0",
      level: memory.level ?? "1",
      xp: memory.xp ?? "0",
      gold: memory.gold ?? "0",
      battleActionCount: memory.battleActionCount ?? "0",

      strength: memory.strength ?? "0",
      dexterity: memory.dexterity ?? "0",
      vitality: memory.vitality ?? "0",
      intelligence: memory.intelligence ?? "0",
      wisdom: memory.wisdom ?? "0",
      charisma: memory.charisma ?? "0",
      luck: memory.luck ?? "0",
      statUpgrades: memory.statUpgrades ?? "0",

      weapon: memory.weapon
        ? `${memory.weapon}${memory.weaponXP ? ` (Greatness: ${calculateGreatness(parseInt(memory.weaponXP))})` : ""}`
        : "None",
      chest: memory.chest
        ? `${memory.chest}${memory.chestXP ? ` (Greatness: ${calculateGreatness(parseInt(memory.chestXP))})` : ""}`
        : "None",
      head: memory.head
        ? `${memory.head}${memory.headXP ? ` (Greatness: ${calculateGreatness(parseInt(memory.headXP))})` : ""}`
        : "None",
      waist: memory.waist
        ? `${memory.waist}${memory.waistXP ? ` (Greatness: ${calculateGreatness(parseInt(memory.waistXP))})` : ""}`
        : "None",
      foot: memory.foot
        ? `${memory.foot}${memory.footXP ? ` (Greatness: ${calculateGreatness(parseInt(memory.footXP))})` : ""}`
        : "None",
      hand: memory.hand
        ? `${memory.hand}${memory.handXP ? ` (Greatness: ${calculateGreatness(parseInt(memory.handXP))})` : ""}`
        : "None",
      neck: memory.neck
        ? `${memory.neck}${memory.neckXP ? ` (Greatness: ${calculateGreatness(parseInt(memory.neckXP))})` : ""}`
        : "None",
      ring: memory.ring
        ? `${memory.ring}${memory.ringXP ? ` (Greatness: ${calculateGreatness(parseInt(memory.ringXP))})` : ""}`
        : "None",

      currentBeast: memory.currentBeast ?? "None",
      beastHealth: memory.beastHealth ?? "0",
      beastMaxHealth: memory.beastMaxHealth ?? "0",
      beastLevel: memory.beastLevel ?? "0",
      beastTier: memory.beastTier ?? "0",
      beastType: memory.beastType ?? "0",
      beastSpecial1: memory.beastSpecial1 ?? "None",
      beastSpecial2: memory.beastSpecial2 ?? "None",
      beastSpecial3: memory.beastSpecial3 ?? "None",

      inBattle: memory.inBattle ?? "false",
      lastAction: memory.lastAction ?? "None",
      lastDamageDealt: memory.lastDamageDealt ?? "0",
      lastDamageTaken: memory.lastDamageTaken ?? "0",
      lastCritical: memory.lastCritical ?? "false",

      bagItems: bagItemsString,
      marketItems: formattedMarketItems,
    };

    // Log the final template parameters for debugging
    console.log(`[RENDER] Rendering template with parameters:`, {
      adventurerId: templateParams.adventurerId,
      health: `${templateParams.adventurerHealth}/${templateParams.adventurerMaxHealth}`,
      level: templateParams.level,
      gold: templateParams.gold,
      inBattle: templateParams.inBattle,
      statUpgrades: templateParams.statUpgrades,
      lastAction: templateParams.lastAction
    });

    return render(template, templateParams as any);
  },
});

// Create the Loot Survivor agent with UI integration
export const lootSurvivor = extension({
  name: "lootSurvivor",
  contexts: {
    goal: goalContexts,
  },
  actions: [
    /**
     * Action to start a new game
     */
    action({
      name: "newGame",
      description: "Start a new game in Loot Survivor",
      schema: z
        .object({
          startingWeapon: z
            .enum(["Wand", "Book", "Club", "ShortSword"])
            .describe(
              "The weapon to start with (Blade, Bludgeon, or Magic type. Wand and Book are magic types.)"
            ),
          name: z.string().describe("The name of your adventurer"),
        })
        .describe("Start a new game with a chosen weapon, and name"),
      async handler(data, ctx: any, _agent: Agent) {
        try {
          console.log(
            `[ACTION] Starting New Game - Weapon: ${data.startingWeapon}, Name: ${data.name}`
          );

          const { startingWeapon, name } = data;

          // Map starting weapon to weapon ID
          const weaponIdMap: Record<string, number> = {
            Club: 76,
            Book: 16,
            Wand: 12,
            ShortSword: 46,
          };

          const weaponId = weaponIdMap[startingWeapon] || 1;

          console.log(`[STARKNET] Calling new_game function on contract`);

          // Updated to match ABI parameters
          const result = await starknet.write({
            contractAddress: GAME_CONTRACT_ADDRESS,
            entrypoint: "new_game",
            calldata: [
              env.STARKNET_ADDRESS, // client_reward_address (using our configured address)
              weaponId, // weapon
              Buffer.from(name).toString("hex"), // name
              0, // golden_token_id (default 0)
              0, // delay_reveal (false)
              0, // custom_renderer (0x0 address)
              0, // launch_tournament_winner_token_id (0)
              env.STARKNET_ADDRESS, // mint_to (using our configured address)
            ],
          });

          console.log(
            `[STARKNET] Transaction hash: ${result.transaction_hash}`
          );

          // Create a new adventurer ID from the transaction hash or result
          const adventurerId = result.transaction_hash || "unknown";

          // Initialize adventurer state through state manager
          console.log(`[NEWGAME] Waiting for transaction and initializing game state`);
          const state = await gameStateManager.updateAfterAction(
            adventurerId,
            "New Game Created",
            result.transaction_hash
          );

          if (!state) {
            return {
              success: false,
              error: "Failed to retrieve adventurer state after creation",
              message: "Failed to start a new game",
            };
          }

          // Apply the state to agent memory
          gameStateManager.applyToMemory(ctx);

          console.log(
            `[ACTION] New Game Created - Adventurer ID: ${state.adventurerId}`
          );

          // Set initial weapon and action in state directly, since blockchain might not reflect it immediately
          if (state) {
            state.weapon = ITEM_NAMES[weaponId - 1] || startingWeapon;
            state.lastAction = "New Game Created";
          }

          return {
            success: true,
            message: `Successfully started a new game with ${startingWeapon} and name ${name}. Your adventurer ID is ${adventurerId}.`,
            adventurerId: adventurerId // Return the ID so the agent can reference it
          };
        } catch (error: unknown) {
          const errorMessage =
            error instanceof Error ? error.message : String(error);
          console.error("[ERROR] Failed to start new game:", errorMessage);

          return {
            success: false,
            error: errorMessage,
            message: "Failed to start a new game",
          };
        }
      },
    }),

    /**
     * Action to explore the world
     */
    action({
      name: "explore",
      description: "Explore the world to find beasts, obstacles, or treasures",
      schema: z
        .object({
          adventurerId: z.string().describe("The ID of your adventurer"),
          tillBeast: z
            .boolean()
            .default(false)
            .describe(
              "Whether to explore until finding a beast (true) or just once (false)"
            ),
        })
        .describe(
          "Explore the world to discover beasts, obstacles, or treasures"
        ),
      async handler(data, ctx: any, _agent: Agent) {
        try {
          // Get current state through the state manager
          const currentState = await gameStateManager.getState(data.adventurerId);

          // Check if there are any stat upgrades available - if so, reject the action
          if (currentState && parseInt(currentState.statUpgrades) > 0) {
            console.log("[ACTION] Rejecting explore - stat upgrades available:", currentState.statUpgrades);
            return {
              success: false,
              error: "Cannot explore when stat upgrades are available",
              message: "You must allocate all available stat points before exploring. Use upgradeAdventurer action first.",
            };
          }

          console.log(
            `[ACTION] Exploring - Adventurer ID: ${data.adventurerId}, Till Beast: ${data.tillBeast}`
          );

          const { adventurerId, tillBeast } = data;

          // Store initial state to compare later
          const initialState = currentState ? { ...currentState } : null;

          // Use Starknet to call explore function
          console.log(`[STARKNET] Calling explore function on contract`);
          const exploreResult = await starknet.write({
            contractAddress: GAME_CONTRACT_ADDRESS,
            entrypoint: "explore",
            calldata: [
              adventurerId,
              tillBeast ? 1 : 0, // Convert boolean to 0/1
            ],
          });

          console.log(
            `[STARKNET] Transaction hash: ${exploreResult.transaction_hash}`
          );

          // Update state through the state manager
          const updatedState = await gameStateManager.updateAfterAction(
            adventurerId,
            "Exploring",
            exploreResult.transaction_hash
          );

          if (!updatedState) {
            return {
              success: false,
              error: "Failed to retrieve updated adventurer state",
              message: "Failed to explore: could not get updated adventurer state",
            };
          }

          // Determine what happened during exploration by comparing before/after states
          let actionDescription = "Explored area";

          // Check for beast encounter
          if (updatedState.inBattle === "true") {
            actionDescription = "Discovered Beast";
            console.log(
              `[ENCOUNTER] Found Beast: ${updatedState.currentBeast || "Unknown"} (Level ${updatedState.beastLevel || "Unknown"})`
            );
          }
          // Check for health decrease (obstacle)
          else if (
            initialState &&
            parseInt(updatedState.adventurerHealth) < parseInt(initialState.adventurerHealth || "0")
          ) {
            const damageTaken =
              parseInt(initialState.adventurerHealth || "0") -
              parseInt(updatedState.adventurerHealth);
            actionDescription = `Encountered Obstacle (-${damageTaken} HP)`;
            updatedState.lastDamageTaken = damageTaken.toString();
            console.log(`[ENCOUNTER] Obstacle: Took ${damageTaken} damage`);
          }
          // Check for gold increase (discovery)
          else if (
            initialState &&
            parseInt(updatedState.gold) > parseInt(initialState.gold || "0")
          ) {
            const goldFound =
              parseInt(updatedState.gold) - parseInt(initialState.gold || "0");
            actionDescription = `Found ${goldFound} Gold`;
            console.log(`[DISCOVERY] Found ${goldFound} Gold`);
          }
          // Check if health increased (health discovery)
          else if (
            initialState &&
            parseInt(updatedState.adventurerHealth) > parseInt(initialState.adventurerHealth || "0")
          ) {
            const healthFound =
              parseInt(updatedState.adventurerHealth) -
              parseInt(initialState.adventurerHealth || "0");
            actionDescription = `Found ${healthFound} Health`;
            console.log(`[DISCOVERY] Found ${healthFound} Health`);
          }
          // Check if bag items count changed (item discovery)
          else if (
            initialState &&
            Array.isArray(initialState.bagItems) &&
            Array.isArray(updatedState.bagItems) &&
            updatedState.bagItems.length > initialState.bagItems.length
          ) {
            // Find the new item by comparing arrays
            const newItems = updatedState.bagItems.filter(
              (item: string) => !initialState.bagItems.includes(item)
            );
            if (newItems.length > 0) {
              actionDescription = `Found Item: ${newItems[0]}`;
              console.log(`[DISCOVERY] Found Item: ${newItems[0]}`);
            } else {
              actionDescription = "Found an Item";
              console.log(`[DISCOVERY] Found an item`);
            }
          }
          // Nothing interesting happened
          else {
            actionDescription = "Explored area, found nothing";
            console.log(`[EXPLORATION] Found nothing of interest`);
          }

          // Update last action in state
          updatedState.lastAction = actionDescription;

          // Check if level up occurred
          if (
            initialState &&
            parseInt(updatedState.statUpgrades) > parseInt(initialState.statUpgrades || "0")
          ) {
            console.log(`[LEVEL UP] Gained stat points! Available: ${updatedState.statUpgrades}`);
          }

          // Apply updated state to agent memory
          gameStateManager.applyToMemory(ctx);

          // Update the return statement in the explore handler
          console.log(`[ACTION] Exploration Complete - ${actionDescription}`);

          const stateSummary = generateStateSummary(updatedState);
          console.log(`[EXPLORE] Sending state summary to agent`);

          return {
            success: true,
            message: `${actionDescription}\n\n${stateSummary}`,
          };
        } catch (error: unknown) {
          const errorMessage =
            error instanceof Error ? error.message : String(error);
          console.error("[ERROR] Failed to explore:", errorMessage);

          return {
            success: false,
            error: errorMessage,
            message: "Failed to explore",
          };
        }
      },
    }),

    /**
     * Action to attack a beast
     */
    action({
      name: "attackBeast",
      description: "Attack the beast you're currently facing",
      schema: z
        .object({
          adventurerId: z.string().describe("The ID of your adventurer"),
          toTheDeath: z
            .boolean()
            .default(false)
            .describe(
              "Whether to fight to the death (true) or just attack once (false)"
            ),
        })
        .describe("Attack the beast you encountered"),
      async handler(data, ctx, _agent: Agent) {
        try {
          console.log(
            `[ACTION] Attacking Beast - Adventurer ID: ${data.adventurerId}, To Death: ${data.toTheDeath}`
          );

          const { adventurerId, toTheDeath } = data;

          // Get current state through the state manager
          const currentState = await gameStateManager.getState(adventurerId);

          // Make sure we're in battle
          if (!currentState || currentState.inBattle !== "true") {
            return {
              success: false,
              error: "Not in battle",
              message: "Cannot attack: you are not in battle with a beast",
            };
          }

          // Store initial state to compare later for damage calculation
          const initialState = { ...currentState };
          console.log(`[ATTACK] Initial beast health: ${initialState.beastHealth}, adventurer health: ${initialState.adventurerHealth}`);

          // Record the name of the beast we're fighting for better messaging
          const beastName = initialState.currentBeast || "Beast";

          console.log(`[STARKNET] Calling attack function on contract`);
          const attackResult = await starknet.write({
            contractAddress: GAME_CONTRACT_ADDRESS,
            entrypoint: "attack",
            calldata: [
              adventurerId,
              toTheDeath ? 1 : 0, // Convert boolean to 0/1
            ],
          });

          console.log(
            `[STARKNET] Transaction hash: ${attackResult.transaction_hash}`
          );

          // Update state through the state manager but use a descriptive action name for better logs
          const updatedState = await gameStateManager.updateAfterAction(
            adventurerId,
            `Attacking ${beastName}`,
            attackResult.transaction_hash
          );

          if (!updatedState) {
            return {
              success: false,
              error: "Failed to retrieve updated adventurer state",
              message: "Failed to attack: could not get updated adventurer state",
            };
          }

          // Calculate damage dealt to beast - ensure we handle undefined values
          const initialBeastHealth = parseInt(initialState.beastHealth || "0");
          const updatedBeastHealth = parseInt(updatedState.beastHealth || "0");
          const damageDealt = Math.max(0, initialBeastHealth - updatedBeastHealth);

          // Calculate damage taken by adventurer
          const initialAdvHealth = parseInt(initialState.adventurerHealth || "0");
          const updatedAdvHealth = parseInt(updatedState.adventurerHealth || "0");
          const damageTaken = Math.max(0, initialAdvHealth - updatedAdvHealth);

          // Store damage values in state for reference
          updatedState.lastDamageDealt = damageDealt.toString();
          updatedState.lastDamageTaken = damageTaken.toString();

          // We don't know if it was critical without event logs, so default is false
          updatedState.lastCritical = "false";

          // Log detailed attack results for debugging
          console.log(`[ATTACK] Damage calculation:`, {
            initialBeastHealth,
            updatedBeastHealth,
            damageDealt,
            initialAdvHealth,
            updatedAdvHealth,
            damageTaken
          });

          // Check if beast was defeated
          const beastDefeated = updatedBeastHealth <= 0;

          // Check if adventurer died
          const adventurerDied = updatedAdvHealth <= 0;

          // Check for XP and gold gains
          const initialXP = parseInt(initialState.xp || "0");
          const updatedXP = parseInt(updatedState.xp || "0");
          const xpGained = Math.max(0, updatedXP - initialXP);

          const initialGold = parseInt(initialState.gold || "0");
          const updatedGold = parseInt(updatedState.gold || "0");
          const goldGained = Math.max(0, updatedGold - initialGold);

          // Create detailed action description with specific numbers for the agent
          let actionDescription = "";

          if (adventurerDied) {
            actionDescription = `Died while attacking ${beastName}`;
            console.log(`[DEATH] Your adventurer has been slain!`);
          } else if (beastDefeated) {
            actionDescription = `Defeated ${beastName}`;
            if (xpGained > 0 || goldGained > 0) {
              actionDescription += ` (Gained`;
              if (xpGained > 0) actionDescription += ` ${xpGained} XP`;
              if (xpGained > 0 && goldGained > 0) actionDescription += `,`;
              if (goldGained > 0) actionDescription += ` ${goldGained} Gold`;
              actionDescription += `)`;
            }
            console.log(`[VICTORY] ${beastName} slain!`);
          } else {
            // Most important case - clearly describe attack results
            actionDescription = `Attacked ${beastName}: Dealt ${damageDealt} damage`;
            if (damageTaken > 0) {
              actionDescription += `, took ${damageTaken} damage`;
            }
            actionDescription += ` (Beast health: ${updatedBeastHealth}/${initialState.beastMaxHealth})`;

            console.log(
              `[BATTLE] Attacked ${beastName}, dealt ${damageDealt} damage, took ${damageTaken} damage`
            );
          }

          // Update the last action in state
          updatedState.lastAction = actionDescription;
          console.log(`[ATTACK] Set lastAction to: "${actionDescription}"`);

          // Check for level up
          const initialLevel = parseInt(initialState.level || "1");
          const updatedLevel = parseInt(updatedState.level || "1");
          if (updatedLevel > initialLevel) {
            console.log(
              `[LEVEL UP] Advanced to level ${updatedLevel}! Available stat points: ${updatedState.statUpgrades}`
            );
          }

          // Apply updated state to agent memory
          gameStateManager.applyToMemory(ctx);

          console.log(`[ACTION] Attack Complete - ${actionDescription}`);

          // Return a clear, detailed message about the attack outcome
          const stateSummary = generateStateSummary(updatedState);
          console.log(`[ATTACK] Sending state summary to agent`);
          return {
            success: true,
            message: `${actionDescription}\n\n${stateSummary}`,
            // Include additional details that might be useful to the agent
            details: {
              beastName,
              damageDealt,
              damageTaken,
              beastHealth: updatedBeastHealth,
              beastMaxHealth: initialState.beastMaxHealth,
              beastDefeated,
              xpGained,
              goldGained,
              levelUp: updatedLevel > initialLevel
            }
          };
        } catch (error: unknown) {
          const errorMessage =
            error instanceof Error ? error.message : String(error);
          console.error("[ERROR] Failed to attack beast:", errorMessage);

          return {
            success: false,
            error: errorMessage,
            message: "Failed to attack beast",
          };
        }
      },
    }),

    /**
     * Action to get the current state of the adventurer
     */
    action({
      name: "getAdventurerState",
      description: "Get the current state of your adventurer",
      schema: z
        .object({
          adventurerId: z.string().describe("The ID of your adventurer"),
        })
        .describe("Get the current state of your adventurer"),
      async handler(data, ctx, _agent: Agent) {
        try {
          console.log(
            `[ACTION] Getting Adventurer State - ID: ${data.adventurerId}`
          );

          const { adventurerId } = data;

          // Force refresh state through state manager
          const updatedState = await gameStateManager.getState(adventurerId, true);

          if (!updatedState) {
            return {
              success: false,
              error: "Failed to retrieve adventurer state",
              message: "Failed to get adventurer state",
            };
          }

          // Apply the updated state to agent memory
          const memoryState = gameStateManager.applyToMemory(ctx);

          console.log(`[ACTION] State Retrieved Successfully`);

          // Create a detailed state summary to return directly to the agent
          const stateSummary = generateStateSummary(updatedState);

          console.log(`[ACTION] Sending state summary to agent`);

          return {
            success: true,
            message: `State retrieved successfully. ${stateSummary}`,
          };
        } catch (error: unknown) {
          const errorMessage =
            error instanceof Error ? error.message : String(error);
          console.error(
            "[ERROR] Failed to get adventurer state:",
            errorMessage
          );

          return {
            success: false,
            error: errorMessage,
            message: "Failed to get adventurer state",
          };
        }
      },
    }),

    /**
     * Action to flee from a beast
     */
    action({
      name: "fleeBeast",
      description: "Try to flee from the beast you're currently facing",
      schema: z
        .object({
          adventurerId: z.string().describe("The ID of your adventurer"),
          toTheDeath: z
            .boolean()
            .default(false)
            .describe("Always false as this is a flee attempt"),
        })
        .describe("Try to flee from the beast you encountered"),
      async handler(data, ctx: any, _agent: Agent) {
        try {
          console.log(
            `[ACTION] Attempting to Flee - Adventurer ID: ${data.adventurerId}`
          );

          const { adventurerId, toTheDeath } = data;

          // Get current state through the state manager
          const currentState = await gameStateManager.getState(adventurerId);

          // Make sure we're in battle
          if (!currentState || currentState.inBattle !== "true") {
            return {
              success: false,
              error: "Not in battle",
              message: "Cannot flee: you are not in battle with a beast",
            };
          }

          // Store initial state to compare later
          const initialState = { ...currentState };

          // Record the name of the beast we're fleeing from
          const beastName = initialState.currentBeast || "Beast";
          console.log(`[FLEE] Attempting to flee from ${beastName}`);

          // Use Starknet to call flee function
          console.log(`[STARKNET] Calling flee function on contract`);
          const fleeResult = await starknet.write({
            contractAddress: GAME_CONTRACT_ADDRESS,
            entrypoint: "flee",
            calldata: [
              adventurerId,
              toTheDeath ? 1 : 0, // Typically should be 0 for flee
            ],
          });

          console.log(
            `[STARKNET] Transaction hash: ${fleeResult.transaction_hash}`
          );

          // Update state through the state manager
          const updatedState = await gameStateManager.updateAfterAction(
            adventurerId,
            `Fleeing from ${beastName}`,
            fleeResult.transaction_hash
          );

          if (!updatedState) {
            return {
              success: false,
              error: "Failed to retrieve updated adventurer state",
              message: "Failed to flee: could not get updated adventurer state",
            };
          }

          // Determine what happened during flee attempt by comparing before/after states

          // Calculate damage taken during flee attempt
          const initialHealth = parseInt(initialState.adventurerHealth || "0");
          const updatedHealth = parseInt(updatedState.adventurerHealth || "0");
          const damageTaken = Math.max(0, initialHealth - updatedHealth);

          // Update state with damage information
          updatedState.lastDamageTaken = damageTaken.toString();
          updatedState.lastDamageDealt = "0"; // We don't deal damage during flee attempts

          // Check if flee was successful - we're no longer in battle
          const fleeSuccessful = updatedState.inBattle === "false";

          // Check if adventurer died
          const adventurerDied = updatedHealth <= 0;

          // Create detailed action description
          let actionDescription = "";

          if (adventurerDied) {
            actionDescription = `Died while fleeing from ${beastName}`;
            console.log(`[DEATH] Your adventurer died while attempting to flee!`);
          } else if (fleeSuccessful) {
            actionDescription = `Successfully fled from ${beastName}`;
            if (damageTaken > 0) {
              actionDescription += ` (took ${damageTaken} damage)`;
            }
            console.log(`[FLEE] Successfully escaped from ${beastName}!`);
          } else {
            actionDescription = `Failed to flee from ${beastName}`;
            if (damageTaken > 0) {
              actionDescription += ` (took ${damageTaken} damage)`;
            }
            console.log(
              `[FLEE] Failed to escape from ${beastName}!${damageTaken > 0 ? ` Took ${damageTaken} damage!` : ''}`
            );
          }

          // Update the last action in state
          updatedState.lastAction = actionDescription;
          console.log(`[FLEE] Set lastAction to: "${actionDescription}"`);

          // Apply state to agent memory
          gameStateManager.applyToMemory(ctx);

          console.log(`[ACTION] Flee Attempt Complete - ${actionDescription}`);

          const stateSummary = generateStateSummary(updatedState);
          console.log(`[FLEE] Sending state summary to agent`);

          return {
            success: true,
            message: `${actionDescription}\n\n${stateSummary}`,
            details: {
              beastName,
              fleeSuccessful,
              damageTaken,
              adventurerDied,
              // Include the current health so the agent knows its situation
              currentHealth: updatedHealth,
              maxHealth: parseInt(updatedState.adventurerMaxHealth || "100")
            }
          };
        } catch (error: unknown) {
          const errorMessage =
            error instanceof Error ? error.message : String(error);
          console.error("[ERROR] Failed to flee from beast:", errorMessage);

          return {
            success: false,
            error: errorMessage,
            message: "Failed to flee from beast",
          };
        }
      },
    }),
  ],
});

// Add a utility function to wait for transaction confirmation
async function waitForTransaction(txHash: string, waitTime: number = 5000): Promise<void> {
  console.log(`[STARKNET] Waiting for transaction ${txHash} to be confirmed...`);

  try {
    // First add a small delay to allow transaction to propagate
    await new Promise(resolve => setTimeout(resolve, 1000));

    // Then poll until the transaction is confirmed
    let status = "RECEIVED";
    let attempts = 0;
    const maxAttempts = 30; // Prevent infinite loops
    const pollInterval = 2000; // 2 seconds between checks

    while (!["ACCEPTED_ON_L2", "ACCEPTED_ON_L1"].includes(status) && attempts < maxAttempts) {
      try {
        // Use the direct account.waitForTransaction method with polling
        const receipt = await starknet.write({
          contractAddress: GAME_CONTRACT_ADDRESS,
          entrypoint: "check_transaction_status", // Using a read-only entrypoint to get access to provider
          calldata: [txHash],
        });

        // Extract status from receipt if available
        if (receipt && typeof receipt === 'object' && 'execution_status' in receipt) {
          const executionStatus = receipt.execution_status;
          if (executionStatus === "SUCCEEDED") {
            status = "ACCEPTED_ON_L2";
          } else if (executionStatus === "REVERTED") {
            console.error(`[STARKNET] Transaction ${txHash} failed with status: REVERTED`);
            throw new Error(`Transaction failed: REVERTED`);
          }
        }

        if (!["ACCEPTED_ON_L2", "ACCEPTED_ON_L1"].includes(status)) {
          console.log(`[STARKNET] Transaction ${txHash} not confirmed yet. Waiting...`);
          await new Promise(resolve => setTimeout(resolve, pollInterval));
        }
      } catch (error) {
        console.warn(`[STARKNET] Error checking transaction status: ${error}`);
        await new Promise(resolve => setTimeout(resolve, pollInterval));
      }

      attempts++;
    }

    if (attempts >= maxAttempts) {
      console.warn(`[STARKNET] Transaction confirmation timed out after ${attempts} attempts. Proceeding anyway.`);
    } else {
      console.log(`[STARKNET] Transaction ${txHash} confirmed with status: ${status}`);
    }
  } catch (error) {
    console.error(`[STARKNET] Error waiting for transaction: ${error}`);
    // Fall back to simple delay in case of errors with receipt fetching
    console.log(`[STARKNET] Falling back to delay of ${waitTime}ms`);
    await new Promise(resolve => setTimeout(resolve, waitTime));
  }

  console.log(`[STARKNET] Resuming after transaction confirmation`);
}

// Add back the createDreams initialization at the end of the file
// Add this at the very end of the file

// Initialize the agent
createDreams({
  logger: LogLevel.INFO,
  model: anthropic("claude-3-7-sonnet-latest"),
  extensions: [cliExtension, lootSurvivor],
  context: goalContexts,
  actions: [],
}).start({
  id: "loot-survivor-game",
  initialGoal:
    "Progress as far as possible in Loot Survivor, defeat beasts, collect loot, and upgrade your character.",
  initialTasks: [
    "Check adventurer state",
    "Start a new game if needed",
    "Explore and battle beasts strategically",
    "Manage equipment and upgrades",
    "Make decisions based on health and beast strength",
  ],
});

console.log(
  "Loot Survivor agent is now running! The agent will play the game through CLI."
);
--- End File: examples/games/lootsurvivor/example-lootsurvivor.ts ---

--- File: examples/mcp/mcp-agent.ts ---
import { createDreams } from "@daydreamsai/core";
import { createMcpExtension } from "@daydreamsai/mcp";
import { LogLevel } from "@daydreamsai/core";
import path from "path";
import { groq } from "@ai-sdk/groq";
import { cli } from "@daydreamsai/cli";

/**
 * This example demonstrates how to create an agent that connects to an MCP server
 * and uses its resources through the MCP extension.
 *
 * It sets up a connection to a local MCP server that provides access to resources
 * like application logs.
 */

// Create an agent with the MCP extension
createDreams({
  model: groq("deepseek-r1-distill-llama-70b"),
  logger: LogLevel.INFO,
  contexts: [cli],
  // Add the MCP extension with the example server configuration
  extensions: [
    createMcpExtension([
      {
        id: "example-server",
        name: "Example Resource Server",
        transport: {
          type: "stdio",
          command: "tsx",
          args: [path.join(__dirname, "mcp-server-example.ts")],
        },
      },
    ]),
  ],
}).start();

--- End File: examples/mcp/mcp-agent.ts ---

--- File: examples/mcp/mcp-server-example.ts ---
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { z } from "zod";

// Create an MCP server
const server = new McpServer({
  name: "Demo",
  version: "1.0.0",
});

// Add an addition tool
server.tool("add", { a: z.number(), b: z.number() }, async ({ a, b }) => ({
  content: [{ type: "text", text: String(a + b) }],
}));

async function main() {
  const transport = new StdioServerTransport();
  await server.connect(transport);
  console.error("MCP Server running on stdio");
}

main().catch((error) => {
  console.error("Fatal error in main():", error);
  process.exit(1);
});

--- End File: examples/mcp/mcp-server-example.ts ---

--- File: examples/mcp/package.json ---
{
  "name": "mcp",
  "module": "index.ts",
  "type": "module",
  "private": true,
  "devDependencies": {
    "@types/bun": "latest"
  },
  "peerDependencies": {
    "typescript": "^5"
  },
  "dependencies": {
    "@ai-sdk/anthropic": "^1.2.0",
    "@daydreamsai/core": "workspace:*",
    "@daydreamsai/mcp": "workspace:*",
    "@modelcontextprotocol/sdk": "^1.7.0",
    "zod": "^3.24.2"
  }
}

--- End File: examples/mcp/package.json ---

--- File: examples/server/README.md ---
# server

To install dependencies:

```bash
bun install
```

To run:

```bash
bun run 
```

This project was created using `bun init` in bun v1.2.5. [Bun](https://bun.sh) is a fast all-in-one JavaScript runtime.

--- End File: examples/server/README.md ---

--- File: examples/server/mcp/api.ts ---
import { createMcpClient } from "@daydreamsai/mcp";
import { Client as McpClient } from "@modelcontextprotocol/sdk/client/index.js";
import path from "path";
import { env } from "bun";
import { api } from "../utils";

export interface McpServerConfig {
  id: string;
  name: string;
  transport:
    | {
        type: "stdio";
        // For stdio transport
        command?: string;
        args?: string[];
      }
    | {
        type: "sse";
        // For SSE transport
        serverUrl?: string;
        sseEndpoint?: string;
        messageEndpoint?: string;
      };
  capabilities?: {
    prompts?: Record<string, unknown>;
    resources?: Record<string, unknown>;
    tools?: Record<string, unknown>;
  };
  env?: Record<string, string>;
}

export async function createMcpProxyApi({
  servers,
}: {
  servers: McpServerConfig[];
}) {
  const clients = new Map<string, McpClient>();

  for (const config of servers) {
    const client = await createMcpClient(config);
    clients.set(config.id, client);
  }

  return api({
    "/api/mcp/servers": async (req) => {
      return Response.json({
        servers: servers.map(({ id, name }) => ({ id, name })),
      });
    },
    "/api/mcp/servers/:serverId/tools": async (req) => {
      const { serverId } = req.params;
      const client = clients.get(serverId);
      if (!client) throw new Error("Unknow client");
      const { tools } = await client!.listTools();
      return Response.json({
        tools,
      });
    },
    "/api/mcp/servers/:serverId/tools/:tool": async (req) => {
      if (req.method !== "POST") {
        return new Response("Method not allowed", {
          status: 405,
        });
      }

      const { serverId, tool } = req.params;
      const client = clients.get(serverId);
      if (!client) throw new Error("Unknow client");

      const data = (await req.json()) as {
        args: any;
      };

      try {
        const result = await client.callTool({
          name: tool,
          arguments: data.args,
        });

        // const toolResult = JSON.parse((result.content as any)[0].text);
        return Response.json({
          serverId,
          tool: req.params.tool,
          result: result.content,
        });
      } catch (error) {
        return Response.json({
          serverId,
          tool,
          result: {
            error,
            message: error instanceof Error ? error.message : undefined,
          },
        });
      }
    },
    "/api/mcp/servers/:serverId/prompts": async (req) => {
      const { serverId } = req.params;
      const client = clients.get(serverId);
      if (!client) throw new Error("Unknow client");
      const res = await client!.listPrompts();
      return Response.json(res);
    },
    "/api/mcp/servers/:serverId/resources": async (req) => {
      const { serverId } = req.params;
      const client = clients.get(serverId);
      if (!client) throw new Error("Unknow client");
      const res = await client!.listResources();
      return Response.json(res);
    },
  });
}

--- End File: examples/server/mcp/api.ts ---

--- File: examples/server/mcp/servers/example.ts ---
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { z } from "zod";

// Create an MCP server
const server = new McpServer({
  name: "Demo",
  version: "1.0.0",
});

// Add an addition tool
server.tool("add", { a: z.number(), b: z.number() }, async ({ a, b }) => ({
  content: [{ type: "text", text: String(a + b) }],
}));

async function main() {
  const transport = new StdioServerTransport();
  await server.connect(transport);
  console.error("MCP Server running on stdio");
}

main().catch((error) => {
  console.error("Fatal error in main():", error);
  process.exit(1);
});

--- End File: examples/server/mcp/servers/example.ts ---

--- File: examples/server/package.json ---
{
  "name": "server",
  "private": true,
  "devDependencies": {
    "@types/bun": "latest"
  },
  "dependencies": {
    "@daydreamsai/core": "workspace:*",
    "@daydreamsai/mcp": "workspace:*",
    "@e2b/code-interpreter": "^1.0.4",
    "h3": "^1.15.1",
    "unstorage": "^1.15.0"
  },
  "peerDependencies": {
    "typescript": "^5"
  }
}

--- End File: examples/server/package.json ---

--- File: examples/server/server.ts ---
import { env, type RouterTypes } from "bun";
import { sanboxTools } from "./tools/sandbox";
import { basicTools } from "./tools/utils";
import { createToolsApi } from "./tools/api";
import { createMcpProxyApi, type McpServerConfig } from "./mcp/api";
import path from "path";
import { createStorageApi } from "./storage";
import fsLiteDriver from "unstorage/drivers/fs-lite";

export function createServer<
  R extends { [K in keyof R]: RouterTypes.RouteValue<K & string> },
>(params: { routes: R }) {
  const server = Bun.serve({
    port: 5555,
    routes: {
      "/ping": () => {
        return new Response("pong");
      },
      ...params.routes,
    },
  });
  return server;
}

const tools = {
  ...sanboxTools,
  ...basicTools,
};

export type ServerTools = typeof tools;

const mcpServers: McpServerConfig[] = [
  {
    id: "example-server",
    name: "Example Resource Server",
    transport: {
      type: "stdio",
      command: "tsx",
      args: [path.join(__dirname, "./mcp/servers/example.ts")],
    },
  },
  {
    id: "github",
    name: "GitHub MCP Server",
    transport: {
      type: "stdio",
      command: "docker",
      args: [
        "run",
        "-i",
        "--rm",
        "-e",
        "GITHUB_PERSONAL_ACCESS_TOKEN",
        "ghcr.io/github/github-mcp-server",
      ],
    },
    env: {
      GITHUB_PERSONAL_ACCESS_TOKEN: env.GITHUB_TOKEN!,
    },
  },
];

const mcpApi = await createMcpProxyApi({
  servers: mcpServers,
});

const server = createServer({
  routes: {
    ...createToolsApi({ tools }),
    ...createStorageApi(fsLiteDriver({ base: "./data/storage" })),
    ...mcpApi,
  },
});

--- End File: examples/server/server.ts ---

--- File: examples/server/storage.ts ---
import { createStorage, type Driver } from "unstorage";
import { createH3StorageHandler } from "unstorage/server";
import { createApp, toWebHandler } from "h3";
import { api } from "./utils";

export function createStorageApi(driver: Driver) {
  const storage = createStorage({
    driver,
  });

  const storageHandler = createH3StorageHandler(storage, {
    authorize(req) {
      console.log({ req });
    },
  });
  const app = createApp({ debug: true });
  app.use("/api/storage", storageHandler);
  const handler = toWebHandler(app);
  return api({
    "/api/storage/*": (req) => handler(req),
  });
}

--- End File: examples/server/storage.ts ---

--- File: examples/server/tools/api.ts ---
import { type CoreMessage } from "ai";
import zodToJsonSchema from "zod-to-json-schema";
import { randomUUIDv7, type RouterTypes } from "bun";
import { api, type ToolSet } from "../utils";

export function createToolsApi<Tools extends ToolSet>({
  tools,
}: {
  tools: {
    [K in keyof Tools]: Tools[K];
  };
}) {
  return api(() => {
    const state = {
      tools: Object.entries(tools as ToolSet).map(([name, tool]) => ({
        name,
        ...tool,
      })),
    };
    return {
      "/api/tools": {
        GET: async () => {
          return Response.json({
            tools: state.tools.map((tool) => ({
              name: tool.name,
              description: tool.description,
              parameters: zodToJsonSchema(tool.parameters, "schema")
                .definitions!["schema"],
            })),
          });
        },
      },
      "/api/tools/:tool": {
        POST: async (req) => {
          const data = (await req.json()) as {
            args: any;
            messages?: CoreMessage[];
            toolCallId?: string;
          };

          const tool = state.tools.find(
            (tool) => tool.name === req.params.tool
          )!;
          const args = tool.parameters.parse(data.args);
          const toolCallId = data.toolCallId ?? randomUUIDv7();

          try {
            const result = tool.execute
              ? await tool.execute(args, {
                  messages: data.messages ?? [],
                  toolCallId,
                  abortSignal: req.signal,
                })
              : args;
            return Response.json({
              tool: req.params.tool,
              toolCallId,
              result,
            });
          } catch (error) {
            return Response.json({
              tool: req.params.tool,
              toolCallId,
              result: {
                error,
                message: error instanceof Error ? error.message : undefined,
              },
            });
          }
        },
      },
    };
  });
}

--- End File: examples/server/tools/api.ts ---

--- File: examples/server/tools/sandbox.ts ---
import { tool } from "ai";
import { z } from "zod";
import { createToolSet } from "../utils";
import { Sandbox } from "@e2b/code-interpreter";
import { env } from "bun";
const e2bApiKey = env.E2B_API_KEY;

export type SandboxTools = typeof sanboxTools;

export const sanboxTools = createToolSet({
  "sandbox.runCode": tool({
    parameters: z.object({
      code: z.string(),
      language: z.enum(["python", "js"]),
      sandboxId: z.string(),
    }),
    execute: async ({ code, language, sandboxId }) => {
      const sdx = sandboxId
        ? await Sandbox.connect(sandboxId, { apiKey: e2bApiKey })
        : await Sandbox.create({ apiKey: e2bApiKey });

      const response = await sdx.runCode(code, {
        language,
        onStdout(output) {
          console.log("out", output);
        },
        onStderr(output) {
          console.log("err", output);
        },
      });

      return response;
    },
  }),
  "sandbox.files.list": tool({
    parameters: z.object({
      path: z.string(),
      sandboxId: z.string(),
    }),
    execute: async ({ path, sandboxId }) => {
      const sdx = sandboxId
        ? await Sandbox.connect(sandboxId, { apiKey: e2bApiKey })
        : await Sandbox.create({ apiKey: e2bApiKey });
      return await sdx.files.list(path);
    },
  }),
  "sandbox.files.read": tool({
    parameters: z.object({
      path: z.string(),
      sandboxId: z.string(),
    }),
    execute: async ({ path, sandboxId }) => {
      const sdx = sandboxId
        ? await Sandbox.connect(sandboxId, { apiKey: e2bApiKey })
        : await Sandbox.create({ apiKey: e2bApiKey });
      return await sdx.files.read(path);
    },
  }),
  "sandbox.files.write": tool({
    parameters: z.object({
      path: z.string(),
      content: z.string(),
      sandboxId: z.string(),
    }),
    execute: async ({ path, content, sandboxId }) => {
      const sdx = sandboxId
        ? await Sandbox.connect(sandboxId, { apiKey: e2bApiKey })
        : await Sandbox.create({ apiKey: e2bApiKey });
      return await sdx.files.write(path, content);
    },
  }),
  "sandbox.files.rename": tool({
    parameters: z.object({
      oldPath: z.string(),
      newPath: z.string(),
      sandboxId: z.string(),
    }),
    execute: async ({ oldPath, newPath, sandboxId }) => {
      const sdx = sandboxId
        ? await Sandbox.connect(sandboxId, { apiKey: e2bApiKey })
        : await Sandbox.create({ apiKey: e2bApiKey });
      return await sdx.files.rename(oldPath, newPath);
    },
  }),
  "sandbox.commands.run": tool({
    parameters: z.object({
      sandboxId: z.string(),
      cmd: z.string(),
      background: z.boolean().optional().default(false),
      // cwd: z.string().optional().describe("the working directory"),
      envs: z.record(z.string()).optional(),
    }),
    execute: async ({ cmd, background, envs, sandboxId }) => {
      const sdx = sandboxId
        ? await Sandbox.connect(sandboxId, { apiKey: e2bApiKey })
        : await Sandbox.create({ apiKey: e2bApiKey });
      return await sdx.commands.run(cmd, {
        background: background as any,
        // cwd,
        envs,
        onStdout(data) {
          console.log(data);
        },
      });
    },
  }),
});

--- End File: examples/server/tools/sandbox.ts ---

--- File: examples/server/tools/utils.ts ---
import { tool } from "ai";
import { z } from "zod";
import { createToolSet } from "../utils";
import { createContainer, http } from "@daydreamsai/core";
import { tavily, type TavilyClient } from "@tavily/core";
import { env } from "bun";

const container = createContainer();

container.singleton("tavily", () =>
  tavily({
    apiKey: env.TAVILY_API_KEY!,
  })
);

export type BasicTools = typeof basicTools;

export const basicTools = createToolSet({
  getWeather: tool({
    parameters: z.object({ location: z.string() }),
    description: "get the weather for a location",
    execute: async ({ location }, options) => {
      const geolocation = await http.get.json<{
        results: { latitude: number; longitude: number }[];
      }>("https://geocoding-api.open-meteo.com/v1/search", {
        name: location,
        count: 1,
        language: "en",
        format: "json",
      });
      if (geolocation.results[0]) {
        const res = await http.get.json<{ test: true }>(
          "https://api.open-meteo.com/v1/forecast",
          {
            latitude: geolocation.results[0].latitude,
            longitude: geolocation.results[0].longitude,
            current_weather: "true", // Request current weather data
          }
        );

        return res;
      }

      return "Failed";
    },
  }),
  "tavily.search": tool({
    description: "Execute a search query using Tavily Search.",
    parameters: z.object({
      query: z.string().describe("The search query to execute with Tavily."),
      topic: z
        .enum(["general", "news"])
        .optional()
        .default("general")
        .describe(
          "The category of the search.news is useful for retrieving real-time updates, particularly about politics, sports, and major current events covered by mainstream media sources. general is for broader, more general-purpose searches that may include a wide range of sources."
        ),
      maxResults: z.number().min(1).max(20).default(5).optional(),
      searchDepth: z
        .enum(["basic", "advanced"])
        .default("basic")
        .optional()
        .describe(
          "The depth of the search. advanced search is tailored to retrieve the most relevant sources and content snippets for your query, while basic search provides generic content snippets from each source."
        ),
    }),
    async execute({ query, topic, searchDepth, maxResults }) {
      const response = await container
        .resolve<TavilyClient>("tavily")
        .search(query, {
          searchDepth,
          topic,
          maxResults,
        });

      return {
        results: response.results.map((result) => ({
          title: result.title,
          url: result.url,
          content: result.content,
        })),
        totalResults: response.results.length,
      };
    },
  }),
  "tavily.extract": tool({
    description:
      "Extract web page content from one or more specified URLs using Tavily Extract.",
    parameters: z.object({
      urls: z
        .array(z.string())
        .describe("A list of URLs to extract content from."),

      extractDepth: z
        .enum(["basic", "advanced"])
        .default("basic")
        .optional()
        .describe(
          "The depth of the extraction process. advanced extraction retrieves more data, including tables and embedded content, with higher success but may increase latency.basic extraction costs 1 credit per 5 successful URL extractions, while advanced extraction costs 2 credits per 5 successful URL extractions."
        ),
    }),
    async execute({ urls, extractDepth }) {
      const response = await container
        .resolve<TavilyClient>("tavily")
        .extract(urls, {
          extractDepth,
        });

      return {
        results: response.results.map((result) => ({
          url: result.url,
          content: result.rawContent,
          images: result.images,
        })),
        totalResults: response.results.length,
      };
    },
  }),
});

--- End File: examples/server/tools/utils.ts ---

--- File: examples/server/utils.ts ---
import type { Tool } from "ai";
import { type RouterTypes } from "bun";

export type ToolSet = Record<string, Tool<any, any>>;

export function createToolSet<Tools extends ToolSet>(tools: {
  [K in keyof Tools]: Tools[K];
}) {
  return tools;
}

export function api<
  R extends { [K in keyof R]: RouterTypes.RouteValue<K & string> },
>(r: R | (() => R)) {
  return typeof r === "function" ? r() : r;
}

--- End File: examples/server/utils.ts ---

--- File: examples/tasks/eternum.ts ---
// This is all you need to inject into the LLM

export const ETERNUM_CONTEXT = `

Your Realms are:

Uw Rohi 
$REALM_ID: 6933
outer_col: 2147483646
outer_row: 2147483671

You are an AI assistant helping players with Eternum, a strategy game focused on realm development. Your purpose is to:

# Game Overview
1. Guide players through game mechanics
2. Help optimize resource management and building decisions  
3. Provide strategic recommendations based on game state

# Game Overview
- Players expand their Realm to build a hyperstructure
- Hyperstructures require 3M fragments and significant resources
- Once built, hyperstructures generate points when defended
- First player to accumulate 9M points wins the game

# When advising players, focus on:
- Current realm status and resources
- Strategic building placement
- Resource gathering efficiency
- Progress toward hyperstructure goals

<import_game_info>
1. Realm has no restrictions on building placement the level does not matter.
2. Building a building just requires having the resources along with a free space available.
</import_game_info>

Please familiarize yourself with the following game information:

<contract_addresses>
   - eternum-trade_systems: 0x1234567890ABCDEF1234567890ABCDEF1234567890ABCDEF1234567890ABCDEF
   - eternum-building_systems: 0x36b82076142f07fbd8bf7b2cabf2e6b190082c0b242c6ecc5e14b2c96d1763c
</contract_addresses>

<resource_ids>
  Stone = 1,
    Coal = 2,
    Wood = 3,
    Copper = 4,
    Ironwood = 5,
    Obsidian = 6,
    Gold = 7,
    Silver = 8,
    Mithral = 9,
    AlchemicalSilver = 10,
    ColdIron = 11,
    DeepCrystal = 12,
    Ruby = 13,
    Diamonds = 14,
    Hartwood = 15,
    Ignium = 16,
    TwilightQuartz = 17,
    TrueIce = 18,
    Adamantine = 19,
    Sapphire = 20,
    EtherealSilica = 21,
    Dragonhide = 22,
    AncientFragment = 29,
    Donkey = 249,
    Knight = 250,
    Crossbowman = 251,
    Paladin = 252,
    Lords = 253,
    Wheat = 254,
    Fish = 255
</resource_ids>

3. Building Types:
    None = 0
    Castle = 1
    Resource = 2
    Farm = 3
    Fishing Village = 4
    Barracks = 5
    Market = 6
    Archery Range = 7
    Stable = 8
    Trading Post = 9
    Workers Hut = 10
    Watch Tower = 11
    Walls = 12
    Storehouse = 13
    Bank = 14
    Fragment Mine = 15

4. Building Costs:
    Market: 750000 Fish, 125000 Stone, 50000 Obsidian, 25000 Ruby, 5000 DeepCrystal
    Barracks: 1000000 Wheat, 75000 Wood, 75000 Coal, 50000 Silver, 45000 Gold
    Archery Range: 1000000 Fish, 75000 Wood, 75000 Obsidian, 25000 Gold, 25000 Hartwood
    Stable: 1000000 Wheat, 75000 Wood, 75000 Silver, 35000 Ironwood, 25000 Gold
    Workers Hut: 300000 Wheat, 75000 Stone, 75000 Wood, 75000 Coal
    Storehouse: 1000000 Fish, 75000 Coal, 75000 Stone, 10000 Sapphire
    Farm: 450000 Fish
    Fishing Village: 450000 Wheat

5. Building Population Effects:
    None: 0
    Castle: 0
    Bank: 0
    Fragment Mine: 0
    Resource: 2
    Farm: 1
    Fishing Village: 1
    Barracks: 2
    Market: 3
    Archery Range: 2
    Stable: 3
    Trading Post: 2
    Workers Hut: 0
    Watch Tower: 2
    Walls: 2
    Storehouse: 2

6. Realm Levels and Upgrade Requirements:
Level 0 (Settlement):
  - 6 buildable hexes - starting realm level

Level 1 (City):
  - 18 buildable hexes
  - Requires: 3000k Wheat and 3000k Fish

Level 2 (Kingdom):
  Requires:
  - 600k ColdIron
  - 600k Hartwood  
  - 600k Diamonds
  - 600k Sapphire
  - 600k DeepCrystal
  - 5000k Wheat
  - 5000k Fish

Level 3 (Empire):
  Requires:
  - 50k AlchemicalSilver
  - 50k Adamantine
  - 50k Mithral 
  - 50k Dragonhide
  - 9000k Wheat
  - 9000k Fish

7. Building Descriptions:
    Farm: Creates Wheat
    Fishing Village: Creates Fish

When assisting players, follow these guidelines:

1. Buying Resources:
   a. Examine the market data using the eternum_Orders function.
   b. Accept an order using the eternum_AcceptOrder model with the correct parameters.


2. If asked to build a farm:
   a. Check resources
   b. Check space 
   c. Build farm


3. Realm Upgrades:
   a. Assess the current realm level and check if upgrade requirements are met.
   b. Advise on resource gathering if requirements are not met.
   c. Suggest upgrading when all requirements are satisfied.

When responding to player queries or requests:

1. Begin your analysis inside <game_analysis> tags:
   a. Summarize the current game context
   b. Identify the player's main concerns or goals
   c. List relevant game mechanics and resources
   d. Consider possible actions and their consequences
   e. Formulate a recommendation or strategy

2. Provide a clear explanation of your recommendation or the action to be taken.
3. Include relevant game data, calculations, or resource requirements as needed.
4. If multiple options are available, present them clearly with pros and cons.



Remember to always provide accurate information based on the game mechanics and current context. If you're unsure about any aspect, state so clearly and suggest where the player might find more information within the game.

<game_analysis>

<query_guide>
You are an AI assistant specialized in helping users query information about the Eternum game using GraphQL. Your task is to understand the user's request, construct an appropriate GraphQL query, and explain how to use it.



When a user asks for information about the game, follow these steps:

1. Analyze the user's request and determine which type of query is needed. Always follow <best_practices>
2. Break down your approach inside <query_analysis> tags, including:
   - A summary of the user's request
   - Identification of the relevant query type(s) needed
   - A list of specific parameters or variables required for the query
   - Consideration of any potential challenges or edge cases
3. Construct the appropriate GraphQL query based on the available models and query structures.
4. Provide the query in <query> tags.
5. Explain how to use the query and what it will return in <explanation> tags.
6. You should always use the entity_id in your queries unless specifically searching by realm_id. The entity_id is the id of the realm and how you query the realm.

Here are the main query structures you can use:

1. Get Realm Info:

\`\`\`graphql
query GetRealmInfo {
  s0EternumRealmModels(where: { realm_id: REALM_ID }) {
    edges {
      node {
          entity_id
          level
      }
    }
  }
}
\`\`\`

2. Get Realm Position:
\`\`\`graphql
query GetRealmPosition {
  s0EternumPositionModels(where: { entity_id: ENTITY_ID }, limit: 1) {
    edges {
      node {
   
          x
          y
      }
    }
  }
}
\`\`\`

3. Get Realm Details:
\`\`\`graphql
query GetRealmDetails {
  s0EternumResourceModels(where: { entity_id: ENTITY_ID }, limit: 100) {
    edges {
      node {
          resource_type
          balance
      }
    }
  }
  s0EternumBuildingModels(where: { outer_col: X, outer_row: Y }) {
    edges {
      node {
          category
          entity_id
          inner_col
          inner_row
      }
    }
  }
}
\`\`\`

4. Schema Introspection:
\`\`\`graphql
query IntrospectModel {
  __type(name: MODEL_NAME) {
    name
    fields {
      name
      type {
        name
        kind
        ofType {
          name
          kind
        }
      }
    }
  }
}
\`\`\`




<AVAILABLE_MODELS>
 s0EternumAcceptOrderModels
      s0EternumAcceptPartialOrderModels
      s0EternumAddressNameModels
      s0EternumArmyModels
      s0EternumArmyTroopsModels
      s0EternumArrivalTimeModels
      s0EternumBankModels
      s0EternumBattleModels
      s0EternumBattleClaimDataModels
      s0EternumBattleConfigModels
      s0EternumBattleJoinDataModels
      s0EternumBattleLeaveDataModels
      s0EternumBattlePillageDataModels
      s0EternumBattlePillageDataTroopsModels
      s0EternumBattlePillageDataU8u128Models
      s0EternumBattleStartDataModels
      s0EternumBattleBattleArmyModels
      s0EternumBattleBattleHealthModels
      s0EternumBattleTroopsModels
      s0EternumBuildingModels
      s0EternumBuildingCategoryPopConfigModels
      s0EternumBuildingConfigModels
      s0EternumBuildingGeneralConfigModels
      s0EternumBuildingQuantityv2Models
      s0EternumBurnDonkeyModels
      s0EternumCancelOrderModels
      s0EternumCapacityCategoryModels
      s0EternumCapacityConfigModels
      s0EternumContributionModels
      s0EternumCreateGuildModels
      s0EternumCreateOrderModels
      s0EternumDetachedResourceModels
      s0EternumEntityNameModels
      s0EternumEntityOwnerModels
      s0EternumEpochModels
      s0EternumEpochContractAddressu16Models
      s0EternumFragmentMineDiscoveredModels
      s0EternumGameEndedModels
      s0EternumGuildModels
      s0EternumGuildMemberModels
      s0EternumGuildWhitelistModels
      s0EternumHealthModels
      s0EternumHyperstructureModels
      s0EternumHyperstructureCoOwnersChangeModels
      s0EternumHyperstructureCoOwnersChangeContractAddressu16Models
      s0EternumHyperstructureConfigModels
      s0EternumHyperstructureContributionModels
      s0EternumHyperstructureContributionU8u128Models
      s0EternumHyperstructureFinishedModels
      s0EternumHyperstructureResourceConfigModels
      s0EternumJoinGuildModels
      s0EternumLevelingConfigModels
      s0EternumLiquidityModels
      s0EternumLiquidityEventModels
      s0EternumLiquidityFixedModels
      s0EternumMapConfigModels
      s0EternumMapExploredModels
      s0EternumMapExploredU8u128Models
      s0EternumMarketModels
      s0EternumMarketFixedModels
      s0EternumMercenariesConfigModels
      s0EternumMercenariesConfigU8u128Models
      s0EternumMessageModels
      s0EternumMovableModels
      s0EternumOrdersModels
      s0EternumOwnedResourcesTrackerModels
      s0EternumOwnerModels
      s0EternumPopulationModels
      s0EternumPopulationConfigModels
      s0EternumPositionModels
      s0EternumProductionModels
      s0EternumProductionDeadlineModels
      s0EternumProductionInputModels
      s0EternumProductionOutputModels
      s0EternumProgressModels
      s0EternumProtecteeModels
      s0EternumProtectorModels
      s0EternumQuantityModels
      s0EternumQuantityTrackerModels
      s0EternumQuestModels
      s0EternumQuestBonusModels
      s0EternumQuestConfigModels
      s0EternumRealmModels
      s0EternumRealmLevelConfigModels
      s0EternumRealmMaxLevelConfigModels
      s0EternumResourceModels
      s0EternumResourceAllowanceModels
      s0EternumResourceBridgeConfigModels
      s0EternumResourceBridgeFeeSplitConfigModels
      s0EternumResourceBridgeWhitelistConfigModels
      s0EternumResourceCostModels
      s0EternumResourceTransferLockModels
      s0EternumSeasonModels
      s0EternumSettleRealmDataModels
      s0EternumSettlementConfigModels
      s0EternumSpeedConfigModels
      s0EternumStaminaModels
      s0EternumStaminaConfigModels
      s0EternumStaminaRefillConfigModels
      s0EternumStatusModels
      s0EternumStructureModels
      s0EternumStructureCountModels
      s0EternumStructureCountCoordModels
      s0EternumSwapEventModels
      s0EternumTickConfigModels
      s0EternumTileModels
      s0EternumTradeModels
      s0EternumTransferModels
      s0EternumTransferU8u128Models
      s0EternumTravelModels
      s0EternumTravelFoodCostConfigModels
      s0EternumTravelStaminaCostConfigModels
      s0EternumTravelCoordModels
      s0EternumTroopConfigModels
      s0EternumTrophyCreationModels
      s0EternumTrophyCreationTaskModels
      s0EternumTrophyProgressionModels
      s0EternumWeightModels
      s0EternumWeightConfigModels
      s0EternumWorldConfigModels
</AVAILABLE_MODELS>

<best_practices>
1. Always first use GetRealmInfo to get the entity_id.
2. Always validate entity_id before querying. Use the introspection get the entity_id.
3. Always replace the <entity_id> with the actual entity_id.  
4. Use pagination for large result sets.
5. Include only necessary fields in your queries.
6. Handle null values appropriately.
</best_practices>

<import_query_context>
1. Always use entity_id in queries unless specifically searching by realm_id.
2. Use limit parameters to control result size.
3. Include proper type casting in variables.
4. Follow the nested structure: Models → edges → node → specific type.
5. Only use the models listed in the AVAILABLE_MODELS section to query.
</import_query_context>

Remember to replace placeholders like <realm_id>, <entity_id>, <x>, <y>, and <model_name> with actual values when constructing queries.

Now, please wait for a user query about the Eternum game, and respond according to the steps outlined above.

</query_guide>
`;

// API DOCs etc
export const PROVIDER_GUIDE = `

<PROVIDER_GUIDE>

    Use these to call functions with graphql


  <IMPORTANT_RULES>
    1. If you receive an error, you may need to try again, the error message should tell you what went wrong.
    2. To verify a successful transaction, read the response you get back. You don't need to query anything.
    3. Never include slashes in your calldata.
  </IMPORTANT_RULES>

  <FUNCTIONS>
    <CREATE_ORDER>
      <DESCRIPTION>
        Creates a new trade order between realms.
      </DESCRIPTION>
      <PARAMETERS>
        - maker_id: ID of the realm creating the trade
        - maker_gives_resources: Resources the maker is offering
        - taker_id: ID of the realm that can accept the trade
        - taker_gives_resources: Resources requested from the taker
        - signer: Account executing the transaction
        - expires_at: When the trade expires
      </PARAMETERS>
      <EXAMPLE>
     
          {
            "contractAddress": "<eternum-trade_systems>",
            "entrypoint": "create_order",
            "calldata": [
              123,         
              1,           
              1,           
              100,         
              456,         
              1,           
              2,           
              50,          
              1704067200   
            ]
          }
  
      </EXAMPLE>
    </CREATE_ORDER>

    <ACCEPT_ORDER>
      <DESCRIPTION>
        Accepts an existing trade order.
      </DESCRIPTION>
      <PARAMETERS>
        - taker_id: ID of the realm accepting the trade
        - trade_id: ID of the trade being accepted
        - maker_gives_resources: Resources the maker is offering
        - taker_gives_resources: Resources requested from the taker
        - signer: Account executing the transaction
      </PARAMETERS>
      <EXAMPLE>
        <JSON>
          {
            "contractAddress": "<eternum-trade_systems>",
            "entrypoint": "accept_order",
            "calldata": [
              123,
              789,
              1,
              1,
              100,
              1,
              2,
              50
            ]
          }
        </JSON>
      </EXAMPLE>
    </ACCEPT_ORDER>

    <ACCEPT_PARTIAL_ORDER>
      <DESCRIPTION>
        Accepts a portion of an existing trade order.
      </DESCRIPTION>
      <PARAMETERS>
        - taker_id: ID of the realm accepting the trade
        - trade_id: ID of the trade being accepted
        - maker_gives_resources: Resources the maker is offering
        - taker_gives_resources: Resources requested from the taker
        - taker_gives_actual_amount: Actual amount taker will give
        - signer: Account executing the transaction
      </PARAMETERS>
      <EXAMPLE>
        <JSON>
          {
            "contractAddress": "<eternum-trade_systems>",
            "entrypoint": "accept_partial_order",
            "calldata": [
              123,
              789,
              1,
              1,
              100,
              1,
              2,
              50,
              25
            ]
          }
        </JSON>
      </EXAMPLE>
    </ACCEPT_PARTIAL_ORDER>

    <CANCEL_ORDER>
      <DESCRIPTION>
        Cancels an existing trade order.
      </DESCRIPTION>
      <PARAMETERS>
        - trade_id: ID of the trade to cancel
        - return_resources: Resources to return
        - signer: Account executing the transaction
      </PARAMETERS>
      <EXAMPLE>
        <JSON>
          {
            "contractAddress": "<eternum-trade_systems>",
            "entrypoint": "cancel_order",
            "calldata": [
              789,
              1,
              1,
              100
            ]
          }
        </JSON>
      </EXAMPLE>
    </CANCEL_ORDER>

    <CREATE_BUILDING>
      <DESCRIPTION>
        Creates a new building for a realm on the hexagonal grid map.
      </DESCRIPTION>
      <PARAMETERS>
        - entity_id: ID of the realm creating the building (required)
        - directions: Array of directions from castle to building location (required)
        - building_category: Type of building (required)
        - produce_resource_type: Resource type ID this building will produce (required for resource buildings)
      </PARAMETERS>
      <NOTES>
        Never use 0 for produce_resource_type, always use the resource type ID - eg: fish is 1, wheat is 1, etc.
      </NOTES>
      
      <PLACEMENT_GUIDE>
        <DESCRIPTION>
          The map uses a hexagonal grid with your realm's castle at the center (0,0). 
          Buildings are placed by specifying directions outward from the castle.
        </DESCRIPTION>
        
        <DIRECTION_IDS>
          0 = East (→)
          1 = Northeast (↗) 
          2 = Northwest (↖)
          3 = West (←)
          4 = Southwest (↙) 
          5 = Southeast (↘)
        </DIRECTION_IDS>

        <KEY_RULES>
          1. Cannot build on castle location (0,0)
          2. Building distance from castle is limited by realm level
          3. Each direction in the array represents one hex step from castle
          4. Location is determined by following directions sequentially
        </KEY_RULES>

        <RESOURCE_TYPES>
          <BASIC_RESOURCES>
            Stone (1)
            Coal (2) 
            Wood (3)
            Copper (4)
            Ironwood (5)
            Obsidian (6)
          </BASIC_RESOURCES>

          <PRECIOUS_RESOURCES>
            Gold (7)
            Silver (8)
            Mithral (9)
            AlchemicalSilver (10)
            ColdIron (11)
          </PRECIOUS_RESOURCES>

          <RARE_RESOURCES>
            DeepCrystal (12)
            Ruby (13)
            Diamonds (14)
            Hartwood (15)
            Ignium (16)
            TwilightQuartz (17)
            TrueIce (18)
            Adamantine (19)
            Sapphire (20)
            EtherealSilica (21)
            Dragonhide (22)
          </RARE_RESOURCES>

          <SPECIAL_RESOURCES>
            AncientFragment (29)
            Donkey (249)
            Knight (250)
            Crossbowman (251)
            Paladin (252)
            Lords (253)
            Wheat (1)
            Fish (1)
          </SPECIAL_RESOURCES>
        </RESOURCE_TYPES>
      </PLACEMENT_GUIDE>

      <EXAMPLE>
        <DESCRIPTION>
          Create a wood production building one hex northeast of castle:
        </DESCRIPTION>
        <JSON>
          {
            "contractAddress": "<eternum-building_systems>",
            "entrypoint": "create",
            "calldata": [
              123,
              [1],
              1,
              3
            ]
          }
        </JSON>
      </EXAMPLE>
    </CREATE_BUILDING>
  </FUNCTIONS>
</PROVIDER_GUIDE>
`;

--- End File: examples/tasks/eternum.ts ---

--- File: examples/tasks/example-task.ts ---
/**
 * Advanced example demonstrating a hierarchical goal planning system using Dreams
 * with Claude 3.7 Sonnet for autonomous agent behavior in a game environment. This is still alpha and not all features are available.
 *
 * This example shows how to:
 * 1. Create a hierarchical goal planning system (long/medium/short-term goals)
 * 2. Decompose goals into executable tasks
 * 3. Track and update goal progress
 * 4. Integrate with external APIs (Tavily, Eternum)
 *
 * Usage
 * 1. First ask the agent to "set up a plan to win at Eternum"
 * 2. Then ask the agent to execute the plan.
 */
import {
  createDreams,
  context,
  render,
  action,
  LogLevel,
  output,
  createContainer,
  fetchGraphQL,
  type InferContextMemory,
  validateEnv,
} from "@daydreamsai/core";
import { cliExtension } from "@daydreamsai/cli";
import { deepResearch } from "../deep-research/research";
import { string, z } from "zod";
import { tavily } from "@tavily/core";
import { ETERNUM_CONTEXT } from "./eternum";
import { anthropic } from "@ai-sdk/anthropic";

validateEnv(
  z.object({
    ANTHROPIC_API_KEY: z.string().min(1, "ANTHROPIC_API_KEY is required"),
    TAVILY_API_KEY: z.string().min(1, "TAVILY_API_KEY is required"),
    OPENAI_API_KEY: z.string().min(1, "OPENAI_API_KEY is required"),
  })
);

/**
 * EXAMPLE USAGE:
 *
 * 1. Initialize the agent with a high-level objective:
 *    "Build a thriving settlement in Eternum with sustainable resource production"
 *
 * 2. The agent will automatically:
 *    - Break this down into hierarchical goals (long/medium/short-term)
 *    - Prioritize goals based on dependencies and importance
 *    - Execute tasks to achieve each goal
 *    - Update goal status as progress is made
 *
 * 3. Sample goal hierarchy:
 *    - Long-term: "Establish a self-sustaining settlement"
 *      - Medium-term: "Secure reliable food production"
 *        - Short-term: "Build 3 farms near water source"
 *          - Tasks: [Scout location, Gather resources, Construct buildings]
 */

// ==========================================
// SCHEMA DEFINITIONS
// ==========================================

/**
 * Defines the structure of individual tasks that make up a goal
 */
const taskSchema = z.object({
  plan: z.string().optional(),
  meta: z.any().optional(),
  actions: z.array(
    z.object({
      type: z.string(),
      context: z.string(),
      payload: z.any(),
    })
  ),
});

/**
 * Defines the structure of a goal with metadata for tracking and execution
 */
export const goalSchema = z
  .object({
    id: z.string(),
    description: z.string().describe("A description of the goal"),
    success_criteria: z.array(z.string()).describe("The criteria for success"),
    dependencies: z.array(z.string()).describe("The dependencies of the goal"),
    priority: z.number().min(1).max(10).describe("The priority of the goal"),
    required_resources: z
      .array(z.string())
      .describe("The resources needed to achieve the goal"),
    estimated_difficulty: z
      .number()
      .min(1)
      .max(10)
      .describe("The estimated difficulty of the goal"),
    tasks: z
      .array(taskSchema)
      .describe(
        "The tasks to achieve the goal. This is where you build potential tasks you need todo, based on your understanding of what you can do. These are actions."
      ),
  })
  .describe("A goal to be achieved");

/**
 * Defines the hierarchical goal planning structure with three time horizons
 */
export const goalPlanningSchema = z.object({
  long_term: z
    .array(goalSchema)
    .describe("Strategic goals that are the main goals you want to achieve"),
  medium_term: z
    .array(goalSchema)
    .describe(
      "Tactical goals that will require many short term goals to achieve"
    ),
  short_term: z
    .array(goalSchema)
    .describe(
      "Immediate actionable goals that will require a few tasks to achieve"
    ),
});

// ==========================================
// MODEL AND CONTAINER SETUP
// ==========================================

// Create a dependency injection container for services
const container = createContainer();

// Register Tavily search service
container.singleton("tavily", () => {
  return tavily({
    apiKey: process.env.TAVILY_API_KEY!,
  });
});

// ==========================================
// CONTEXT DEFINITION
// ==========================================

/**
 * Template for the goal manager context
 * This provides structure for the LLM to understand the current state
 */
const template = `
Goal: {{goal}} 
Tasks: {{tasks}}
Current Task: {{currentTask}}

<goal_planning_rules>
1. Break down the objective into hierarchical goals
2. Each goal must have clear success criteria
3. Identify dependencies between goals
4. Prioritize goals (1-10) based on urgency and impact
5. short term goals should be given a priority of 10
6. Ensure goals are achievable given the current context
7. Consider past experiences when setting goals
8. Use available game state information to inform strategy

# Each goal must include:
- id: Unique temporary ID used in dependencies
- description: Clear goal statement
- success_criteria: Array of specific conditions for completion
- dependencies: Array of prerequisite goal IDs (empty for initial goals)
- priority: Number 1-10 (10 being highest)
- required_resources: Array of resources needed (based on game state)
- estimated_difficulty: Number 1-10 based on past experiences
</goal_planning_rules>
`;

// Type definition for the goal planning schema
type Goal = z.infer<typeof goalPlanningSchema>;

/**
 * Context for managing goals and tasks
 * This maintains the state of goals and provides rendering for the LLM
 */
const goalContexts = context({
  type: "goal-manager",
  schema: z.object({
    id: string(),
  }),

  key({ id }) {
    return id;
  },

  create(state) {
    return {
      goal: null as null | Goal,
      tasks: [],
      currentTask: null,
    };
  },

  render({ memory }) {
    return render(template, {
      goal: memory.goal ?? "NONE",
      tasks: memory?.tasks?.join("\n"),
      currentTask: memory?.currentTask ?? "NONE",
    });
  },
});

// Type for the goal context memory
type GoalContextMemory = InferContextMemory<typeof goalContexts>;

// ==========================================
// ACTIONS DEFINITION
// ==========================================

/**
 * Create the Dreams agent with all necessary components
 */
createDreams({
  logger: LogLevel.INFO,
  debugger: async (contextId, keys, data) => {
    const [type, id] = keys;
    await Bun.write(`./logs/tasks/${contextId}/${id}-${type}.md`, data);
  },
  model: anthropic("claude-3-7-sonnet-latest"),
  extensions: [cliExtension, deepResearch],
  context: goalContexts,
  container,
  actions: [
    /**
     * Action to decompose a goal into executable tasks
     */
    action({
      name: "decomposeGoal",
      description: "Decompose a goal into executable tasks",
      schema: {
        goalId: z.string().describe("ID of the goal to decompose"),
        goalType: z
          .enum(["long_term", "medium_term", "short_term"])
          .describe("Type of goal"),
      },
      handler(data, ctx, agent) {
        const agentMemory = ctx.agentMemory as GoalContextMemory;

        if (!agentMemory.goal) {
          throw new Error("No goals have been set yet");
        }

        const goalType = data.goalType;
        const goalId = data.goalId;

        // Find the goal in the specified category
        const goal = agentMemory.goal[goalType].find(
          (g: any) => g.id === goalId
        );

        if (!goal) {
          throw new Error(
            `Goal with ID ${goalId} not found in ${goalType} goals`
          );
        }

        // Return the goal for task decomposition
        return {
          goal,
          message: `Ready to decompose goal: ${goal.description}`,
        };
      },
    }),

    /**
     * Action to set the complete goal plan
     */
    action({
      name: "setGoalPlan",
      description: "Set the complete goal plan",
      schema: z.object({ goal: goalPlanningSchema }),
      handler(data, ctx, agent) {
        const agentMemory = ctx.agentMemory as GoalContextMemory;
        agentMemory.goal = data.goal;
        return {
          plan: data.goal,
          message: "Goal plan has been set successfully",
        };
      },
    }),

    /**
     * Action to update a goal's state or properties
     */
    action({
      name: "updateGoal",
      description: "Update a goal's state or properties",
      schema: z.object({
        goalId: z.string().describe("ID of the goal to update"),
        goalType: z
          .enum(["long_term", "medium_term", "short_term"])
          .describe("Type of goal"),
        updates: goalSchema.partial().describe("Properties to update"),
      }),
      handler(data, ctx, agent) {
        const agentMemory = ctx.agentMemory as GoalContextMemory;

        if (!agentMemory.goal) {
          throw new Error("No goals have been set yet");
        }

        const goalType = data.goalType;
        const goalId = data.goalId;

        // Find the goal in the specified category
        const goalIndex = agentMemory.goal[goalType].findIndex(
          (g) => g.id === goalId
        );

        if (goalIndex === -1) {
          throw new Error(
            `Goal with ID ${goalId} not found in ${goalType} goals`
          );
        }

        // Update the goal with the provided updates
        agentMemory.goal[goalType][goalIndex] = {
          ...agentMemory.goal[goalType][goalIndex],
          ...data.updates,
        };

        return {
          updatedGoal: agentMemory.goal[goalType][goalIndex],
          message: `Goal ${goalId} has been updated successfully`,
        };
      },
    }),

    /**
     * Action to query Eternum game context
     */
    action({
      name: "queryEternum",
      description:
        "This will tell you everything you need to know about Eternum for how to win the game",
      schema: z.object({ query: z.string() }),
      handler(call, ctx, agent) {
        return {
          data: {
            result: ETERNUM_CONTEXT,
          },
          timestamp: Date.now(),
        };
      },
    }),

    /**
     * Action to query Eternum GraphQL API for game state
     */
    action({
      name: "Query:Eternum:Graphql",
      description: "Search Eternum GraphQL API",
      schema: z.object({
        query: z.string().describe(`
            query GetRealmDetails {
  s0EternumResourceModels(where: { entity_id: ENTITY_ID }, limit: 100) {
    edges {
      node {
          resource_type
          balance
      }
    }
  }
  s0EternumBuildingModels(where: { outer_col: X, outer_row: Y }) {
    edges {
      node {
          category
          entity_id
          inner_col
          inner_row
      }
    }
  }
}`),
      }),
      async handler(data, ctx, agent) {
        const result = await fetchGraphQL(
          "https://api.cartridge.gg/x/eternum-sepolia/torii/graphql",
          data.query
        );

        if (result instanceof Error) {
          return {
            error: result.message,
          };
        }

        return {
          data: {
            result: result,
          },
          timestamp: Date.now(),
        };
      },
    }),
  ],

  // ==========================================
  // OUTPUTS DEFINITION
  // ==========================================

  outputs: {
    /**
     * Output to update the goal state
     */
    "goal-manager:state": output({
      description:
        "Use this when you need to update the goals. Use the goal id to update the goal. You should attempt the goal then call this to update the goal.",
      instructions: "Increment the state of the goal manager",
      schema: z.object({
        type: z
          .enum(["SET", "UPDATE"])
          .describe("SET to set the goals. UPDATE to update a goal."),
        goal: goalSchema,
      }),
      handler: async (call, ctx, agent) => {
        console.log("handler", { call, ctx, agent });

        return {
          data: {
            goal: "",
          },
          timestamp: Date.now(),
        };
      },
    }),
  },
}).start({
  id: "game",
});

--- End File: examples/tasks/example-task.ts ---

--- File: examples/tasks/package.json ---
{
  "name": "tasks",
  "module": "index.ts",
  "type": "module",
  "private": true,
  "devDependencies": {
    "@types/bun": "latest"
  },
  "peerDependencies": {
    "typescript": "^5"
  },
  "dependencies": {
    "@ai-sdk/anthropic": "^1.1.15",
    "@ai-sdk/openai": "^1.2.1",
    "@ai-sdk/groq": "^1.1.12",
    "@daydreamsai/cli": "workspace:*",
    "@daydreamsai/core": "workspace:*",
    "@tavily/core": "^0.3.1",
    "zod": "^3.24.2"
  }
}

--- End File: examples/tasks/package.json ---

--- File: examples/telegram/index.ts ---
import { createGroq } from "@ai-sdk/groq";
import { createDreams, LogLevel, validateEnv } from "@daydreamsai/core";
import { telegram } from "@daydreamsai/telegram";
import { deepResearch } from "../deep-research/research";
import { z } from "zod";
import { searchWebAction } from "../actions";

const env = validateEnv(
  z.object({
    TELEGRAM_TOKEN: z.string().min(1, "TELEGRAM_TOKEN is required"),
    GROQ_API_KEY: z.string().min(1, "GROQ_API_KEY is required"),
    TAVILY_API_KEY: z.string().min(1, "TAVILY_API_KEY is required"),
    OPENAI_API_KEY: z.string().min(1, "OPENAI_API_KEY is required"),
  })
);

const groq = createGroq({
  apiKey: env.GROQ_API_KEY!,
});

createDreams({
  logLevel: LogLevel.DEBUG,
  model: groq("deepseek-r1-distill-llama-70b"),
  extensions: [telegram, deepResearch],
}).start();

--- End File: examples/telegram/index.ts ---

--- File: examples/telegram/package.json ---
{
  "name": "telegram",
  "module": "index.ts",
  "type": "module",
  "private": true,
  "devDependencies": {
    "@types/bun": "latest"
  },
  "peerDependencies": {
    "typescript": "^5"
  },
  "dependencies": {
    "@ai-sdk/groq": "^1.1.12",
    "@daydreamsai/core": "workspace:*",
    "@daydreamsai/telegram": "workspace:*",
    "@daydreamsai/cli": "workspace:*",
    "zod": "^3.24.2"
  }
}

--- End File: examples/telegram/package.json ---

--- File: examples/twitter/index.ts ---
import { createGroq } from "@ai-sdk/groq";
import { twitter } from "@daydreamsai/twitter";
import { createDreams, LogLevel, validateEnv } from "@daydreamsai/core";
import { z } from "zod";

const env = validateEnv(
  z.object({
    GROQ_API_KEY: z.string().min(1, "GROQ_API_KEY is required"),
    TWITTER_USERNAME: z.string().min(1, "TWITTER_USERNAME is required"),
    TWITTER_PASSWORD: z.string().min(1, "TWITTER_PASSWORD is required"),
    TWITTER_EMAIL: z.string().min(1, "TWITTER_EMAIL is required"),
    OPENAI_API_KEY: z.string().min(1, "OPENAI_API_KEY is required"),
  })
);

const groq = createGroq({
  apiKey: env.GROQ_API_KEY!,
});

const agent = createDreams({
  logLevel: LogLevel.DEBUG,
  model: groq("deepseek-r1-distill-llama-70b"),
  extensions: [twitter],
});

// Start the agent
await agent.start();

--- End File: examples/twitter/index.ts ---

--- File: examples/twitter/package.json ---
{
  "name": "twitter",
  "module": "index.ts",
  "type": "module",
  "private": true,
  "devDependencies": {
    "@types/bun": "latest"
  },
  "peerDependencies": {
    "typescript": "^5"
  },
  "dependencies": {
    "@ai-sdk/groq": "^1.1.12",
    "@daydreamsai/core": "workspace:*",
    "@daydreamsai/twitter": "workspace:*",
    "@daydreamsai/cli": "workspace:*",
    "zod": "^3.24.2"
  }
}

--- End File: examples/twitter/package.json ---

--- File: package.json ---
{
  "name": "daydreams",
  "version": "0.0.0",
  "workspaces": [
    "packages/*",
    "clients/*",
    "examples/*"
  ],
  "scripts": {
    "test": "bun run packages/core",
    "build:packages": "./scripts/build.sh",
    "build:packages:watch": "./scripts/build.sh --watch",
    "release": "./scripts/release.sh",
    "release:dry-run": "./scripts/release.sh --dry-run",
    "clean": "./scripts/clean.sh",
    "clean:dry-run": "./scripts/clean.sh --dry-run",
    "clean:deps": "./scripts/clean.sh --deps-only",
    "clean:builds": "./scripts/clean.sh --builds-only",
    "prettier-check": "pnpx prettier --check packages",
    "prettier": "pnpx prettier --write packages",
    "knip": "knip",
    "docs:dev": "cd docs && bun run dev",
    "docs:build": "cd docs && bun run docs:build",
    "docs:start": "cd docs && bun run start"
  },
  "devDependencies": {
    "@types/bun": "^1.2.2",
    "@types/react": "^18.3.18",
    "@types/react-dom": "^18.3.5",
    "knip": "^5.43.6",
    "typedoc": "^0.27.6",
    "typedoc-plugin-frontmatter": "^1.1.2",
    "typedoc-plugin-markdown": "^4.4.1",
    "typescript": "^5.8.2"
  },
  "resolutions": {
    "@mysten/sui": "1.7.0"
  },
  "dependencies": {
    "@ai-sdk/anthropic": "^1.2.3",
    "@ai-sdk/groq": "^1.2.2",
    "@ai-sdk/openai": "^1.3.5",
    "@ai-sdk/provider": "^1.1.0",
    "@ai-sdk/ui-utils": "^1.2.3",
    "ai": "^4.2.9"
  }
}

--- End File: package.json ---

--- File: packages/chroma/package.json ---
{
  "name": "@daydreamsai/chromadb",
  "version": "0.3.6",
  "type": "module",
  "main": "./dist/index.js",
  "module": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "exports": {
    "./package.json": "./package.json",
    ".": {
      "types": "./dist/index.d.ts",
      "require": "./dist/index.js",
      "import": "./dist/index.js"
    }
  },
  "devDependencies": {
    "@types/bun": "latest",
    "tsup": "^8.3.6",
    "vitest": "^3.0.5"
  },
  "scripts": {
    "test": "vitest",
    "build": "tsup --dts-resolve"
  },
  "dependencies": {
    "@daydreamsai/core": "workspace:*",
    "chromadb": "^1.10.5",
    "zod": "^3.24.2"
  }
}

--- End File: packages/chroma/package.json ---

--- File: packages/chroma/src/chroma.ts ---
/**
 * Imports required dependencies from chromadb and local types
 */
import {
  ChromaClient,
  Collection,
  OpenAIEmbeddingFunction,
  type IEmbeddingFunction,
} from "chromadb";
import { DefaultEmbeddingFunction } from "chromadb";
import type { InferContextMemory, VectorStore } from "@daydreamsai/core";

/**
 * Implementation of VectorStore using ChromaDB as the backend
 */
export class ChromaVectorStore implements VectorStore {
  private client: ChromaClient;
  private collection!: Collection;
  private embedder: IEmbeddingFunction;

  /**
   * Creates a new ChromaVectorStore instance
   * @param collectionName - Name of the ChromaDB collection to use (defaults to "default")
   * @param connection - Optional connection string for ChromaDB
   * @param embedder - Optional custom embedding function implementation
   */
  constructor(
    collectionName: string = "default",
    connection?: string,
    embedder?: IEmbeddingFunction
  ) {
    this.embedder =
      embedder || process.env.OPENAI_API_KEY
        ? new OpenAIEmbeddingFunction({
            openai_api_key: process.env.OPENAI_API_KEY!,
            openai_model: "text-embedding-3-small",
          })
        : new DefaultEmbeddingFunction();

    this.client = new ChromaClient({
      path: connection,
    });
    this.initCollection(collectionName);
  }

  /**
   * Initializes or retrieves the ChromaDB collection
   * @param collectionName - Name of the collection to initialize
   */
  private async initCollection(collectionName: string) {
    this.collection = await this.client.getOrCreateCollection({
      name: collectionName,
      embeddingFunction: this.embedder,
      metadata: {
        description: "Memory storage for AI consciousness",
      },
    });
  }

  /**
   * Adds or updates documents in the vector store
   * @param contextId - Unique identifier for the context
   * @param data - Array of documents to store
   */
  async upsert(
    contextId: string,
    data: InferContextMemory<any>[]
  ): Promise<void> {
    if (data.length === 0) return;

    // Generate IDs for the documents
    const ids = data.map((_, index) => `doc_${Date.now()}_${index}`);

    // Convert documents to strings if they aren't already
    const documents = data.map((item) =>
      typeof item === "string" ? item : JSON.stringify(item)
    );

    await this.collection.add({
      ids,
      documents,
      metadatas: [
        {
          contextId: contextId,
          timestamp: Date.now(),
        },
      ],
    });
  }

  /**
   * Searches for similar documents in the vector store
   * @param contextId - Context to search within
   * @param query - Query text to search for
   * @returns Array of matching documents
   */
  async query(contextId: string, query: string): Promise<any[]> {
    const results = await this.collection.query({
      queryTexts: [query],
      nResults: 5,
      where: {
        contextId: contextId,
      },
    });

    return results.documents[0] || [];
  }

  /**
   * Creates a new index in ChromaDB
   * @param indexName - Name of the index to create
   */
  async createIndex(indexName: string): Promise<void> {
    await this.client.getOrCreateCollection({
      name: indexName,
      embeddingFunction: this.embedder,
    });
  }

  /**
   * Deletes an existing index from ChromaDB
   * @param indexName - Name of the index to delete
   */
  async deleteIndex(indexName: string): Promise<void> {
    await this.collection.delete({
      where: {
        indexName: indexName,
      },
    });
  }
}

/**
 * Factory function to create a new ChromaVectorStore instance
 * @param collectionName - Name of the ChromaDB collection to use (defaults to "default")
 * @param connection - Optional connection string for ChromaDB
 * @param embedder - Optional custom embedding function implementation
 * @returns A new ChromaVectorStore instance
 */
export function createChromaVectorStore(
  collectionName: string = "default",
  connection?: string,
  embedder?: IEmbeddingFunction
) {
  return new ChromaVectorStore(collectionName, connection, embedder);
}

--- End File: packages/chroma/src/chroma.ts ---

--- File: packages/chroma/src/index.ts ---
export * from "./chroma";

--- End File: packages/chroma/src/index.ts ---

--- File: packages/cli/package.json ---
{
  "name": "@daydreamsai/cli",
  "version": "0.3.6",
  "type": "module",
  "main": "./dist/index.js",
  "module": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "exports": {
    "./package.json": "./package.json",
    ".": {
      "types": "./dist/index.d.ts",
      "require": "./dist/index.js",
      "import": "./dist/index.js"
    }
  },
  "devDependencies": {
    "@types/bun": "latest",
    "tsup": "^8.3.6",
    "vitest": "^3.0.5"
  },
  "scripts": {
    "test": "vitest",
    "build": "tsup --dts-resolve"
  },
  "peerDependencies": {
    "typescript": "^5.6.3"
  },
  "dependencies": {
    "@daydreamsai/core": "workspace:*",
    "zod": "^3.24.2"
  }
}

--- End File: packages/cli/package.json ---

--- File: packages/cli/src/cli.ts ---
import * as readline from "readline/promises";
import { service, context, input, extension, output } from "@daydreamsai/core";
import { z } from "zod";

export const readlineService = service({
  register(container) {
    container.singleton("readline", () =>
      readline.createInterface({
        input: process.stdin,
        output: process.stdout,
      })
    );
  },
});

export const cli = context({
  type: "cli",
  key: ({ user }) => user.toString(),
  schema: { user: z.string() },
  inputs: {
    "cli:message": input({
      async subscribe(send, { container }) {
        const rl = container.resolve<readline.Interface>("readline");

        const controller = new AbortController();

        while (!controller.signal.aborted) {
          const question = await rl.question("> ");
          if (question === "exit") {
            break;
          }
          console.log("User:", question);
          send(cli, { user: "admin" }, question);
        }

        return () => {
          controller.abort();
        };
      },
    }),
  },
  outputs: {
    "cli:message": output({
      description: "Send messages to the user",
      instructions: "Use plain text",
      schema: z.string(),
      handler(data) {
        console.log("Agent:", { data });
        return {
          data,
        };
      },
      examples: [
        `<output type="cli:message">Hi, How can I assist you today?</output>`,
      ],
    }),
  },
});

export const cliExtension = extension({
  name: "cli",
  contexts: {
    cli,
  },
  services: [readlineService],
});

--- End File: packages/cli/src/cli.ts ---

--- File: packages/cli/src/index.ts ---
export * from "./cli";

--- End File: packages/cli/src/index.ts ---

--- File: packages/core/package.json ---
{
  "name": "@daydreamsai/core",
  "version": "0.3.6",
  "type": "module",
  "main": "./dist/index.js",
  "module": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "exports": {
    "./package.json": "./package.json",
    ".": {
      "types": "./dist/index.d.ts",
      "require": "./dist/index.js",
      "import": "./dist/index.js"
    }
  },
  "publishConfig": {
    "main": "./dist/index.js",
    "module": "./dist/index.js",
    "types": "./dist/index.d.ts",
    "exports": {
      "./package.json": "./package.json",
      ".": {
        "types": "./dist/index.d.ts",
        "require": "./dist/index.js",
        "import": "./dist/index.js"
      }
    }
  },
  "devDependencies": {
    "@ai-sdk/anthropic": "^1.2.3",
    "@ai-sdk/groq": "^1.2.2",
    "@ai-sdk/openai": "^1.3.5",
    "@types/bun": "latest",
    "tsup": "^8.3.6",
    "vitest": "^3.0.5"
  },
  "peerDependencies": {
    "typescript": "^5.8.2"
  },
  "scripts": {
    "test": "vitest",
    "build": "tsup --dts-resolve"
  },
  "dependencies": {
    "@ai-sdk/provider": "^1.1.0",
    "@ai-sdk/ui-utils": "^1.2.3",
    "ai": "^4.2.9",
    "dotenv": "^16.4.7",
    "p-defer": "^4.0.1",
    "uuid": "^11.1.0",
    "zod": "^3.24.2",
    "zod-to-json-schema": "^3.24.1"
  }
}

--- End File: packages/core/package.json ---

--- File: packages/core/src/configs.ts ---
type ModelConfig = {
  assist?: boolean;
  prefix?: string;
  thinkTag?: string;
};

export const modelsResponseConfig: Record<string, ModelConfig> = {
  "o3-mini": {
    assist: false,
    prefix: "",
  },
  "claude-3-7-sonnet-20250219": {},
  "qwen-qwq-32b": {
    prefix: "",
  },
  // "google/gemini-2.0-flash-001": {},
  "deepseek-r1-distill-llama-70b": {
    prefix: "",
    assist: false,
  },
};

export const reasoningModels = [
  "claude-3-7-sonnet-20250219",
  "qwen-qwq-32b",
  "deepseek-r1-distill-llama-70b",
  "o3-mini",
];

--- End File: packages/core/src/configs.ts ---

--- File: packages/core/src/container.ts ---
/**
 * Represents a constructor function that creates an instance of type T.
 */
type Constructor<T> = new (...args: any[]) => T;

/**
 * Represents a factory function that creates an instance of type T using the container.
 */
type Factory<T> = (container: Container) => T;

/**
 * Represents any function type.
 */
type FunctionType = (...args: any[]) => any;

/**
 * Represents a dependency injection token that can be a string, symbol, constructor, or function.
 */
type Token = string | symbol | Constructor<any> | FunctionType;

/**
 * Interface for a dependency injection container.
 */
export interface Container {
  /**
   * Registers a factory function for a token.
   * Each time the token is resolved, the factory will be called to create a new instance.
   *
   * @param token - The token to register
   * @param factory - The factory function that creates the instance
   * @returns The container instance for chaining
   */
  register: <T>(token: Token, factory: Factory<T>) => Container;

  /**
   * Registers a singleton factory function for a token.
   * The factory will be called only once when the token is first resolved,
   * and the same instance will be returned for subsequent resolutions.
   *
   * @param token - The token to register
   * @param factory - The factory function that creates the singleton instance
   * @returns The container instance for chaining
   */
  singleton: <T>(token: Token, factory: Factory<T>) => Container;

  /**
   * Registers a pre-created instance for a token.
   *
   * @param token - The token to register
   * @param instance - The instance to register
   * @returns The container instance for chaining
   */
  instance: <T>(token: Token, instance: T) => Container;

  /**
   * Creates an alias for an existing token.
   *
   * @param aliasToken - The alias token (must be a string or symbol)
   * @param originalToken - The original token to alias
   * @returns The container instance for chaining
   */
  alias: (aliasToken: string | symbol, originalToken: Token) => Container;

  /**
   * Resolves a token to its registered instance.
   *
   * @param token - The token to resolve
   * @returns The resolved instance
   * @throws Error if no registration is found for the token
   */
  resolve: <T>(token: Token) => T;
}

/**
 * Creates a new dependency injection container.
 *
 * @returns A new Container instance
 *
 * @example
 * ```typescript
 * const container = createContainer();
 *
 * // Register a transient dependency
 * container.register('logger', () => new Logger());
 *
 * // Register a singleton
 * container.singleton('database', (c) => new Database(c.resolve('config')));
 *
 * // Register a pre-created instance
 * container.instance('config', { connectionString: 'mongodb://localhost:27017' });
 *
 * // Create an alias
 * container.alias('db', 'database');
 *
 * // Resolve dependencies
 * const db = container.resolve<Database>('db');
 * ```
 */
export const createContainer = (): Container => {
  const instances = new Map<Token, any>();
  const factories = new Map<Token, Factory<any>>();
  const singletons = new Set<Token>();
  const aliases = new Map<string | symbol, Token>();

  /**
   * Converts a token to a string representation for error messages.
   */
  const getTokenString = (token: Token): string => {
    if (typeof token === "string") return token;
    if (typeof token === "symbol") return token.toString();
    if (typeof token === "function") {
      return token.name || "anonymous function";
    }
    return "unknown token";
  };

  /**
   * Resolves a token to its original token if it's an alias.
   */
  const resolveToken = (token: Token): Token => {
    if (typeof token === "string" || typeof token === "symbol") {
      return aliases.get(token) || token;
    }
    return token;
  };

  const container: Container = {
    register: <T>(token: Token, factory: Factory<T>): Container => {
      factories.set(token, factory);
      instances.delete(token);
      return container;
    },

    singleton: <T>(token: Token, factory: Factory<T>): Container => {
      factories.set(token, factory);
      singletons.add(token);
      instances.delete(token);
      return container;
    },

    instance: <T>(token: Token, value: T): Container => {
      instances.set(token, value);
      factories.delete(token);
      singletons.delete(token);
      return container;
    },

    alias: (aliasToken: string | symbol, originalToken: Token): Container => {
      aliases.set(aliasToken, originalToken);
      return container;
    },

    resolve: <T>(token: Token): T => {
      const resolvedToken = resolveToken(token);

      if (instances.has(resolvedToken)) {
        return instances.get(resolvedToken);
      }

      const factory = factories.get(resolvedToken);
      if (!factory) {
        throw new Error(
          `No registration found for ${getTokenString(resolvedToken)}`
        );
      }

      if (singletons.has(resolvedToken)) {
        if (!instances.has(resolvedToken)) {
          instances.set(resolvedToken, factory(container));
        }
        return instances.get(resolvedToken);
      }

      return factory(container);
    },
  };

  return container;
};

--- End File: packages/core/src/container.ts ---

--- File: packages/core/src/context.ts ---
import { z, type ZodRawShape } from "zod";
import type {
  AnyAction,
  AnyAgent,
  AnyContext,
  AnyRef,
  Context,
  ContextConfig,
  ContextSettings,
  ContextState,
  InferSchemaArguments,
  Log,
  WorkingMemory,
} from "./types";
import { formatContextLog } from "./formatters";
import { memory } from "./utils";

/**
 * Creates a context configuration
 * @template Memory - Type of working memory
 * @template Args - Zod schema type for context arguments
 * @template Ctx - Type of context data
 * @template Exports - Type of exported data
 * @param ctx - Context configuration object
 * @returns Typed context configuration
 */

export function context<
  TMemory = any,
  Args extends z.ZodTypeAny | ZodRawShape = any,
  Ctx = any,
  Actions extends AnyAction[] = AnyAction[],
  Events extends Record<string, z.ZodTypeAny | z.ZodRawShape> = Record<
    string,
    z.ZodTypeAny | z.ZodRawShape
  >,
>(
  config: ContextConfig<TMemory, Args, Ctx, Actions, Events>
): Context<TMemory, Args, Ctx, Actions, Events> {
  const ctx: Context<TMemory, Args, Ctx, Actions, Events> = {
    ...config,
    setActions(actions) {
      Object.assign(ctx, { actions });
      return ctx as any;
    },
    setInputs(inputs) {
      ctx.inputs = inputs;
      return ctx;
    },
    setOutputs(outputs) {
      ctx.outputs = outputs;
      return ctx;
    },
    use(composer) {
      ctx.__composers = ctx.__composers?.concat(composer) ?? [composer];
      return ctx;
    },
  };

  return ctx;
}

/**
 * Retrieves and sorts working memory logs
 * @param memory - Working memory object
 * @param includeThoughts - Whether to include thought logs (default: true)
 * @returns Sorted array of memory logs
 */
export function getWorkingMemoryLogs(
  memory: Partial<WorkingMemory>,
  includeThoughts = true
): Log[] {
  return [
    ...(memory.inputs ?? []),
    ...(memory.outputs ?? []),
    ...(memory.calls ?? []),
    ...((includeThoughts ? memory.thoughts : undefined) ?? []),
    ...(memory.results ?? []),
    ...(memory.events ?? []),
  ].sort((a, b) => (a.timestamp > b.timestamp ? 1 : -1));
}

export function getWorkingMemoryAllLogs(
  memory: Partial<WorkingMemory>,
  includeThoughts = true
): AnyRef[] {
  return [
    ...(memory.inputs ?? []),
    ...(memory.outputs ?? []),
    ...(memory.calls ?? []),
    ...((includeThoughts ? memory.thoughts : undefined) ?? []),
    ...(memory.results ?? []),
    ...(memory.events ?? []),
    ...(memory.steps ?? []),
    ...(memory.runs ?? []),
  ].sort((a, b) => (a.timestamp >= b.timestamp ? 1 : -1));
}

export function formatWorkingMemory({
  memory,
  processed,
  size,
}: {
  memory: Partial<WorkingMemory>;
  processed: boolean;
  size?: number;
}) {
  let logs = getWorkingMemoryLogs(memory, false).filter(
    (i) => i.processed === processed
  );

  if (size) {
    logs = logs.slice(-size);
  }

  return logs.map((i) => formatContextLog(i)).flat();
}

/**
 * Creates a default working memory object
 * @returns Empty working memory with initialized arrays
 */
export function createWorkingMemory(): WorkingMemory {
  return {
    inputs: [],
    outputs: [],
    thoughts: [],
    calls: [],
    results: [],
    runs: [],
    steps: [],
    events: [],
  };
}

export function pushToWorkingMemory(workingMemory: WorkingMemory, ref: AnyRef) {
  switch (ref.ref) {
    case "action_call":
      workingMemory.calls.push(ref);
      break;
    case "action_result":
      workingMemory.results.push(ref);
      break;
    case "input":
      workingMemory.inputs.push(ref);
      break;
    case "output":
      workingMemory.outputs.push(ref);
      break;
    case "thought":
      workingMemory.thoughts.push(ref);
      break;
    case "event":
      workingMemory.events.push(ref);
      break;
    case "step":
      workingMemory.steps.push(ref);
      break;
    case "run":
      workingMemory.runs.push(ref);
      break;
    default:
      throw new Error("invalid ref");
  }
}

/**
 * Default working memory config
 * Provides a memory container with standard working memory structure
 */
export const defaultWorkingMemory = memory<WorkingMemory>({
  key: "working-memory",
  create: createWorkingMemory,
});

export function getContextId<TContext extends AnyContext>(
  context: TContext,
  args: z.infer<TContext["schema"]>
) {
  const key = context.key ? context.key(args) : undefined;
  return key ? [context.type, key].join(":") : context.type;
}

export async function createContextState<TContext extends AnyContext>({
  agent,
  context,
  args,
  contexts = [],
  settings: initialSettings = {},
}: {
  agent: AnyAgent;
  context: TContext;
  args: InferSchemaArguments<TContext["schema"]>;
  contexts?: string[];
  settings?: ContextSettings;
}): Promise<ContextState<TContext>> {
  const key = context.key ? context.key(args) : undefined;
  const id = key ? [context.type, key].join(":") : context.type;

  const settings: ContextSettings = {
    model: context.model,
    maxSteps: context.maxSteps,
    maxWorkingMemorySize: context.maxWorkingMemorySize,
    ...initialSettings,
  };

  const options = context.setup
    ? await context.setup(args, settings, agent)
    : {};

  const memory =
    (context.load
      ? await context.load(id, { options, settings })
      : await agent.memory.store.get(`memory:${id}`)) ??
    (context.create
      ? await Promise.try(
          context.create,
          { key, args, id, options, settings },
          agent
        )
      : {});

  return {
    id,
    key,
    args,
    options,
    context,
    memory,
    settings,
    contexts,
  };
}

export async function getContextWorkingMemory(
  agent: AnyAgent,
  contextId: string
) {
  let workingMemory = await agent.memory.store.get<WorkingMemory>(
    ["working-memory", contextId].join(":")
  );

  if (!workingMemory) {
    workingMemory = await defaultWorkingMemory.create();
    await agent.memory.store.set(
      ["working-memory", contextId].join(":"),
      workingMemory
    );
  }

  return workingMemory;
}

export async function saveContextWorkingMemory(
  agent: AnyAgent,
  contextId: string,
  workingMemory: WorkingMemory
) {
  return await agent.memory.store.set(
    ["working-memory", contextId].join(":"),
    workingMemory
  );
}

type ContextStateSnapshot = {
  id: string;
  type: string;
  args: any;
  key?: string;
  settings: Omit<ContextSettings, "model"> & { model?: string };
  contexts: string[];
};

export async function saveContextState(agent: AnyAgent, state: ContextState) {
  const { id, context, key, args, settings, contexts } = state;
  await agent.memory.store.set<ContextStateSnapshot>(`context:${id}`, {
    id,
    type: context.type,
    key,
    args,
    settings: {
      ...settings,
      model: settings.model?.modelId,
    },
    contexts,
  });

  if (state.context.save) {
    await state.context.save(state);
  } else {
    await agent.memory.store.set<any>(`memory:${id}`, state.memory);
  }
}
export async function loadContextState(
  agent: AnyAgent,
  context: AnyContext,
  contextId: string
): Promise<Omit<ContextState, "options" | "memory"> | null> {
  const state = await agent.memory.store.get<ContextStateSnapshot>(
    `context:${contextId}`
  );

  if (!state) return null;

  return {
    ...state,
    context,
    settings: {
      ...state?.settings,
      // todo: agent resolve model?
      model: undefined,
    },
  };
}

export async function saveContextsIndex(
  agent: AnyAgent,
  contextIds: Set<string>
) {
  await agent.memory.store.set<string[]>(
    "contexts",
    Array.from(contextIds.values())
  );
}

function getContextData(
  contexts: Map<string, ContextState>,
  contextId: string
) {
  // todo: verify type?
  if (contexts.has(contextId)) {
    const state = contexts.get(contextId)!;
    return {
      id: contextId,
      type: state.context.type,
      key: state.key,
      args: state.args,
      settings: state.settings,
    };
  }

  const [type, key] = contextId.split(":");

  return {
    id: contextId,
    type,
    key,
  };
}

export function getContexts(
  contextIds: Set<string>,
  contexts: Map<string, ContextState>
) {
  return Array.from(contextIds.values())
    .filter((t) => !!t)
    .map((id) => getContextData(contexts, id));
}

export async function deleteContext(agent: AnyAgent, contextId: string) {
  await agent.memory.store.delete(`context:${contextId}`);
  await agent.memory.store.delete(`memory:${contextId}`);
  await agent.memory.store.delete(`working-memory:${contextId}`);
}

--- End File: packages/core/src/context.ts ---

--- File: packages/core/src/dreams.ts ---
import { z } from "zod";
import type {
  Agent,
  AnyContext,
  Config,
  Debugger,
  Subscription,
  ContextState,
  Episode,
  Registry,
  InputRef,
  WorkingMemory,
  Log,
  AnyRef,
  LogChunk,
} from "./types";
import { Logger } from "./logger";
import { createContainer } from "./container";
import { createServiceManager } from "./serviceProvider";
import { TaskRunner } from "./task";
import {
  getContextId,
  createContextState,
  getContextWorkingMemory,
  saveContextWorkingMemory,
  saveContextState,
  saveContextsIndex,
  loadContextState,
  getContexts,
  deleteContext,
} from "./context";
import { createMemoryStore } from "./memory";
import { createMemory } from "./memory";
import { createVectorStore } from "./memory/base";
import { runGenerate } from "./tasks";
import { exportEpisodesAsTrainingData } from "./memory/utils";
import { LogLevel } from "./types";
import { randomUUIDv7, tryAsync } from "./utils";
import { createContextStreamHandler, handleStream } from "./streaming";
import { mainPrompt, promptTemplate } from "./prompts/main";
import { createEngine } from "./engine";
import type { DeferredPromise } from "p-defer";

export function createDreams<TContext extends AnyContext = AnyContext>(
  config: Config<TContext>
): Agent<TContext> {
  let booted = false;

  const inputSubscriptions = new Map<string, Subscription>();

  const contextIds = new Set<string>();
  const contexts = new Map<string, ContextState>();
  const contextsRunning = new Map<
    string,
    {
      defer: DeferredPromise<AnyRef[]>;
      controller: AbortController;
      push: (log: Log) => Promise<void>;
    }
  >();

  const workingMemories = new Map<string, WorkingMemory>();

  const ctxSubscriptions = new Map<
    string,
    Set<(ref: AnyRef, done: boolean) => void>
  >();

  const __ctxChunkSubscriptions = new Map<
    string,
    Set<(chunk: LogChunk) => void>
  >();

  // todo register everything into registry, remove from agent
  const registry: Registry = {
    contexts: new Map(),
    actions: new Map(),
    outputs: new Map(),
    inputs: new Map(),
    extensions: new Map(),
    models: new Map(),
    prompts: new Map(),
  };

  registry.prompts.set("step", promptTemplate);

  const {
    inputs = {},
    outputs = {},
    events = {},
    actions = [],
    experts = {},
    services = [],
    extensions = [],
    model,
    reasoningModel,
    exportTrainingData,
    trainingDataPath,
  } = config;

  const container = config.container ?? createContainer();

  const taskRunner = config.taskRunner ?? new TaskRunner(3);

  const logger =
    config.logger ??
    new Logger({
      level: config.logLevel ?? LogLevel.INFO,
    });

  if (config.logger && config.logLevel !== undefined) {
    logger.configure({ level: config.logLevel });
  }

  container.instance("logger", logger);

  const debug: Debugger = (...args) => {
    if (!config.debugger) return;
    try {
      config.debugger(...args);
    } catch {
      console.log("debugger failed");
    }
  };

  const serviceManager = createServiceManager(container);

  for (const service of services) {
    serviceManager.register(service);
  }

  if (config.contexts) {
    for (const ctx of config.contexts) {
      registry.contexts.set(ctx.type, ctx);
    }
  }

  for (const extension of extensions) {
    if (extension.inputs) Object.assign(inputs, extension.inputs);
    if (extension.outputs) Object.assign(outputs, extension.outputs);
    if (extension.events) Object.assign(events, extension.events);
    if (extension.actions) actions.push(...extension.actions);
    if (extension.services) {
      for (const service of extension.services) {
        serviceManager.register(service);
      }
    }

    if (extension.contexts) {
      for (const context of Object.values(extension.contexts)) {
        registry.contexts.set(context.type, context);
      }
    }
  }

  const agent: Agent<TContext> = {
    logger,
    inputs,
    outputs,
    events,
    actions,
    experts,
    memory:
      config.memory ?? createMemory(createMemoryStore(), createVectorStore()),
    container,
    model,
    reasoningModel,
    taskRunner,
    debugger: debug,
    context: config.context ?? undefined,
    exportTrainingData,
    trainingDataPath,
    registry,
    emit: (event: string, data: any) => {
      logger.debug("agent:event", event, data);
    },

    isBooted() {
      return booted;
    },

    subscribeContext(contextId, handler) {
      if (!ctxSubscriptions.has(contextId)) {
        ctxSubscriptions.set(contextId, new Set());
      }

      const subs = ctxSubscriptions.get(contextId)!;

      if (subs.has(handler)) {
        throw new Error("handler already registered");
      }

      subs.add(handler);

      return () => {
        subs.delete(handler);
      };
    },

    __subscribeChunk(contextId, handler) {
      if (!__ctxChunkSubscriptions.has(contextId)) {
        __ctxChunkSubscriptions.set(contextId, new Set());
      }

      const subs = __ctxChunkSubscriptions.get(contextId)!;

      if (subs.has(handler)) {
        throw new Error("handler already registered");
      }

      subs.add(handler);

      return () => {
        subs.delete(handler);
      };
    },

    async getAgentContext() {
      return agent.context
        ? await agent.getContext({
            context: agent.context,
            args: contexts.get("agent:context")!.args,
          })
        : undefined;
    },

    async getContexts() {
      return getContexts(contextIds, contexts);
    },

    async getContextById<TContext extends AnyContext>(
      id: string
    ): Promise<ContextState<TContext> | null> {
      if (contexts.has(id)) return contexts.get(id)! as ContextState<TContext>;

      const [type] = id.split(":");

      const context = registry.contexts.get(type) as TContext | undefined;

      if (context && contextIds.has(id)) {
        const stateSnapshot = await loadContextState(agent, context, id);

        if (stateSnapshot) {
          const state = await createContextState({
            agent,
            context,
            args: stateSnapshot.args,
            settings: stateSnapshot.settings,
            contexts: stateSnapshot.contexts,
          });

          await this.saveContext(state);

          return state;
        }
      }

      return null;
    },

    async getContext(params) {
      if (!registry.contexts.has(params.context.type))
        registry.contexts.set(params.context.type, params.context);

      const ctxSchema = params.context.schema
        ? "parse" in params.context.schema
          ? params.context.schema
          : z.object(params.context.schema)
        : undefined;

      const args = ctxSchema ? ctxSchema.parse(params.args) : {};
      const id = getContextId(params.context, args);

      if (!contexts.has(id) && contextIds.has(id)) {
        const stateSnapshot = await loadContextState(agent, params.context, id);

        if (stateSnapshot) {
          await this.saveContext(
            await createContextState({
              agent,
              context: params.context,
              args: params.args,
              settings: stateSnapshot.settings,
              contexts: stateSnapshot.contexts,
            })
          );
        }
      }

      if (!contexts.has(id)) {
        await this.saveContext(
          await createContextState({
            agent,
            context: params.context,
            args: params.args,
          })
        );
      }

      return contexts.get(id)! as ContextState<typeof params.context>;
    },

    async loadContext(params) {
      if (!registry.contexts.has(params.context.type))
        registry.contexts.set(params.context.type, params.context);

      const ctxSchema =
        "parse" in params.context.schema
          ? params.context.schema
          : z.object(params.context.schema);

      const args = ctxSchema.parse(params.args);
      const id = getContextId(params.context, args);

      if (!contexts.has(id) && contextIds.has(id)) {
        const stateSnapshot = await loadContextState(agent, params.context, id);

        if (stateSnapshot) {
          await this.saveContext(
            await createContextState({
              agent,
              context: params.context,
              args: params.args,
              settings: stateSnapshot.settings,
              contexts: stateSnapshot.contexts,
            })
          );
        }
      }

      return (contexts.get(id) as ContextState<typeof params.context>) ?? null;
    },

    async saveContext(ctxState, workingMemory) {
      contextIds.add(ctxState.id);
      contexts.set(ctxState.id, ctxState);

      await saveContextState(agent, ctxState);

      if (workingMemory) {
        workingMemories.set(ctxState.id, workingMemory);
        await saveContextWorkingMemory(agent, ctxState.id, workingMemory);
      }

      await saveContextsIndex(agent, contextIds);

      return true;
    },

    getContextId(params) {
      // logger.trace("agent:getContextId", "Getting context id", params);
      return getContextId(params.context, params.args);
    },

    async getWorkingMemory(contextId) {
      logger.trace("agent:getWorkingMemory", "Getting working memory", {
        contextId,
      });

      if (!workingMemories.has(contextId)) {
        workingMemories.set(
          contextId,
          await getContextWorkingMemory(agent, contextId)
        );
      }

      return workingMemories.get(contextId)!;
    },

    async deleteContext(contextId) {
      //todo: handle if its running;

      contexts.delete(contextId);
      contextIds.delete(contextId);

      contextsRunning.delete(contextId);
      workingMemories.delete(contextId);

      await deleteContext(agent, contextId);

      await saveContextsIndex(agent, contextIds);
    },

    async start(args) {
      if (booted) return agent;
      logger.info("agent:start", "Starting agent", { args, booted });

      booted = true;

      logger.debug("agent:start", "Booting services");
      await serviceManager.bootAll();

      logger.debug("agent:start", "Installing extensions", {
        count: extensions.length,
      });

      for (const extension of extensions) {
        if (extension.install) await tryAsync(extension.install, agent);
      }

      logger.debug("agent:start", "Setting up inputs", {
        count: Object.keys(agent.inputs).length,
      });

      const inputs = {
        ...agent.inputs,
      };

      for (const ctx of registry.contexts.values()) {
        if (ctx.inputs) Object.assign(inputs, ctx.inputs);
      }

      for (const [type, input] of Object.entries(inputs)) {
        if (input.install) {
          logger.trace("agent:start", "Installing input", { type });
          await tryAsync(input.install, agent);
        }

        if (input.subscribe) {
          logger.trace("agent:start", "Subscribing to input", { type });
          let subscription = await tryAsync<Subscription>(
            input.subscribe,
            (context: any, args: any, data: any) => {
              logger.debug("agent", "input", { context, args, data });
              agent
                .send({
                  context,
                  input: { type, data },
                  args,
                })
                .catch((err) => {
                  logger.error("agent:input", "error", err);
                });
            },
            agent
          );

          if (subscription) inputSubscriptions.set(type, subscription);
        }
      }

      logger.debug("agent:start", "Setting up outputs", {
        count: Object.keys(outputs).length,
      });

      for (const [type, output] of Object.entries(outputs)) {
        if (output.install) {
          logger.trace("agent:start", "Installing output", { type });
          await tryAsync(output.install, agent);
        }
      }

      logger.debug("agent:start", "Setting up actions", {
        count: actions.length,
      });

      for (const action of actions) {
        if (action.install) {
          logger.trace("agent:start", "Installing action", {
            name: action.name,
          });
          await tryAsync(action.install, agent);
        }
      }

      logger.debug("agent:start", "Loading saved contexts");
      const savedContexts = await agent.memory.store.get<string[]>("contexts");

      if (savedContexts) {
        logger.trace("agent:start", "Restoring saved contexts", {
          count: savedContexts.length,
        });

        for (const id of savedContexts) {
          contextIds.add(id);
        }
      }

      if (agent.context) {
        logger.debug("agent:start", "Setting up agent context", {
          type: agent.context.type,
        });

        const agentState = await agent.getContext({
          context: agent.context,
          args: args!,
        });

        contexts.set("agent:context", agentState);
      }

      logger.info("agent:start", "Agent started successfully");
      return agent;
    },

    async stop() {
      logger.info("agent:stop", "Stopping agent");
    },

    async run(params) {
      const { context, args, outputs, handlers, abortSignal } = params;
      if (!booted) {
        logger.error("agent:run", "Agent not booted");
        throw new Error("Not booted");
      }

      const model =
        params.model ?? context.model ?? config.reasoningModel ?? config.model;

      if (!model) throw new Error("no model");

      logger.info("agent:run", "Running context", {
        contextType: context.type,
        hasArgs: !!args,
        hasCustomOutputs: !!outputs,
        hasHandlers: !!handlers,
      });

      const ctxId = agent.getContextId({ context, args });

      // try to move this to state
      // we need this here now because its needed to create the handler
      // and we will use that state from contextsRunning so we need to wait before checking and creating
      const ctxState = await agent.getContext({ context, args });
      const workingMemory = await agent.getWorkingMemory(ctxId);
      const agentCtxState = await agent.getAgentContext();

      // todo: allow to control what happens when new input is sent while the ctx is running
      // context.onInput?
      // we should allow to abort the current run, or just push it to current run
      // state.controller.abort()
      if (contextsRunning.has(ctxId)) {
        logger.debug("agent:run", "Context already running", {
          id: ctxId,
        });

        const { defer, push } = contextsRunning.get(ctxId)!;
        params.chain?.forEach((el) => push(el));
        return defer.promise;
      }

      logger.debug("agent:run", "Added context to running set", {
        id: ctxId,
      });

      if (!ctxSubscriptions.has(ctxId)) {
        ctxSubscriptions.set(ctxId, new Set());
      }

      if (!__ctxChunkSubscriptions.has(ctxId)) {
        __ctxChunkSubscriptions.set(ctxId, new Set());
      }

      const engine = createEngine({
        agent,
        ctxState,
        workingMemory,
        handlers,
        agentCtxState,
        subscriptions: ctxSubscriptions.get(ctxId)!,
        __chunkSubscriptions: __ctxChunkSubscriptions.get(ctxId)!,
      });

      contextsRunning.set(ctxId, {
        controller: engine.controller,
        push: engine.push,
        defer: engine.state.defer,
      });

      const { streamState, streamHandler, tags, __streamChunkHandler } =
        createContextStreamHandler({
          abortSignal,
          pushLog(log, done) {
            engine.push(log, done, false);
          },
          __pushLogChunk(chunk) {
            engine.pushChunk(chunk);
          },
        });

      let maxSteps = 0;

      function getMaxSteps() {
        return engine.state.contexts.reduce(
          (maxSteps, ctxState) =>
            Math.max(
              maxSteps,
              ctxState.settings.maxSteps ?? ctxState.context.maxSteps ?? 0
            ),
          5
        );
      }

      await engine.setParams({
        actions: params.actions,
        outputs: params.outputs,
        contexts: params.contexts,
      });

      let stepRef = await engine.start();

      //todo: pull unprocessed, unfinished steps/runs

      if (params.chain) {
        for (const log of params.chain) {
          await engine.push(log);
        }
      }

      await engine.settled();

      const { state } = engine;

      while ((maxSteps = getMaxSteps()) >= state.step) {
        logger.info("agent:run", `Starting step ${state.step}/${maxSteps}`, {
          contextId: ctxState.id,
        });

        try {
          if (state.step > 1) {
            stepRef = await engine.nextStep();
            streamState.index++;
          }

          const promptData = mainPrompt.formatter({
            contexts: state.contexts,
            actions: state.actions,
            outputs: state.outputs,
            workingMemory,
            chainOfThoughtSize: 0,
            maxWorkingMemorySize: ctxState.settings.maxWorkingMemorySize,
          });

          const prompt = mainPrompt.render(promptData);

          stepRef.data.prompt = prompt;

          let streamError: any = null;

          const unprocessed = [
            ...workingMemory.inputs.filter((i) => i.processed === false),
            ...state.chain.filter((i) => i.processed === false),
          ];

          const { stream, getTextResponse } = await taskRunner.enqueueTask(
            runGenerate,
            {
              model,
              prompt,
              workingMemory,
              logger,
              onError: (error) => {
                streamError = error;
                // state.errors.push(error);
              },
            },
            {
              abortSignal,
            }
          );

          logger.debug("agent:run", "Processing stream", { step: state.step });

          await handleStream(
            stream,
            streamState.index,
            tags,
            streamHandler,
            __streamChunkHandler
          );

          if (streamError) {
            throw streamError;
          }

          const response = await getTextResponse();
          stepRef.data.response = response;

          unprocessed.forEach((i) => {
            i.processed = true;
          });

          logger.debug("agent:run", "Waiting for action calls to complete", {
            pendingCalls: state.promises.length,
          });

          await engine.settled();

          stepRef.processed = true;

          await saveContextWorkingMemory(agent, ctxState.id, workingMemory);

          await Promise.all(
            state.contexts.map((state) =>
              state.context.onStep?.(
                {
                  ...state,
                  workingMemory,
                },
                agent
              )
            )
          );

          await Promise.all(
            state.contexts.map((state) => agent.saveContext(state))
          );

          if (!engine.shouldContinue()) break;

          state.step++;
        } catch (error) {
          console.error(error);

          await Promise.allSettled(
            [
              saveContextWorkingMemory(agent, ctxState.id, workingMemory),
              state.contexts.map((state) => agent.saveContext(state)),
            ].flat()
          );

          if (context.onError) {
            try {
              await context.onError(
                error,
                {
                  ...ctxState,
                  workingMemory,
                },
                agent
              );
            } catch (error) {
              break;
            }
          } else {
            break;
          }
        }
      }

      await Promise.all(
        state.contexts.map((state) =>
          state.context.onRun?.(
            {
              ...state,
              workingMemory,
            },
            agent
          )
        )
      );

      await Promise.all(
        state.contexts.map((state) => agent.saveContext(state))
      );

      logger.debug("agent:run", "Removing context from running set", {
        id: ctxState.id,
      });

      contextsRunning.delete(ctxState.id);

      logger.info("agent:run", "Run completed", {
        contextId: ctxState.id,
        chainLength: state.chain.length,
      });

      state.defer.resolve(state.chain);

      return state.chain;
    },

    async send(params) {
      const inputRef: InputRef = {
        id: randomUUIDv7(),
        ref: "input",
        type: params.input.type,
        content: params.input.data,
        data: undefined,
        timestamp: Date.now(),
        processed: false,
      };

      return await agent.run({
        ...params,
        chain: params.chain ? [...params.chain, inputRef] : [inputRef],
      });
    },

    async evaluator(ctx) {
      const { id, memory } = ctx;
      logger.debug("agent:evaluator", "memory", memory);
    },

    /**
     * Exports all episodes as training data
     * @param filePath Optional path to save the training data
     */
    async exportAllTrainingData(filePath?: string) {
      logger.info(
        "agent:exportTrainingData",
        "Exporting episodes as training data"
      );

      // Get all contexts
      const contexts = await agent.getContexts();

      // Collect all episodes from all contexts
      const allEpisodes: Episode[] = [];

      for (const { id } of contexts) {
        const episodes = await agent.memory.vector.query(id, "");
        if (episodes.length > 0) {
          allEpisodes.push(...episodes);
        }
      }

      logger.info(
        "agent:exportTrainingData",
        `Found ${allEpisodes.length} episodes to export`
      );

      // Export episodes as training data
      if (allEpisodes.length > 0) {
        await exportEpisodesAsTrainingData(
          allEpisodes,
          filePath || config.trainingDataPath || "./training-data.jsonl"
        );
        logger.info(
          "agent:exportTrainingData",
          "Episodes exported successfully"
        );
      } else {
        logger.warn("agent:exportTrainingData", "No episodes found to export");
      }
    },
  };

  container.instance("agent", agent);

  return agent;
}

--- End File: packages/core/src/dreams.ts ---

--- File: packages/core/src/engine.ts ---
import {
  createResultsTemplateResolver,
  getValueByPath,
  handleActionCall,
  handleInput,
  handleOutput,
  NotFoundError,
  ParsingError,
  prepareActionCall,
  prepareContexts,
  prepareOutputRef,
  resolveActionCall,
} from "./handlers";
import type {
  ActionCall,
  ActionCtxRef,
  ActionResult,
  AnyAction,
  AnyAgent,
  AnyContext,
  AnyRef,
  ContextRef,
  ContextState,
  ContextStateApi,
  EventRef,
  Handlers,
  Input,
  InputConfig,
  InputRef,
  Log,
  Output,
  OutputCtxRef,
  OutputRef,
  RunRef,
  StepRef,
  TemplateResolver,
  WorkingMemory,
  LogChunk,
  ActionCallContext,
} from "./types";
import pDefer, { type DeferredPromise } from "p-defer";
import { pushToWorkingMemory } from "./context";
import { createEventRef, randomUUIDv7 } from "./utils";
import { ZodError, type ZodIssue } from "zod";

type CallOptions = Partial<{
  templateResolvers: Record<string, TemplateResolver>;
  queueKey: string;
}>;

// type Router<TLog extends AnyRef = AnyRef> = {
//   [K in TLog["ref"]]: K extends "action_call"
//     ? (
//         log: ActionCall,
//         options?: Partial<{
//           templateResolvers: Record<string, TemplateResolver>;
//         }>
//       ) => MaybePromise<ActionResult>
//     : TLog extends { ref: K }
//       ? (log: TLog) => MaybePromise<void>
//       : never;
// };

interface Router {
  input(ref: InputRef): Promise<void>;
  output(ref: OutputRef): Promise<OutputRef[]>;
  action_call(call: ActionCall, options: CallOptions): Promise<ActionResult>;
}

type ErrorRef = {
  log: AnyRef;
  error: unknown;
};

type State = {
  running: boolean;
  step: number;
  chain: AnyRef[];
  ctxState: ContextState;

  inputs: Input[];
  outputs: OutputCtxRef[];
  actions: ActionCtxRef[];
  contexts: ContextState[];

  promises: Promise<any>[];

  errors: ErrorRef[];

  results: Promise<ActionResult>[];

  params?: Partial<{
    outputs: Record<string, Omit<Output<any, any, any, any>, "type">>;
    inputs: Record<string, InputConfig>;
    actions: AnyAction[];
    contexts: ContextRef[];
  }>;

  defer: DeferredPromise<AnyRef[]>;
};

type Engine = ReturnType<typeof createEngine>;

export function createEngine({
  agent,
  ctxState,
  agentCtxState,
  workingMemory,
  subscriptions,
  handlers,
  __chunkSubscriptions,
}: {
  agent: AnyAgent;
  ctxState: ContextState;
  agentCtxState?: ContextState;
  workingMemory: WorkingMemory;
  subscriptions: Set<(log: AnyRef, done: boolean) => void>;
  handlers?: Partial<Handlers>;
  __chunkSubscriptions?: Set<(chunk: LogChunk) => void>;
}) {
  const controller = new AbortController();

  const state: State = {
    running: false,
    step: -1,

    ctxState,

    chain: [],

    inputs: [],
    outputs: [],
    actions: [],
    contexts: [],

    results: [],

    promises: [],

    errors: [],

    defer: pDefer<AnyRef[]>(),
  };

  function pushPromise(promise: Promise<any>) {
    state.promises.push(promise);

    promise.finally(() => {
      state.promises.splice(state.promises.indexOf(promise), 1);
    });
  }

  function pushLogToSubscribers(log: AnyRef, done: boolean) {
    try {
      handlers?.onLogStream?.(structuredClone(log), done);
    } catch (error) {}

    for (const subscriber of subscriptions) {
      try {
        subscriber(structuredClone(log), done);
      } catch (error) {}
    }
  }

  function __pushLogChunkToSubscribers(log: LogChunk) {
    if (__chunkSubscriptions) {
      for (const subscriber of __chunkSubscriptions) {
        try {
          subscriber(structuredClone(log));
        } catch (error) {}
      }
    }
  }

  async function pushLog<TRef extends AnyRef = AnyRef>(
    log: TRef,
    options?: any
  ): Promise<any> {
    // throw?
    if (!state.running) throw new Error("not running!");

    // todo: still push?
    controller.signal.throwIfAborted();

    if (log.ref !== "output") {
      state.chain.push(log);
    }

    try {
      let res: any;

      switch (log.ref) {
        case "input":
          await router.input(log);
          break;
        case "output":
          res = await router.output(log);
          break;
        case "action_call":
          res = await router.action_call(log, options);
          break;
      }

      if (log.ref !== "output") {
        pushToWorkingMemory(workingMemory, log);
      }

      return res;
    } catch (error) {
      if (log.ref === "output") {
        state.chain.push(log);
      }

      const errorRef = { log, error };

      state.errors.push(errorRef);

      __push(createErrorEvent(errorRef), true, true);

      pushToWorkingMemory(workingMemory, log);
    } finally {
      pushLogToSubscribers(log, true);
    }
  }

  async function __push<TRef extends AnyRef = AnyRef>(
    log: TRef,
    done: boolean = true,
    __pushChunk: boolean = true
  ): Promise<any> {
    try {
      if (done) {
        return await pushLog(log);
      } else {
        pushLogToSubscribers(log, false);
      }
    } finally {
      if (__pushChunk) {
        __pushLogChunkToSubscribers({
          type: "log",
          done,
          log,
        });
      }
    }
  }

  const ctxStateApi: ContextStateApi<AnyContext> = {
    push: (log) => pushLog(log),
    emit(event, args, options) {
      const eventRef: EventRef = {
        ref: "event",
        id: randomUUIDv7(),
        name: event as string,
        data: args,
        processed: options?.processed ?? true,
        timestamp: Date.now(),
      };
      __push(eventRef, true, true);
    },
    async callAction(call, options) {
      const res = await pushLog(call, options);
      __pushLogChunkToSubscribers({ type: "log", log: call, done: true });
      return res;
    },
    __getRunResults() {
      return state.results;
    },
  };

  const defaultResolvers: Record<string, TemplateResolver> = {
    calls: createResultsTemplateResolver(state.results),
    shortTermMemory: async (path) => {
      const shortTermMemory = state.contexts.find(
        (state) => state.context.type === "shortTermMemory"
      );
      if (!shortTermMemory) throw new Error("short term memory not found");
      const value = getValueByPath(shortTermMemory.memory, path);
      if (value === undefined)
        throw new Error("invalid short term memory resultPath");
      return value;
    },
  };

  async function templateResolver(
    key: string,
    path: string,
    ctx: ActionCallContext,
    resolvers: Record<string, TemplateResolver<ActionCallContext>>
  ) {
    if (resolvers[key]) return resolvers[key](path, ctx);
    throw new Error("template engine key not implemented");
  }

  const router: Router = {
    async input(log) {
      await handleInput({
        agent,
        ctxState,
        inputRef: log,
        inputs: state.inputs,
        logger: agent.logger,
        workingMemory,
      });
    },

    async action_call(call, options = {}) {
      if (call.processed) throw new Error("Already processed");
      call.processed = true;

      const defer = pDefer<ActionResult>();

      pushPromise(defer.promise);
      state.results.push(defer.promise);

      const action = resolveActionCall({
        call,
        actions: state.actions,
        logger: agent.logger,
      });

      const actionCtxState =
        state.contexts.find(
          (subCtxState: any) => subCtxState.id === action.ctxRef.id
        ) ?? ctxState;

      const templateResolvers = {
        ...defaultResolvers,
        ...ctxState.context.__templateResolvers,
        ...options.templateResolvers,
      };

      const callCtx = await prepareActionCall({
        agent,
        call,
        action,
        state: actionCtxState,
        workingMemory,
        api: ctxStateApi,
        abortSignal: controller.signal,
        agentState: agentCtxState,
        logger: agent.logger,
        templateResolver: (key, path, callCtx) =>
          templateResolver(key, path, callCtx, templateResolvers),
      }).catch((err) => {
        defer.reject(err);
        throw err;
      });

      handleActionCall({
        call,
        callCtx,
        action,
        agent,
        logger: agent.logger,
        taskRunner: agent.taskRunner,
        abortSignal: controller.signal,
        queueKey: options.queueKey,
      })
        .catch((error) => {
          const result: ActionResult = {
            ref: "action_result",
            id: randomUUIDv7(),
            callId: call.id,
            data: { error: formatError(error) },
            name: call.name,
            timestamp: Date.now(),
            processed: false,
          };

          return result;
        })
        .then((res) => {
          defer.resolve(res);
          __push(res, true, true);
          return res;
        });

      return await defer.promise;
    },

    async output(outputRef) {
      const { output } = prepareOutputRef({
        outputRef,
        outputs: state.outputs,
        logger: agent.logger,
      });

      const res = await handleOutput({
        agent,
        logger: agent.logger,
        state:
          state.contexts.find(
            (subCtxState) => subCtxState.id === output.ctxRef.id
          ) ?? ctxState,
        workingMemory,
        output,
        outputRef,
      });

      const refs = Array.isArray(res) ? res : [res];

      for (const ref of refs) {
        agent.logger.debug("agent:output", "Output processed status", {
          type: ref.type,
          processed: ref.processed,
        });

        state.chain.push(ref);

        pushToWorkingMemory(workingMemory, ref);
      }

      return refs;
    },
  };

  const runRef: RunRef = {
    id: randomUUIDv7(),
    ref: "run",
    type: ctxState.context.type,
    data: {},
    processed: false,
    timestamp: Date.now(),
  };

  async function createStep() {
    const newStep: StepRef = {
      ref: "step",
      id: randomUUIDv7(),
      step: state.step,
      type: "main",
      data: {},
      processed: false,
      timestamp: Date.now(),
    };

    await __push(newStep, true, true);

    return newStep;
  }

  return {
    state,
    controller,

    async setParams(params: State["params"]) {
      state.params = params;
    },

    async prepare() {
      const { actions, contexts, inputs, outputs } = await prepareContexts({
        agent,
        ctxState,
        agentCtxState,
        workingMemory,
        params: state.params,
      });

      Object.assign(state, { actions, contexts, inputs, outputs });
    },

    async stop() {
      controller.abort("stop");
    },

    async pushChunk(chunk: LogChunk) {
      __pushLogChunkToSubscribers(chunk);
    },

    async push(log: Log, done: boolean = true, pushChunk: boolean = true) {
      return await __push(log, done, pushChunk);
    },

    async settled() {
      while (state.promises.length > 0) {
        await Promise.allSettled(state.promises);
      }
    },

    async start() {
      if (state.running) throw new Error("alredy running");

      state.running = true;

      await this.prepare();

      await __push(runRef, true, true);

      state.step = 1;
      return createStep();
    },

    async nextStep() {
      await this.prepare();
      return createStep();
    },

    shouldContinue() {
      if (controller.signal.aborted) return false;

      if (state.errors.length > 0) {
        agent.logger.warn("agent:run", "Continuing despite error", {
          errors: state.errors,
          step: state.step,
        });
      }

      for (const ctx of state.contexts) {
        if (!ctx.context.shouldContinue) continue;

        if (
          ctx.context.shouldContinue({
            ...ctx,
            workingMemory,
          })
        )
          return true;
      }

      const pendingResults = state.chain.filter(
        (i) => i.ref !== "thought" && i.processed === false
      );

      return pendingResults.length > 0;
    },
  };
}

function prettifyZodError(error: ZodError): string {
  if (!error || !error.issues || error.issues.length === 0) {
    return "Validation failed, but no specific issues were provided.";
  }

  const errorMessages = error.issues.map((issue: ZodIssue) => {
    const pathString = issue.path.join(".");
    return `- Field \`${pathString || "object root"}\`: ${issue.message} (Code: ${issue.code})`;
  });

  return `Validation Errors:\n${errorMessages.join("\n")}`;
}

function formatError(error: unknown) {
  if (error instanceof Error) {
    return {
      name: error.name,
      message: error.message,
      cause: error.cause,
      // stack: error.stack,
    };
  }

  return JSON.stringify(error);
}

function createErrorEvent(errorRef: ErrorRef) {
  if (errorRef.error instanceof NotFoundError) {
    if (
      errorRef.error.ref.ref === "input" ||
      errorRef.error.ref.ref === "output"
    ) {
      return createEventRef({
        name: "error",
        data: {
          ref: {
            ref: errorRef.log.ref,
            id: errorRef.log.id,
            type: errorRef.error.ref.type,
          },
          error: {
            name: "NotFoundError",
            message: "Invalid type",
          },
        },
        processed: false,
      });
    } else if (errorRef.error.ref.ref === "action_call") {
      return createEventRef({
        name: "error",
        data: {
          ref: {
            ref: errorRef.log.ref,
            id: errorRef.log.id,
            name: errorRef.error.ref.name,
          },
          error: {
            name: "NotFoundError",
            message: "Invalid action name",
          },
        },
        processed: false,
      });
    }
  }

  if (errorRef.error instanceof ParsingError) {
    return createEventRef({
      name: "error",
      data: {
        ref: {
          ref: errorRef.log.ref,
          id: errorRef.log.id,
          data: errorRef.error.ref.content,
        },
        error: {
          name: "ParsingError",
          message:
            errorRef.error.parsingError instanceof ZodError
              ? prettifyZodError(errorRef.error.parsingError)
              : JSON.stringify(errorRef.error.parsingError),
        },
      },
      processed: false,
    });
  }

  return createEventRef({
    name: "error",
    data: {
      ref: {
        type: errorRef.log.ref,
        id: errorRef.log.id,
      },
      error: formatError(errorRef.error),
    },
    processed: false,
  });
}

--- End File: packages/core/src/engine.ts ---

--- File: packages/core/src/formatters.ts ---
import zodToJsonSchema from "zod-to-json-schema";
import type {
  AnyAction,
  ContextState,
  InputRef,
  Log,
  Output,
  OutputRef,
  TemplateVariables,
  XMLElement,
} from "./types";
import { z } from "zod";
import { type Schema } from "@ai-sdk/ui-utils";

export function xml(
  tag: string,
  params?: Record<string, any>,
  children?: string | XMLElement[] | any
): XMLElement {
  const el: XMLElement = {
    tag,
  };

  if (params) el.params = params;
  if (children) el.children = children;

  return el;
}

/**
 * Formats an XML element into a string representation
 * @param tag - The XML tag name
 * @param params - Optional parameters/attributes for the XML tag
 * @param content - The content of the XML element (string or nested elements)
 * @returns Formatted XML string
 */
export function formatXml(el: XMLElement): string {
  const params = el.params
    ? Object.entries(el.params)
        .map(([k, v]) => ` ${k}="${v}"`)
        .join("")
    : "";

  let children = Array.isArray(el.children)
    ? el.children.filter((t) => !!t)
    : el.children;

  if (Array.isArray(children) && children.length === 0) {
    children = "";
  }

  children =
    typeof children === "string"
      ? children
      : Array.isArray(children) && children.length > 0
        ? "\n" +
          children
            .map((el) =>
              typeof el === "string"
                ? el
                : "tag" in el
                  ? formatXml(el)
                  : formatValue(el)
            )
            .join("\n") +
          "\n"
        : formatValue(children);

  try {
    if (children === "") return `<${el.tag}${params} />`;
    return `<${el.tag}${params}>${children}</${el.tag}>`;
  } catch (error) {
    console.log("failed to format", el);
    throw error;
  }
}

/**
 * Formats an input reference into XML format
 * @param input - The input reference to format
 * @returns XML string representation of the input
 */
export function formatInput(input: InputRef) {
  return xml(
    "input",
    { name: input.type, timestamp: input.timestamp, ...input.params },
    input.data
  );
}

/**
 * Formats an output reference into XML format
 * @param output - The output reference to format
 * @returns XML string representation of the output
 */
export function formatOutput(output: OutputRef) {
  return xml(
    "output",
    { name: output.type, timestamp: output.timestamp, ...output.params },
    output.data ?? output.content
  );
}

export function formatSchema(schema: any, key: string = "schema") {
  return "_type" in schema
    ? (schema as Schema).jsonSchema
    : zodToJsonSchema("parse" in schema ? schema : z.object(schema), key)
        .definitions![key];
}

/**
 * Formats an output interface definition into XML format
 * @param output - The output interface to format
 * @returns XML string representation of the output interface
 */
export function formatOutputInterface(output: Output<any>) {
  const params: Record<string, string> = {
    type: output.type,
  };

  if (output.required) {
    params.required = "true";
  }

  return xml("output", params, [
    output.description
      ? { tag: "description", children: output.description }
      : null,
    output.instructions
      ? { tag: "instructions", children: output.instructions }
      : null,
    {
      tag: "attributes_schema",
      children: output.attributes
        ? formatSchema(output.attributes, "attributes")
        : {},
    },
    {
      tag: "content_schema",
      children: formatSchema(output.schema ?? z.string(), "content"),
    },
    output.examples
      ? {
          tag: "examples",
          children: output.examples,
        }
      : null,
  ]);
}

export function formatAction(action: AnyAction) {
  return xml("action", { name: action.name }, [
    action.description
      ? {
          tag: "description",
          children: action.description,
        }
      : null,
    action.instructions
      ? {
          tag: "instructions",
          children: action.instructions,
        }
      : null,
    {
      tag: "format",
      children: action.callFormat?.toUpperCase() ?? "JSON",
    },
    action.schema
      ? {
          tag: "schema",
          children: formatSchema(action.schema, "schema"),
        }
      : null,
    action.returns
      ? {
          tag: "returns",
          children: formatSchema(action.returns, "returns"),
        }
      : null,
    action.examples
      ? {
          tag: "examples",
          children: action.examples,
        }
      : null,
  ]);
}

export function formatContextState(state: ContextState) {
  const { context, key } = state;
  const params: Record<string, string> = { type: context.type };

  if (key) {
    params.key = key;
  }

  return xml(
    "context",
    params,
    [
      context.description
        ? {
            tag: "description",
            children:
              typeof context.description === "function"
                ? context.description(state)
                : context.description,
          }
        : null,
      context.instructions
        ? {
            tag: "instructions",
            children:
              typeof context.instructions === "function"
                ? context.instructions(state)
                : context.instructions,
          }
        : null,
      {
        tag: "state",
        children: context.render ? context.render(state) : state.memory,
      },
    ].flat()
  );
}

export type Msg =
  | {
      role: "user";
      user: string;
      content: string;
    }
  | {
      role: "assistant";
      content: string;
    };

export function formatMsg(msg: Msg): XMLElement {
  return {
    tag: "msg",
    params:
      msg.role === "user"
        ? {
            role: "user",
            user: msg.user,
          }
        : { role: "assistant" },
    children: msg.content,
  };
}

export function formatContextLog(i: Log) {
  switch (i.ref) {
    case "input":
      return i.formatted ?? formatInput(i);
    case "output":
      return i.formatted ?? formatOutput(i);
    case "thought":
      return xml("reasoning", {}, i.content);
    case "action_call":
      return xml(
        "action_call",
        { id: i.id, name: i.name, timestamp: i.timestamp },
        i.data ?? i.content
      );
    case "action_result":
      return xml(
        "action_result",
        { callId: i.callId, name: i.name, timestamp: i.timestamp },
        i.formatted ?? i.data
      );
    case "event":
      return xml("event", { name: i.name, ...i.params }, i.formatted ?? i.data);
    default:
      throw new Error("invalid context");
  }
}

/**
 * Formats a value for template rendering
 * @param value - The value to format
 * @returns Formatted string representation of the value
 */
export function formatValue(value: any): string {
  if (typeof value !== "string")
    return JSON.stringify(value, (_, value) => {
      if (typeof value === "bigint") return value.toString();
      return value;
    });
  return value.trim();
}

/**
 * Renders a template string by replacing variables with provided values
 * @template Template - The template string type containing variables in {{var}} format
 * @param str - The template string to render
 * @param data - Object containing values for template variables
 * @returns The rendered string with variables replaced
 */
export function render<Template extends string>(
  str: Template,
  data: TemplateVariables<Template>
) {
  return str.trim().replace(/\{\{(\w+)\}\}/g, (match, key: string) => {
    const value: any = data[key as keyof typeof data] ?? "";

    if (typeof value === "object") {
      if (value && "tag" in value) return formatXml(value as XMLElement);
      if (value) formatValue(value);
    }

    if (Array.isArray(value)) {
      return value
        .map((v) => {
          if (typeof v === "object" && v && "tag" in v) {
            return formatXml(v);
          }
          return formatValue(v);
        })
        .join("\n");
    }

    return value ?? "";
  });
}

--- End File: packages/core/src/formatters.ts ---

--- File: packages/core/src/handlers.ts ---
import { z, ZodSchema } from "zod";
import type { Logger } from "./logger";
import type { TaskRunner } from "./task";
import { runAction } from "./tasks";
import type {
  ActionCall,
  ActionCallContext,
  ActionCtxRef,
  ActionResult,
  AnyAction,
  AnyAgent,
  AnyContext,
  AnyOutput,
  Context,
  ContextRef,
  ContextState,
  ContextStateApi,
  Input,
  InputConfig,
  InputRef,
  MaybePromise,
  Memory,
  Output,
  OutputCtxRef,
  OutputRef,
  Resolver,
  TemplateResolver,
  WorkingMemory,
} from "./types";
import { randomUUIDv7 } from "./utils";
import { parse } from "./xml";
import { jsonPath } from "./jsonpath";
import { jsonSchema } from "ai";

export class NotFoundError extends Error {
  name = "NotFoundError";
  constructor(public ref: ActionCall | OutputRef | InputRef) {
    super();
  }
}

export class ParsingError extends Error {
  name = "ParsingError";
  constructor(
    public ref: ActionCall | OutputRef | InputRef,
    public parsingError: unknown
  ) {
    super();
  }
}

function parseJSONContent(content: string) {
  if (content.startsWith("```json")) {
    content = content.slice("```json".length, -3);
  }

  return JSON.parse(content);
}

function parseXMLContent(content: string) {
  const nodes = parse(content, (node) => {
    return node;
  });

  const data = nodes.reduce(
    (data, node) => {
      if (node.type === "element") {
        data[node.name] = node.content;
      }
      return data;
    },
    {} as Record<string, string>
  );

  return data;
}

export interface TemplateInfo {
  path: (string | number)[];
  template_string: string;
  expression: string;
  primary_key: string | null;
}

export function detectTemplates(obj: unknown): TemplateInfo[] {
  const foundTemplates: TemplateInfo[] = [];
  const templatePattern = /^\{\{(.*)\}\}$/; // Matches strings that *only* contain {{...}}
  const primaryKeyPattern = /^([a-zA-Z_][a-zA-Z0-9_]*)/; // Extracts the first identifier (simple version)

  function traverse(
    currentObj: unknown,
    currentPath: (string | number)[]
  ): void {
    if (typeof currentObj === "object" && currentObj !== null) {
      if (Array.isArray(currentObj)) {
        currentObj.forEach((item, index) => {
          traverse(item, [...currentPath, index]);
        });
      } else {
        // Handle non-array objects (assuming Record<string, unknown> or similar)
        for (const key in currentObj) {
          if (Object.prototype.hasOwnProperty.call(currentObj, key)) {
            // Use type assertion if necessary, depending on your exact object types
            traverse((currentObj as Record<string, unknown>)[key], [
              ...currentPath,
              key,
            ]);
          }
        }
      }
    } else if (typeof currentObj === "string") {
      const match = currentObj.match(templatePattern);
      if (match) {
        const expression = match[1].trim();
        const primaryKeyMatch = expression.match(primaryKeyPattern);
        const primaryKey = primaryKeyMatch ? primaryKeyMatch[1] : null;

        foundTemplates.push({
          path: currentPath,
          template_string: currentObj,
          expression: expression,
          primary_key: primaryKey,
        });
      }
    }
  }

  traverse(obj, []);
  return foundTemplates;
}

export function getPathSegments(pathString: string) {
  const segments = pathString.split(/[.\[\]]+/).filter(Boolean);
  return segments;
}

export function resolvePathSegments<T = any>(
  source: any,
  segments: string[]
): T | undefined {
  let current: any = source;

  for (const segment of segments) {
    if (current === null || current === undefined) {
      return undefined;
    }

    // Check if segment is an array index
    const index = parseInt(segment, 10);
    if (!isNaN(index) && Array.isArray(current)) {
      current = current[index];
    } else if (typeof current === "object") {
      current = current[segment];
    } else {
      return undefined; // Cannot access property on non-object/non-array
    }
  }

  return current;
}

/**
 * Native implementation to safely get a nested value from an object/array
 * using a string path like 'a.b[0].c'.
 */
export function getValueByPath(source: any, pathString: string): any {
  if (!pathString) {
    return source; // Return the source itself if path is empty
  }

  // Basic path segment splitting (handles dot notation and array indices)
  // More robust parsing might be needed for complex cases (e.g., keys with dots/brackets)
  const segments = getPathSegments(pathString);

  return resolvePathSegments(source, segments);
}

/**
 * Native implementation to safely set a nested value in an object/array
 * using a path array (like the one from detectTemplates).
 * Creates nested structures if they don't exist.
 */
function setValueByPath(
  target: any,
  path: (string | number)[],
  value: any
): void {
  let current: any = target;
  const lastIndex = path.length - 1;

  for (let i = 0; i < lastIndex; i++) {
    const key = path[i];
    const nextKey = path[i + 1];

    if (current[key] === null || current[key] === undefined) {
      // If the next key looks like an array index, create an array, otherwise an object
      current[key] = typeof nextKey === "number" ? [] : {};
    }
    current = current[key];

    // Safety check: if current is not an object/array, we can't proceed
    if (typeof current !== "object" || current === null) {
      console.error(
        `Cannot set path beyond non-object at segment ${i} ('${key}') for path ${path.join(".")}`
      );
      return;
    }
  }

  // Set the final value
  const finalKey = path[lastIndex];
  if (typeof current === "object" && current !== null) {
    current[finalKey] = value;
  } else {
    console.error(
      `Cannot set final value, parent at path ${path.slice(0, -1).join(".")} is not an object.`
    );
  }
}

/**
 * Resolves detected templates in an arguments object using provided data sources.
 * Modifies the input object directly. Uses native helper functions.
 */
export async function resolveTemplates(
  argsObject: any, // The object containing templates (will be mutated)
  detectedTemplates: TemplateInfo[],
  resolver: (primary_key: string, path: string) => Promise<any>
): Promise<void> {
  for (const templateInfo of detectedTemplates) {
    let resolvedValue: any = undefined;

    if (!templateInfo.primary_key) {
      console.warn(
        `Template at path ${templateInfo.path.join(".")} has no primary key: ${templateInfo.template_string}`
      );
      continue;
    }

    const valuePath = templateInfo.expression
      .substring(templateInfo.primary_key.length)
      .replace(/^\./, "");

    try {
      resolvedValue = await resolver(templateInfo.primary_key, valuePath);
    } catch (error) {
      console.error(
        `Error resolving template at path ${templateInfo.path.join(".")}: ${error}`
      );
    }

    if (resolvedValue === undefined) {
      console.warn(
        `Could not resolve template "${templateInfo.template_string}" at path ${templateInfo.path.join(".")}. Path or source might be invalid.`
      );
      throw new Error(
        `Could not resolve template "${templateInfo.template_string}" at path ${templateInfo.path.join(".")}. Path or source might be invalid.`
      );
    }

    // Use the native setValueByPath function
    setValueByPath(argsObject, templateInfo.path, resolvedValue);
  }
}

export async function templateResultsResolver(
  arr: MaybePromise<ActionResult>[],
  path: string
) {
  const [index, ...resultPath] = getPathSegments(path);
  const actionResult = arr[Number(index)];

  if (!actionResult) throw new Error("invalid index");
  const result = await actionResult;

  if (resultPath.length === 0) {
    return result.data;
  }
  return jsonPath(result.data, resultPath.join("."));
}

export function createResultsTemplateResolver(
  arr: Array<MaybePromise<any>>
): TemplateResolver {
  return (path) => templateResultsResolver(arr, path);
}

export function createObjectTemplateResolver(obj: object): TemplateResolver {
  return async function templateObjectResolver(path) {
    const res = jsonPath(obj, path);
    if (!res) throw new Error("invalid path: " + path);
    return res.length > 1 ? res : res[0];
  };
}

export function parseActionCallContent({
  call,
  action,
}: {
  call: ActionCall;
  action: AnyAction;
}) {
  try {
    const content = call.content.trim();

    let data: any;

    if (action.parser) {
      data = action.parser(call);
    } else if (action.schema && action.schema?._def?.typeName !== "ZodString") {
      if (action.callFormat === "xml") {
        data = parseXMLContent(content);
      } else {
        data = parseJSONContent(content);
      }
    } else {
      data = content;
    }

    return data;
  } catch (error) {
    throw new ParsingError(call, error);
  }
}

export function resolveActionCall({
  call,
  actions,
  logger,
}: {
  call: ActionCall;
  actions: ActionCtxRef[];
  logger: Logger;
}) {
  const contextKey = call.params?.contextKey;

  const action = actions.find(
    (a) =>
      (contextKey ? contextKey === a.ctxRef.key : true) && a.name === call.name
  );

  if (!action) {
    logger.error("agent:action", "ACTION_MISMATCH", {
      name: call.name,
      data: call.content,
      contextKey,
    });

    throw new NotFoundError(call);
  }

  return action;
}

export async function prepareActionCall({
  call,
  action,
  logger,
  templateResolver,
  state,
  api,
  workingMemory,
  agent,
  agentState,
  abortSignal,
}: {
  agent: AnyAgent;
  state: ContextState<AnyContext>;
  api: ContextStateApi<AnyContext>;
  workingMemory: WorkingMemory;
  agentState?: ContextState;
  call: ActionCall;
  action: ActionCtxRef;
  logger: Logger;
  templateResolver: (
    primary_key: string,
    path: string,
    callCtx: ActionCallContext
  ) => MaybePromise<any>;
  abortSignal?: AbortSignal;
}) {
  let actionMemory: Memory<any> | undefined = undefined;

  if (action.memory) {
    actionMemory =
      (await agent.memory.store.get(action.memory.key)) ??
      action.memory.create();
  }

  const callCtx: ActionCallContext = {
    ...state,
    ...api,
    workingMemory,
    actionMemory,
    agentMemory: agentState?.memory,
    abortSignal,
    call,
  };

  const data = call.data ?? parseActionCallContent({ call, action });

  const templates: TemplateInfo[] = [];

  if (action.templateResolver !== false) {
    templates.push(...detectTemplates(data));

    const actionTemplateResolver =
      typeof action.templateResolver === "function"
        ? action.templateResolver
        : templateResolver;

    if (templates.length > 0)
      await resolveTemplates(data, templates, (key, path) =>
        actionTemplateResolver(key, path, callCtx)
      );
  }

  if (action.schema) {
    try {
      const schema =
        "parse" in action.schema || "validate" in action.schema
          ? action.schema
          : "$schema" in action.schema
            ? jsonSchema(action.schema)
            : z.object(action.schema);

      call.data =
        "parse" in schema
          ? (schema as ZodSchema).parse(data)
          : schema.validate
            ? schema.validate(data)
            : data;
    } catch (error) {
      throw new ParsingError(call, error);
    }
  } else {
    call.data = data;
  }

  return callCtx;
}

export async function handleActionCall({
  action,
  logger,
  call,
  taskRunner,
  agent,
  abortSignal,
  callCtx,
  queueKey,
}: {
  callCtx: ActionCallContext;
  call: ActionCall;
  action: AnyAction;
  logger: Logger;
  taskRunner: TaskRunner;
  agent: AnyAgent;
  abortSignal?: AbortSignal;
  queueKey?: string;
}): Promise<ActionResult> {
  queueKey =
    queueKey ??
    (action.queueKey
      ? typeof action.queueKey === "function"
        ? action.queueKey(callCtx)
        : action.queueKey
      : undefined);

  const data = await taskRunner.enqueueTask(
    runAction,
    {
      action,
      agent,
      logger,
      ctx: callCtx,
    },
    {
      retry: action.retry,
      abortSignal,
      queueKey,
    }
  );

  const result: ActionResult = {
    ref: "action_result",
    id: randomUUIDv7(),
    callId: call.id,
    data,
    name: call.name,
    timestamp: Date.now(),
    processed: false,
  };

  if (action.format) result.formatted = action.format(result);

  if (callCtx.actionMemory) {
    await agent.memory.store.set(action.memory.key, callCtx.actionMemory);
  }

  if (action.onSuccess) {
    await Promise.try(action.onSuccess, result, callCtx, agent);
  }

  return result;
}

export function prepareOutputRef({
  outputRef,
  outputs,
  logger,
}: {
  outputRef: OutputRef;
  outputs: OutputCtxRef[];
  logger: Logger;
}) {
  const output = outputs.find((output) => output.type === outputRef.type);

  if (!output) {
    throw new NotFoundError(outputRef);
  }

  logger.debug("agent:output", outputRef.type, outputRef.data);

  if (output.schema) {
    const schema = (
      "parse" in output.schema ? output.schema : z.object(output.schema)
    ) as z.AnyZodObject | z.ZodString;

    let parsedContent = outputRef.content;

    try {
      if (typeof parsedContent === "string") {
        if (schema._def.typeName !== "ZodString") {
          parsedContent = JSON.parse(parsedContent.trim());
        }
      }

      outputRef.data = schema.parse(parsedContent);
    } catch (error) {
      throw new ParsingError(outputRef, error);
    }
  }

  return { output };
}

export async function handleOutput({
  outputRef,
  output,
  logger,
  state,
  workingMemory,
  agent,
}: {
  output: OutputCtxRef;
  outputRef: OutputRef;
  logger: Logger;
  workingMemory: WorkingMemory;
  state: ContextState;
  agent: AnyAgent;
}): Promise<OutputRef | OutputRef[]> {
  if (output.handler) {
    const response = await Promise.try(
      output.handler,
      outputRef.data,
      {
        ...state,
        workingMemory,
        outputRef,
      },
      agent
    );

    if (Array.isArray(response)) {
      const refs: OutputRef[] = [];
      for (const res of response) {
        const ref: OutputRef = {
          ...outputRef,
          id: randomUUIDv7(),
          processed: res.processed ?? true,
          ...res,
        };

        ref.formatted = output.format ? output.format(ref) : undefined;
        refs.push(ref);
      }
      return refs;
    } else if (response) {
      const ref: OutputRef = {
        ...outputRef,
        ...response,
        processed: response.processed ?? true,
      };

      ref.formatted = output.format ? output.format(ref) : undefined;

      return ref;
    }
  }

  return {
    ...outputRef,
    formatted: output.format ? output.format(outputRef.data) : undefined,
    processed: true,
  };
}

export async function prepareContextActions(params: {
  context: Context;
  state: ContextState<AnyContext>;
  workingMemory: WorkingMemory;
  agent: AnyAgent;
  agentCtxState: ContextState<AnyContext> | undefined;
}): Promise<ActionCtxRef[]> {
  const { context, state } = params;
  const actions =
    typeof context.actions === "function"
      ? await Promise.try(context.actions, state)
      : (context.actions ?? []);

  return Promise.all(
    actions.map((action) =>
      prepareAction({
        action,
        ...params,
      })
    )
  ).then((t) => t.filter((t) => !!t));
}

async function prepareOutput({
  output,
  context,
  state,
}: {
  output: AnyOutput;
  context: AnyContext;
  state: ContextState<AnyContext>;
}): Promise<OutputCtxRef | undefined> {
  if (output.context && output.context.type !== context.type) return undefined;

  const enabled = output.enabled ? output.enabled(state) : true;

  return enabled
    ? {
        ...output,
        ctxRef: {
          type: state.context.type,
          id: state.id,
          key: state.key,
        },
      }
    : undefined;
}

export async function prepareContextOutputs(params: {
  context: Context;
  state: ContextState<AnyContext>;
  workingMemory: WorkingMemory;
  agent: AnyAgent;
  agentCtxState: ContextState<AnyContext> | undefined;
}): Promise<OutputCtxRef[]> {
  return params.context.outputs
    ? Promise.all(
        Object.entries(params.context.outputs).map(([type, output]) =>
          prepareOutput({
            output: {
              type,
              ...output,
            },
            ...params,
          })
        )
      ).then((t) => t.filter((t) => !!t))
    : [];
}

export async function prepareAction({
  action,
  context,
  state,
  workingMemory,
  agent,
  agentCtxState,
}: {
  action: AnyAction;
  context: AnyContext;
  state: ContextState<AnyContext>;
  workingMemory: WorkingMemory;
  agent: AnyAgent;
  agentCtxState: ContextState<AnyContext> | undefined;
}): Promise<ActionCtxRef | undefined> {
  if (action.context && action.context.type !== context.type) return undefined;

  let actionMemory: Memory | undefined = undefined;

  if (action.memory) {
    actionMemory =
      (await agent.memory.store.get(action.memory.key)) ??
      action.memory.create();
  }

  const enabled = action.enabled
    ? action.enabled({
        ...state,
        context,
        workingMemory,
        actionMemory,
        agentMemory: agentCtxState?.memory,
      })
    : true;

  if (action.enabled && actionMemory) {
    await agent.memory.store.set(actionMemory.key, actionMemory);
  }

  return enabled
    ? {
        ...action,
        ctxRef: {
          type: state.context.type,
          id: state.id,
          key: state.key,
        },
      }
    : undefined;
}

function resolve<Value = any, Ctx = any>(
  value: Value,
  ctx: Ctx
): Promise<Value extends (ctx: Ctx) => infer R ? R : Value> {
  return typeof value === "function" ? value(ctx) : (value as any);
}

export async function prepareContext(
  {
    agent,
    ctxState,
    workingMemory,
    agentCtxState,
  }: {
    agent: AnyAgent;
    ctxState: ContextState;
    workingMemory: WorkingMemory;
    agentCtxState?: ContextState;
  },
  state: {
    inputs: Input[];
    outputs: OutputCtxRef[];
    actions: ActionCtxRef[];
    contexts: ContextState[];
  }
) {
  state.contexts.push(ctxState);

  await ctxState.context.loader?.(ctxState, agent);

  const inputs: Input[] = ctxState.context.inputs
    ? Object.entries(ctxState.context.inputs).map(([type, input]) => ({
        type,
        ...input,
      }))
    : [];

  state.inputs.push(...inputs);

  const outputs: OutputCtxRef[] = ctxState.context.outputs
    ? await Promise.all(
        Object.entries(await resolve(ctxState.context.outputs, ctxState)).map(
          ([type, output]) =>
            prepareOutput({
              output: {
                type,
                ...output,
              },
              context: ctxState.context,
              state: ctxState,
            })
        )
      ).then((r) => r.filter((a) => !!a))
    : [];

  state.outputs.push(...outputs);

  const actions = await prepareContextActions({
    agent,
    agentCtxState,
    context: ctxState.context,
    state: ctxState,
    workingMemory,
  });

  state.actions.push(...actions);

  const ctxRefs: ContextRef[] = [];

  if (ctxState.context.__composers) {
    for (const composer of ctxState.context.__composers) {
      ctxRefs.push(...composer(ctxState));
    }
  }

  for (const { context, args } of ctxRefs) {
    await prepareContext(
      {
        agent,
        ctxState: await agent.getContext({ context, args }),
        workingMemory,
        agentCtxState,
      },
      state
    );
  }

  return state;
}

export async function prepareContexts({
  agent,
  ctxState,
  agentCtxState,
  workingMemory,
  params,
}: {
  agent: AnyAgent;
  ctxState: ContextState;
  agentCtxState?: ContextState;
  workingMemory: WorkingMemory;
  params?: {
    outputs?: Record<string, Omit<Output, "type">>;
    inputs?: Record<string, InputConfig>;
    actions?: AnyAction[];
    contexts?: ContextRef[];
  };
}) {
  await agentCtxState?.context.loader?.(agentCtxState, agent);

  const inputs: Input[] = Object.entries({
    ...agent.inputs,
    ...(params?.inputs ?? {}),
  }).map(([type, input]) => ({
    type,
    ...input,
  }));

  const outputs: OutputCtxRef[] = await Promise.all(
    Object.entries({
      ...agent.outputs,
      ...(params?.outputs ?? {}),
    }).map(([type, output]) =>
      prepareOutput({
        output: {
          type,
          ...output,
        },
        context: ctxState.context,
        state: ctxState,
      })
    )
  ).then((r) => r.filter((a) => !!a));

  const actions = await Promise.all(
    [agent.actions, params?.actions]
      .filter((t) => !!t)
      .flat()
      .map((action: AnyAction) =>
        prepareAction({
          action,
          agent,
          agentCtxState,
          context: ctxState.context,
          state: ctxState,
          workingMemory,
        })
      )
  ).then((r) => r.filter((a) => !!a));

  const contexts: ContextState[] = agentCtxState ? [agentCtxState] : [];

  const state = {
    inputs,
    outputs,
    actions,
    contexts,
  };

  await prepareContext(
    { agent, ctxState, workingMemory, agentCtxState },
    state
  );

  if (params?.contexts) {
    for (const ctxRef of params?.contexts) {
      await prepareContext(
        {
          agent,
          ctxState: await agent.getContext(ctxRef),
          workingMemory,
          agentCtxState,
        },
        state
      );
    }
  }

  return state;
}

export async function handleInput({
  inputs,
  inputRef,
  logger,
  ctxState,
  workingMemory,
  agent,
}: {
  inputs: Input[];
  inputRef: InputRef;
  logger: Logger;
  workingMemory: WorkingMemory;
  ctxState: ContextState;
  agent: AnyAgent;
}) {
  const input = inputs.find((input) => input.type === inputRef.type);

  if (!input) {
    throw new NotFoundError(inputRef);
  }

  try {
    if (input.schema) {
      const schema = (
        "parse" in input.schema ? input.schema : z.object(input.schema)
      ) as z.AnyZodObject | z.ZodString;
      inputRef.data = schema.parse(inputRef.content);
    } else {
      inputRef.data = z.string().parse(inputRef.content);
    }
  } catch (error) {
    throw new ParsingError(inputRef, error);
  }

  logger.debug("agent:send", "Querying episodic memory");

  const episodicMemory = await agent.memory.vector.query(
    `${ctxState.id}`,
    JSON.stringify(inputRef.data)
  );

  logger.trace("agent:send", "Episodic memory retrieved", {
    episodesCount: episodicMemory.length,
  });

  workingMemory.episodicMemory = {
    episodes: episodicMemory,
  };

  if (input.handler) {
    logger.debug("agent:send", "Using custom input handler", {
      type: inputRef.type,
    });

    const { data, params } = await Promise.try(
      input.handler,
      inputRef.data,
      {
        ...ctxState,
        workingMemory,
      },
      agent
    );

    inputRef.data = data;

    if (params) {
      inputRef.params = {
        ...inputRef.params,
        ...params,
      };
    }
  }

  inputRef.formatted = input.format ? input.format(inputRef) : undefined;
}

--- End File: packages/core/src/handlers.ts ---

--- File: packages/core/src/http.ts ---
let nextRpcRequestId = 1;

type QueryParams =
  | Record<string, string | number | boolean | null | undefined>
  | URLSearchParams;

interface RetryOptions {
  maxRetries?: number;
  initialDelay?: number;
  maxDelay?: number;
  backoffFactor?: number;
  retryableStatuses?: number[];
}

interface RequestOptions extends RequestInit {
  retryOptions?: RetryOptions;
  params?: QueryParams;
}

const DEFAULT_RETRY_OPTIONS: Required<RetryOptions> = {
  maxRetries: 3,
  initialDelay: 1000,
  maxDelay: 30000,
  backoffFactor: 2,
  retryableStatuses: [408, 429, 500, 502, 503, 504],
};

class RequestError extends Error {
  constructor(
    message: string,
    public response?: Response
  ) {
    super(message);
    this.name = "RequestError";
  }
}

const sleep = (ms: number): Promise<void> =>
  new Promise((resolve) => setTimeout(resolve, ms));

const calculateDelay = (
  attempt: number,
  options: Required<RetryOptions>
): number => {
  const delay =
    options.initialDelay * Math.pow(options.backoffFactor, attempt - 1);
  return Math.min(delay, options.maxDelay);
};

const isRetryableError = (error: any): boolean =>
  error.name === "TypeError" ||
  error.name === "AbortError" ||
  error instanceof RequestError;

const buildUrl = (url: string, params?: QueryParams): string => {
  if (!params) return url;

  const searchParams =
    params instanceof URLSearchParams
      ? params
      : new URLSearchParams(
          Object.entries(params)
            .filter(([_, value]) => value != null)
            .map(([key, value]) => [key, String(value)])
        );

  const separator = url.includes("?") ? "&" : "?";
  const queryString = searchParams.toString();

  return queryString ? `${url}${separator}${queryString}` : url;
};

export const http = {
  async request(url: string, options?: RequestOptions): Promise<Response> {
    const { params, ...fetchOptions } = options || {};
    const fullUrl = buildUrl(url, params);

    const retryOptions: Required<RetryOptions> = {
      ...DEFAULT_RETRY_OPTIONS,
      ...options?.retryOptions,
    };

    let attempt = 1;

    while (true) {
      try {
        const res = await fetch(fullUrl, fetchOptions);

        if (!res.ok) {
          const errorText = await res.text();
          throw new RequestError(
            `Request failed with status ${res.status}: ${errorText}`,
            res
          );
        }

        return res;
      } catch (error: any) {
        if (isRetryableError(error) && attempt < retryOptions.maxRetries) {
          const delay = calculateDelay(attempt, retryOptions);
          console.warn(
            `Request failed with error: ${error.message}. ` +
              `Retrying in ${delay}ms (attempt ${attempt}/${retryOptions.maxRetries})`
          );
          await sleep(delay);
          attempt++;
          continue;
        }

        throw error;
      }
    }
  },

  async json<T = any>(url: string, options?: RequestOptions) {
    const res = await this.request(url, {
      ...options,
      headers: {
        "Content-Type": "application/json",
        ...options?.headers,
      },
    });
    return (await res.json()) as T;
  },

  get: {
    async request(url: string, params?: QueryParams, options?: RequestInit) {
      return http.request(url, {
        ...options,
        method: "GET",
        params,
      });
    },
    async json<T = any>(
      url: string,
      params?: QueryParams,
      options?: RequestInit
    ) {
      return http.json<T>(url, {
        ...options,
        method: "GET",
        params,
      });
    },
  },

  post: {
    async request(url: string, body: object, options?: RequestOptions) {
      return http.request(url, {
        ...options,
        method: "POST",
        body: JSON.stringify(body),
      });
    },

    async json<ReturnType = any, Body extends object = object>(
      url: string,
      body: Body,
      options?: RequestOptions
    ) {
      return http.json<ReturnType>(url, {
        ...options,
        method: "POST",
        body: JSON.stringify(body),
      });
    },
  },

  async jsonrpc<ReturnType = any, Params extends object = object>(
    url: string,
    method: string,
    params: Params,
    headers?: HeadersInit
  ) {
    return http.post.json<ReturnType>(
      url,
      {
        jsonrpc: "2.0",
        id: nextRpcRequestId++,
        method,
        params,
      },
      { headers }
    );
  },

  async graphql<ReturnType = any, Variables extends object = object>(
    url: string,
    query: string,
    variables: Variables,
    headers?: HeadersInit
  ) {
    return http.post.json<ReturnType>(
      url,
      {
        query,
        variables,
      },
      { headers }
    );
  },
};

--- End File: packages/core/src/http.ts ---

--- File: packages/core/src/index.ts ---
export * from "./dreams";
export * from "./types";
export * from "./utils";
export * from "./xml";
export * from "./logger";
export * from "./formatters";
export * from "./memory";
export * from "./prompt";
export * from "./task";
export * from "./context";
export * from "./container";
export * from "./serviceProvider";
export * from "./handlers";
export * from "./providers";
export * from "./http";
export * from "./prompts/main";
export * from "./tasks/index";

--- End File: packages/core/src/index.ts ---

--- File: packages/core/src/jsonpath.ts ---
/* JSONPath 0.8.0 - XPath for JSON
 *
 * Copyright (c) 2007 Stefan Goessner (goessner.net)
 * Licensed under the MIT (MIT-LICENSE.txt) licence.
 * Converted to TypeScript.
 */

interface JsonPathArgs {
  resultType?: "VALUE" | "PATH";
}

interface JsonPathInternal {
  resultType: "VALUE" | "PATH";
  result: any[];
  normalize: (expr: string) => string;
  asPath: (path: string) => string;
  store: (p: string, v: any) => boolean;
  trace: (expr: string, val: any, path: string) => void;
  walk: (
    loc: string,
    expr: string,
    val: any,
    path: string,
    f: (m: string | number, l: string, x: string, v: any, p: string) => void
  ) => void;
  slice: (loc: string, expr: string, val: any, path: string) => void;
  eval: (x: string, _v: any, _vname: string | number) => any;
}

export function jsonPath(
  obj: any,
  expr: string,
  arg?: JsonPathArgs
): any[] | false {
  const P: JsonPathInternal = {
    resultType: arg?.resultType || "VALUE",
    result: [],
    normalize: function (expr: string): string {
      const subx: string[] = [];
      return expr
        .replace(/[\['](\??\(.*?\))[\]']/g, function ($0, $1) {
          return "[#" + (subx.push($1) - 1) + "]";
        })
        .replace(/'?\.'?|\['?/g, ";")
        .replace(/;;;|;;/g, ";..;")
        .replace(/;$|'?\]|'$/g, "")
        .replace(/#([0-9]+)/g, function ($0, $1) {
          return subx[parseInt($1, 10)];
        });
    },
    asPath: function (path: string): string {
      const x: string[] = path.split(";");
      let p: string = "$";
      for (let i = 1, n = x.length; i < n; i++)
        p += /^[0-9*]+$/.test(x[i]) ? "[" + x[i] + "]" : "['" + x[i] + "']";
      return p;
    },
    store: function (p: string, v: any): boolean {
      if (p)
        P.result[P.result.length] = P.resultType === "PATH" ? P.asPath(p) : v;
      return !!p;
    },
    trace: function (expr: string, val: any, path: string): void {
      if (expr) {
        let x: string[] = expr.split(";");
        const loc: string = x.shift()!;
        let remainingExpr: string = x.join(";");

        if (
          val &&
          typeof val === "object" &&
          val !== null &&
          Object.prototype.hasOwnProperty.call(val, loc)
        ) {
          P.trace(remainingExpr, val[loc], path + ";" + loc);
        } else if (loc === "*") {
          P.walk(loc, remainingExpr, val, path, function (m, l, x, v, p) {
            P.trace(m + ";" + x, v, p);
          });
        } else if (loc === "..") {
          P.trace(remainingExpr, val, path);
          P.walk(loc, remainingExpr, val, path, function (m, l, x, v, p) {
            if (typeof v[m] === "object" && v[m] !== null) {
              P.trace("..;" + x, v[m], p + ";" + m);
            }
          });
        } else if (/,/.test(loc)) {
          // [name1,name2,...]
          const s: string[] = loc.split(/'?,'?/);
          for (let i = 0, n = s.length; i < n; i++) {
            P.trace(s[i] + ";" + remainingExpr, val, path);
          }
        } else if (/^\(.*?\)$/.test(loc)) {
          // [(expr)]
          P.trace(
            P.eval(loc, val, path.substring(path.lastIndexOf(";") + 1)) +
              ";" +
              remainingExpr,
            val,
            path
          );
        } else if (/^\?\(.*?\)$/.test(loc)) {
          // [?(expr)]
          P.walk(loc, remainingExpr, val, path, function (m, l, x, v, p) {
            if (P.eval(l.replace(/^\?\((.*?)\)$/, "$1"), v[m], m)) {
              P.trace(m + ";" + x, v, p);
            }
          });
        } else if (/^(-?[0-9]*):(-?[0-9]*):?([0-9]*)$/.test(loc)) {
          // [start:end:step] python slice syntax
          P.slice(loc, remainingExpr, val, path);
        }
      } else {
        P.store(path, val);
      }
    },
    walk: function (
      loc: string,
      expr: string,
      val: any,
      path: string,
      f: (m: string | number, l: string, x: string, v: any, p: string) => void
    ): void {
      if (Array.isArray(val)) {
        for (let i = 0, n = val.length; i < n; i++) {
          if (i in val) {
            f(i, loc, expr, val, path);
          }
        }
      } else if (typeof val === "object" && val !== null) {
        for (const m in val) {
          if (Object.prototype.hasOwnProperty.call(val, m)) {
            f(m, loc, expr, val, path);
          }
        }
      }
    },
    slice: function (loc: string, expr: string, val: any, path: string): void {
      if (Array.isArray(val)) {
        const len: number = val.length;
        let start: number = 0;
        let end: number = len;
        let step: number = 1;
        loc.replace(
          /^(-?[0-9]*):(-?[0-9]*):?(-?[0-9]*)$/g,
          function ($0, $1, $2, $3) {
            start = parseInt($1 || start.toString(), 10);
            end = parseInt($2 || end.toString(), 10);
            step = parseInt($3 || step.toString(), 10);
            return ""; // Required by TS replace signature
          }
        );
        start = start < 0 ? Math.max(0, start + len) : Math.min(len, start);
        end = end < 0 ? Math.max(0, end + len) : Math.min(len, end);
        for (let i = start; i < end; i += step) {
          P.trace(i + ";" + expr, val, path);
        }
      }
    },
    eval: function (x: string, _v: any, _vname: string | number): any {
      // Using Function constructor instead of eval for slightly better isolation,
      // but still carries security risks if 'x' is untrusted.
      // Consider safer alternatives if 'x' can contain arbitrary user input.
      try {
        // @ts-ignore - Allows using _v and _vname in the Function scope
        return new Function(
          "_v",
          "_vname",
          `return (${x.replace(/@/g, "_v")})`
        )(_v, _vname);
      } catch (e: any) {
        throw new SyntaxError(
          "jsonPath: " + e.message + ": " + x.replace(/@/g, "_v")
        );
      }
    },
  };

  const $ = obj; // Alias for the object
  if (expr && obj && (P.resultType === "VALUE" || P.resultType === "PATH")) {
    P.trace(P.normalize(expr).replace(/^\$;/, ""), obj, "$");
    return P.result.length ? P.result : false;
  }
  return false; // Default return if conditions aren't met
}

--- End File: packages/core/src/jsonpath.ts ---

--- File: packages/core/src/logger.ts ---
import { LogLevel } from "./types"; // Assuming LogLevel is defined elsewhere

// --- Interfaces ---

export interface LogEntry {
  level: LogLevel;
  timestamp: Date;
  context: string;
  message: string;
  data?: any;
}

export interface LogFormatter {
  format(entry: LogEntry): string;
}

export interface Transport {
  log(formattedMessage: string, entry: LogEntry): void;
  init?(): Promise<void> | void; // Optional initialization (e.g., open file stream)
  close?(): Promise<void> | void; // Optional cleanup
}

export interface LoggerConfig {
  level: LogLevel;
  transports: Transport[];
  formatter: LogFormatter;
}

// --- Default Implementations ---

export class DefaultFormatter implements LogFormatter {
  private enableTimestamp: boolean;

  constructor(options: { enableTimestamp?: boolean } = {}) {
    this.enableTimestamp = options.enableTimestamp ?? true;
  }

  format(entry: LogEntry): string {
    const parts: string[] = [];

    if (this.enableTimestamp) {
      parts.push(`[${entry.timestamp.toISOString()}]`);
    }

    parts.push(`[${LogLevel[entry.level]}]`); // Assumes LogLevel is an enum
    parts.push(`[${entry.context}]`);
    parts.push(entry.message);

    // Note: Default formatter now DOES NOT stringify data,
    // as transports might want to handle it differently.
    // if (entry.data) {
    //   try {
    //     parts.push(`\n${JSON.stringify(entry.data, null, 2)}`);
    //   } catch (error) {
    //     parts.push("[Unserializable data]");
    //   }
    // }

    return parts.join(" ");
  }
}

const colors: { [key in LogLevel]?: string } = {
  [LogLevel.ERROR]: "\x1b[31m", // Red
  [LogLevel.WARN]: "\x1b[33m", // Yellow
  [LogLevel.INFO]: "\x1b[36m", // Cyan
  [LogLevel.DEBUG]: "\x1b[32m", // Green
  [LogLevel.TRACE]: "\x1b[90m", // Gray
};

const colorReset = "\x1b[0m";

function colorize(message: string, level: LogLevel): string {
  const color = colors[level] || "";
  return `${color}${message}${colorReset}`;
}

// --- UPDATED ConsoleTransport ---
export class ConsoleTransport implements Transport {
  private enableColors: boolean;

  constructor(options: { enableColors?: boolean } = {}) {
    this.enableColors = options.enableColors ?? true;
  }

  log(formattedMessage: string, entry: LogEntry): void {
    const messageParts: any[] = []; // Use array to pass multiple args to console.log

    if (this.enableColors) {
      messageParts.push(colorize(formattedMessage, entry.level));
    } else {
      messageParts.push(formattedMessage);
    }

    // If data exists, log it as a separate argument to console.log
    // This allows the browser/Node console to display it interactively.
    if (entry.data !== undefined) {
      messageParts.push(entry.data);
    }

    // Use appropriate console method based on level
    switch (entry.level) {
      case LogLevel.ERROR:
        console.error(...messageParts);
        break;
      case LogLevel.WARN:
        console.warn(...messageParts);
        break;
      case LogLevel.INFO:
        console.info(...messageParts);
        break;
      case LogLevel.DEBUG:
      case LogLevel.TRACE: // console.debug and console.trace might behave differently
        console.debug(...messageParts); // Or console.log(...messageParts)
        break;
      default:
        console.log(...messageParts);
    }
  }
}

export class Logger {
  private config: LoggerConfig;

  constructor(config: Partial<LoggerConfig>) {
    // Provide defaults if necessary
    const transports =
      !config.transports || config.transports.length === 0
        ? [new ConsoleTransport()]
        : config.transports;

    const formatter = config.formatter ?? new DefaultFormatter();

    this.config = {
      level: config.level ?? LogLevel.INFO,
      transports: transports,
      formatter: formatter,
    };

    // Initialize transports
    this.config.transports.forEach((transport) => {
      if (typeof transport.init === "function") {
        Promise.try(transport.init).catch((err) =>
          console.error("Error initializing transport:", err)
        );
      }
    });
  }

  configure(config: Pick<LoggerConfig, "level">) {
    this.config.level = config.level;
  }

  error(context: string, message: string, data?: any) {
    this.log(LogLevel.ERROR, context, message, data);
  }

  warn(context: string, message: string, data?: any) {
    this.log(LogLevel.WARN, context, message, data);
  }

  info(context: string, message: string, data?: any) {
    this.log(LogLevel.INFO, context, message, data);
  }

  debug(context: string, message: string, data?: any) {
    this.log(LogLevel.DEBUG, context, message, data);
  }

  trace(context: string, message: string, data?: any) {
    this.log(LogLevel.TRACE, context, message, data);
  }

  private log(level: LogLevel, context: string, message: string, data?: any) {
    if (level > this.config.level) return;

    const entry: LogEntry = {
      level,
      timestamp: new Date(),
      context,
      message,
      data,
    };

    const formattedMessage = this.config.formatter.format(entry); // Format the core message

    // Send to all transports (passing both formatted string and raw entry)
    this.config.transports.forEach((transport) => {
      try {
        transport.log(formattedMessage, entry);
      } catch (error) {
        console.error(
          `Error logging to transport ${transport.constructor.name}:`,
          error
        );
      }
    });
  }

  // Method to gracefully close transports
  async close(): Promise<void> {
    for (const transport of this.config.transports) {
      if (typeof transport.close === "function") {
        try {
          await Promise.try(transport.close);
        } catch (err) {
          console.error(
            `Error closing transport ${transport.constructor.name}:`,
            err
          );
        }
      }
    }
  }
}

--- End File: packages/core/src/logger.ts ---

--- File: packages/core/src/memory/base.ts ---
import type { MemoryStore, VectorStore, WorkingMemory } from "../types";
import type { LanguageModelV1 } from "ai";
/**
 * Base memory implementation providing storage and vector capabilities
 */
export type BaseMemory = {
  /** Store for conversation memory data */
  store: MemoryStore;
  /** Store for vector embeddings and similarity search */
  vector: VectorStore;
  vectorModel?: LanguageModelV1;
  generateMemories?: boolean;
};

/**
 * Creates a new BaseMemory instance
 * @param store - Memory store implementation for conversation data
 * @param vector - Vector store implementation for embeddings
 * @param vectorModel - Vector model implementation for embeddings
 * @returns A new BaseMemory instance
 */
export function createMemory(
  store: MemoryStore,
  vector: VectorStore,
  vectorModel?: LanguageModelV1
): BaseMemory {
  return { store, vector, vectorModel };
}

/**
 * Creates a new in-memory store for conversation data
 * @returns A MemoryStore implementation using a Map for storage
 */
export function createMemoryStore(): MemoryStore {
  const data = new Map<string, any>();
  return {
    async keys(base) {
      const keys = Array.from(data.keys());

      if (base) {
        return keys.filter((key) => key.startsWith(base));
      }

      return keys;
    },

    /**
     * Retrieves a value from the store
     * @param key - Key to look up
     * @returns The stored value or null if not found
     */
    async get(key: string) {
      return data.get(key) ?? null;
    },

    /**
     * Removes all entries from the store
     */
    async clear() {
      data.clear();
    },

    /**
     * Removes a specific entry from the store
     * @param key - Key to remove
     */
    async delete(key: string) {
      data.delete(key);
    },

    /**
     * Stores a value in the store
     * @param key - Key to store under
     * @param value - Value to store
     */
    async set(key: string, value: any) {
      data.set(key, value);
    },
  };
}

/**
 * Creates a no-op vector store implementation
 * @returns A VectorStore implementation that performs no operations
 */
export function createVectorStore(): VectorStore {
  return {
    /**
     * No-op implementation of vector store upsert
     * @param contextId - Context ID (unused)
     * @param data - Data to store (unused)
     */
    upsert(contextId: string, data: any[]) {
      return Promise.resolve();
    },

    /**
     * No-op implementation of vector store query
     * @param contextId - Context ID (unused)
     * @param query - Query string (unused)
     * @returns Empty array
     */
    query(contextId: string, query: string) {
      return Promise.resolve([]);
    },

    /**
     * No-op implementation of index creation
     * @param indexName - Name of index to create (unused)
     */
    createIndex(indexName: string) {
      return Promise.resolve();
    },

    /**
     * No-op implementation of index deletion
     * @param indexName - Name of index to delete (unused)
     */
    deleteIndex(indexName: string) {
      return Promise.resolve();
    },
  };
}

--- End File: packages/core/src/memory/base.ts ---

--- File: packages/core/src/memory/index.ts ---
export * from "./base";

--- End File: packages/core/src/memory/index.ts ---

--- File: packages/core/src/memory/utils.ts ---
import { generateObject } from "ai";
import { openai } from "@ai-sdk/openai";
import type {
  AnyAgent,
  Episode,
  ActionResult,
  Action,
  Thought,
  ActionCall,
  AnyAction,
} from "../types";
import { z } from "zod";
import { v7 as randomUUIDv7 } from "uuid";

// Check if we're in a browser environment
const isBrowser =
  typeof window !== "undefined" && typeof window.document !== "undefined";

// Conditionally import Node.js modules
let fs: any;
let path: any;

if (!isBrowser) {
  // Only import in Node.js environment
  // Using dynamic import to avoid browser errors
  try {
    fs = require("fs");
    path = require("path");
  } catch (e) {
    console.warn("File system modules not available in this environment");
  }
}

export const generateEpisodicMemory = async (
  agent: AnyAgent,
  thoughts: Thought[],
  actions: Action[],
  results: ActionResult[]
): Promise<{
  observation: string;
  thoughts: string;
  result: string;
}> => {
  const extractEpisode = await generateObject({
    model: agent.memory.vectorModel || openai("gpt-4-turbo"),
    schema: z.object({
      observation: z.string().describe("The context and setup - what happened"),
      thoughts: z
        .string()
        .describe(
          "Internal reasoning process and observations of the agent in the episode that let it arrive at the correct action and result. 'I ...'"
        ),
      result: z
        .string()
        .describe(
          "Outcome and retrospective. What did you do well? What could you do better next time? I ..."
        ),
    }),
    prompt: `
    You are creating an episodic memory for an AI agent to help it recall and learn from past experiences.
    
    Your task is to analyze the agent's thoughts, actions, and the results of those actions to create a structured memory that can be used for future reference and learning.

    ## Context
    <thoughts>
    ${JSON.stringify(thoughts)}
    </thoughts>

    ## Actions Taken
    <actions>
    ${JSON.stringify(actions)}
    </actions>

    ## Results & Outcomes
    <results>
    ${JSON.stringify(results)}
    </results>
    
    ## Instructions
    Create a comprehensive episodic memory with these components:
    
    1. OBSERVATION: Provide a clear, concise description of the situation, context, and key elements. Include:
       - What was the environment or scenario?
       - What was the agent trying to accomplish?
       - What were the initial conditions or constraints?
    
    2. THOUGHTS: Capture the agent's internal reasoning process that led to its actions:
       - What was the agent's understanding of the situation?
       - What strategies or approaches did it consider?
       - What key insights or realizations occurred during the process?
       - Use first-person perspective ("I realized...", "I considered...")
    
    3. RESULT: Summarize the outcomes and provide a retrospective analysis:
       - What was accomplished or not accomplished?
       - What worked well and what didn't?
       - What lessons can be learned for future similar situations?
       - What would be done differently next time?
       - Use first-person perspective ("I succeeded in...", "Next time I would...")
    
    Make the memory detailed enough to be useful for future recall, but concise enough to be quickly processed. Focus on capturing the essence of the experience, key decision points, and lessons learned.`,
  });

  return {
    observation: extractEpisode.object.observation,
    thoughts: extractEpisode.object.thoughts,
    result: extractEpisode.object.result,
  };
};

/**
 * Creates a training data pair from episodic memory
 * @param episodicMemory The episodic memory generated
 * @returns A prompt-completion pair for training data
 */
export function createTrainingDataPair(episodicMemory: {
  observation: string;
  thoughts: string;
  result: string;
}): {
  prompt: string;
  completion: string;
} {
  // Create a simple prompt with the observation
  const prompt = episodicMemory.observation;

  // Create a simple completion with thoughts and result
  const completion = `${episodicMemory.thoughts}\n\n${episodicMemory.result}`;

  return {
    prompt,
    completion,
  };
}

/**
 * Saves training data to a JSON lines file
 * @param trainingData Array of prompt-completion pairs
 * @param filePath Path to save the file
 */
export async function saveTrainingData(
  trainingData: Array<{ prompt: string; completion: string }>,
  filePath: string
): Promise<void> {
  // Skip in browser environment
  if (isBrowser) {
    console.warn("saveTrainingData is not supported in browser environments");
    return;
  }

  try {
    // Ensure fs is available
    if (!fs) {
      console.warn("File system module not available");
      return;
    }

    // Ensure directory exists
    const dir = path.dirname(filePath);
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }

    // Convert each object to a JSON string and join with newlines
    const jsonLines = trainingData
      .map((item) => JSON.stringify(item))
      .join("\n");

    // Write to file
    fs.writeFileSync(filePath, jsonLines, "utf8");
  } catch (error) {
    console.error("Error saving training data:", error);
    throw error;
  }
}

/**
 * Creates an episode from working memory components
 * @param thoughts The thoughts that led to the actions
 * @param actions The actions taken
 * @param results The results of the actions
 * @param agent The agent that generated the episode
 * @param options Optional configuration for exporting training data
 * @param options.exportTrainingData Whether to export this episode as training data
 * @param options.trainingDataPath Path to save the training data
 * @returns A new Episode object
 */
export async function createEpisodeFromWorkingMemory(
  thoughts: Thought[],
  actions: Action[],
  results: ActionResult[],
  agent: AnyAgent,
  options?: {
    exportTrainingData?: boolean;
    trainingDataPath?: string;
  }
): Promise<Episode> {
  const episodicMemory = await generateEpisodicMemory(
    agent,
    thoughts,
    actions,
    results
  );

  // If exportTrainingData is true and not in browser, create and save training data
  if (options?.exportTrainingData && !isBrowser && fs) {
    const trainingDataPair = createTrainingDataPair(episodicMemory);

    // Default path if not provided
    const filePath = options.trainingDataPath || "./training-data.jsonl";

    // Check if file exists to append or create new
    let existingData: Array<{ prompt: string; completion: string }> = [];
    if (fs.existsSync(filePath)) {
      const fileContent = fs.readFileSync(filePath, "utf8");
      existingData = fileContent
        .split("\n")
        .filter((line: string) => line.trim() !== "")
        .map((line: string) => JSON.parse(line));
    }

    // Add new training data pair
    existingData.push(trainingDataPair);

    // Save updated training data
    await saveTrainingData(existingData, filePath);
  }

  return {
    id: randomUUIDv7(),
    timestamp: Date.now(),
    observation: episodicMemory.observation,
    result: episodicMemory.result,
    thoughts: episodicMemory.thoughts,
  };
}

/**
 * Exports all episodes as training data
 * @param episodes Array of episodes to export
 * @param filePath Path to save the training data
 */
export async function exportEpisodesAsTrainingData(
  episodes: Episode[],
  filePath: string = "./training-data.jsonl"
): Promise<void> {
  // Skip in browser environment
  if (isBrowser) {
    console.warn(
      "exportEpisodesAsTrainingData is not supported in browser environments"
    );
    return;
  }

  // Ensure fs is available
  if (!fs) {
    console.warn("File system module not available");
    return;
  }

  const trainingData = episodes.map((episode) => ({
    prompt: episode.observation,
    completion: `${episode.thoughts}\n\n${episode.result}`,
  }));

  await saveTrainingData(trainingData, filePath);
}

export async function generateEpisode(
  thought: Thought,
  actionCall: ActionCall,
  result: ActionResult,
  agent: AnyAgent,
  contextId: string,
  actions: AnyAction[]
) {
  // Find the corresponding Action for the ActionCall
  const action = actions.find((a) => a.name === actionCall.name);

  if (!action) {
    return;
  }

  const thoughts = [thought];
  const actionsArray = [action];
  const results = [result];

  const episode = await createEpisodeFromWorkingMemory(
    thoughts,
    actionsArray,
    results,
    agent,
    {
      exportTrainingData: agent.exportTrainingData === true,
      trainingDataPath: agent.trainingDataPath || "./training-data.jsonl",
    }
  );

  await agent.memory.vector.upsert(`${contextId}`, [
    {
      id: episode.id,
      text: episode.observation,
      metadata: episode,
    },
  ]);
}

--- End File: packages/core/src/memory/utils.ts ---

--- File: packages/core/src/prompt.ts ---
import { ZodType } from "zod";
import zodToJsonSchema from "zod-to-json-schema";
import type { Node, ElementNode } from "./xml";
import { parse as parseXML } from "./xml";
import type { TemplateVariables } from "./types";
import { render } from "./formatters";

export type Formatter<
  Variables extends Record<string, any> = Record<string, any>,
  Data = any,
> = (data: Data) => Record<keyof Variables, any>;

export type InferFormatter<TPrompt extends AnyPrompt> =
  TPrompt extends Prompt<infer Data, infer Variables>
    ? Formatter<Variables, Data>
    : never;

export type PromptVisitor<
  Output = any,
  Attributes extends Record<string, any> = Record<string, any>,
> = (
  output: Output,
  node: ElementNode<Attributes>,
  parse: () => Node[]
) => void;

export type GetVisitors<
  Output = any,
  T extends Record<string, Record<string, any>> = Record<
    string,
    Record<string, any>
  >,
> = {
  [K in keyof T]?: PromptVisitor<Output, T[K]>;
} & {
  [key: string]: PromptVisitor<Output, any>;
};

export type Prompt<
  Data = any,
  Variables extends Record<string, any> = Record<string, any>,
> = <TData extends Data>(
  data: TData,
  formatter?: Formatter<Variables, TData>
) => string;

export type AnyPrompt = Prompt<any, any>;

export type InferPromptVariables<TPrompt extends AnyPrompt> =
  TPrompt extends Prompt<any, infer Vars> ? Vars : never;

export type InferPromptData<TPrompt extends AnyPrompt> =
  TPrompt extends Prompt<infer Data> ? Data : never;

export type GeneratePromptConfig<
  TPrompt extends AnyPrompt | string = any,
  Variables extends Record<string, any> = any,
  Data = Record<string, any>,
  TFormatter extends Formatter<Variables, Data> = Formatter<Variables, Data>,
> = {
  template: TPrompt;
  variables: Variables;
  data: Data;
  formatter?: TFormatter;
};

export type InferGeneratePromptConfig<TPrompt extends AnyPrompt | string> =
  | (TPrompt extends Prompt<infer Data, infer Variables>
      ? GeneratePromptConfig<TPrompt, Variables, Data>
      : never)
  | (TPrompt extends string
      ? GeneratePromptConfig<TPrompt, TemplateVariables<TPrompt>>
      : never);

export type InferPromptComponents<TPrompt extends AnyPrompt | string> =
  TPrompt extends Prompt<any, infer Components> ? Components : never;

export function getZodJsonSchema(schema: ZodType<any>) {
  return zodToJsonSchema(schema, "schema").definitions!.schema;
}

export function createPrompt<
  Template extends string = string,
  Variables extends TemplateVariables<Template> = TemplateVariables<Template>,
  Data extends Record<string, any> = Record<string, any>,
>(
  prompt: Template,
  formatter?: Formatter<Variables, Data>
): Prompt<Data, Variables> {
  return (data, customFormatter) => {
    return render(
      prompt,
      customFormatter
        ? customFormatter(data)
        : formatter
          ? formatter(data)
          : data
    );
  };
}

export type Parser<Output> = (content: string) => Output;

export function createParser<
  Output = any,
  Components extends Record<string, Record<string, any>> = Record<
    string,
    Record<string, any>
  >,
  Visitors extends GetVisitors<Output, Components> = GetVisitors<
    Output,
    Components
  >,
>(getOutput: () => Output, visitors: Visitors): Parser<Output> {
  return (content) => {
    const validTags = new Set(Object.keys(visitors));

    // fix for bad outputs;

    content = content
      .split("\n")
      .map((line) => {
        // Check if line starts with '/'
        if (line.startsWith("/")) {
          // Extract the tag name using regex
          const match = line.match(/^\/([^ >]+)/);

          if (match && match[1]) {
            const tagName = match[1];

            // Check if this is a valid tag
            if (validTags.has(tagName)) {
              console.log("fixing line:\n" + line);
              // Replace the leading '/' with '<'
              return line.replace("/", "<");
            }
          }
        }

        // Return original line if no fix needed
        return line;
      })
      .join("\n");

    const state = getOutput();

    parseXML(content, (node, parse) => {
      if (node.type === "element" && node.name in visitors) {
        visitors[node.name](state, node as ElementNode<any>, parse);
      }
      return node;
    });

    return state;
  };
}

--- End File: packages/core/src/prompt.ts ---

--- File: packages/core/src/prompts/main.ts ---
import { formatWorkingMemory } from "../context";
import {
  formatAction,
  formatContextLog,
  formatContextState,
  formatOutputInterface,
  render,
  xml,
} from "../formatters";
import type { Prompt } from "../prompt";
import type {
  AnyAction,
  AnyContext,
  ContextState,
  Output,
  WorkingMemory,
} from "../types";
/*

## Instructions
- If asked for something - never do a summary unless you are asked to do a summary. Always respond with the exact information requested.
- You must use the available actions and outputs to respond to the context.
- You must reason about the context, think, and planned actions.
- IMPORTANT: If you state that you will perform an action, you MUST issue the corresponding action call. Do not say you will do something without actually issuing the action call.
- IMPORTANT: Never end your response with a plan to do something without actually doing it. Always follow through with action calls.
- When you determine that no further actions or outputs are needed and the flow should end, use the <finalize/> tag to indicate completion.
*/

export const templateSections = {
  intro: `\
  You are tasked with analyzing inputs, formulating outputs, and initiating actions based on the given contexts. 
  You will be provided with a set of available actions, outputs, and contexts. 
  Your instructions are to analyze the situation and respond appropriately.`,
  instructions: `\
Follow these steps to process the updates:

1. Analyze the updates and available data:
   Wrap your reasoning process in <reasoning> tags. Consider:

   - Check the available data to avoid redundant action calls
   - The availabe contexts and their state
   - The available actions and their asynchronous nature
   - The content of the new updates
   - Potential dependencies between actions

   Response determination guidelines:

   a) First check if required state exists in the available contexts
   b) Respond to direct questions or requests for information

2. Plan actions:
   Before formulating a response, consider:

   - What data is already available
   - Which actions need to be initiated
   - The order of dependencies between actions
   - How to handle potential action failures
   - What information to provide while actions are processing

3. Formulate a output (if needed):
   If you decide to respond to the message, use <output> tags to enclose your output.
   Consider:

   - Using available data when possible
   - Acknowledging that certain information may not be immediately available
   - Setting appropriate expectations about action processing time
   - Indicating what will happen after actions complete
   - You can only use outputs listed in the <available_outputs> section
   - Follow the schemas provided for each output
  
4. Initiate actions (if needed):
   Use <action_call> tags to initiate actions. Remember:

   - Actions are processed asynchronously after your response
   - Results will not be immediately available
   - You can only use actions listed in the <available_actions> section
   - Follow the schemas provided for each action
   - Actions should be used when necessary to fulfill requests or provide information that cannot be conveyed through a simple response
   - If action belongs to a context and there is many instances of the context use <action_call contextKey="[Context key]">

5. No output or action:
   If you determine that no output or action is necessary, don't respond to that message.`,
  /*
   */
  /*

Configuration: Access pre-defined configuration values using {{config.key.name}} (e.g., {{config.default_user_id}}). (Assumption: Configuration is structured)

 (e.g., {{shortTermMemory.current_project_file}}).

*/
  content: `\
Here are the available actions you can initiate:
{{actions}}

Here are the available outputs you can use:
{{outputs}}

Here is the current contexts:
{{contexts}}

<template-engine>
Purpose: Utilize the template engine ({{...}} syntax) primarily to streamline workflows by transferring data between different components within the same turn. This includes passing outputs from actions into subsequent action arguments, or embedding data from various sources directly into response outputs. This enhances efficiency and reduces interaction latency.

Data Referencing: You can reference data from:
Action Results: Use {{calls[index].path.to.value}} to access outputs from preceding actions in the current turn (e.g., {{calls[0].sandboxId}}). Ensure the index correctly points to the intended action call.
Short-Term Memory: Retrieve values stored in short-term memory using {{shortTermMemory.key}}

When to Use:
Data Injection: Apply templating when an action argument or a response output requires specific data (like an ID, filename, status, or content) from an action result, configuration, or short-term memory available within the current turn.
Direct Dependencies: Particularly useful when an action requires a specific result from an action called immediately before it in the same turn.
</template-engine>

Here is the current working memory:
{{workingMemory}}

Now, analyze the following updates:
{{updates}}`,
  response: `\
Here's how you structure your response:
<response>
<reasoning>
[Your reasoning of the context, think, messages, and planned actions]
</reasoning>

[List of async action calls to be initiated, if applicable]
<action_call name="[Action name]">[action arguments using the schema and format]</action_call>

[List of outputs, if applicable]
<output type="[Output type]" {...output attributes using the attributes_schema}>
[output content using the content_schema]
</output>
</response>`,

  footer: `\
Remember:
- Always correlate results with their original actions using callId
- Never repeat your outputs
- Consider the complete chain of events when formulating responses
- Address any failures or unexpected results explicitly
- Initiate follow-up actions only when necessary
- Provide clear, actionable insights based on the combined results
- Maintain context awareness between original request and final results

IMPORTANT: 
Always include the 'type' attribute in the output tag and ensure it matches one of the available output types listed above.
Remember to include the other attribute in the output tag and ensure it matches the output attributes schema.
If you say you will perform an action, you MUST issue the corresponding action call here
Always check the correct format for each action: JSON or XML
`,
} as const;

export const promptTemplate = `\
{{intro}}

{{instructions}}

{{content}}

{{response}}

{{footer}}
`;

export function formatPromptSections({
  contexts,
  outputs,
  actions,
  workingMemory,
  maxWorkingMemorySize,
  chainOfThoughtSize,
}: {
  contexts: ContextState<AnyContext>[];
  outputs: Output[];
  actions: AnyAction[];
  workingMemory: WorkingMemory;
  maxWorkingMemorySize?: number;
  chainOfThoughtSize?: number;
}) {
  return {
    actions: xml("available-actions", undefined, actions.map(formatAction)),
    outputs: xml(
      "available-outputs",
      undefined,
      outputs.map(formatOutputInterface)
    ),
    contexts: xml("contexts", undefined, contexts.map(formatContextState)),
    workingMemory: xml(
      "working-memory",
      undefined,
      formatWorkingMemory({
        memory: workingMemory,
        size: maxWorkingMemorySize,
        processed: true,
      })
    ),
    thoughts: xml(
      "thoughts",
      undefined,
      workingMemory.thoughts
        .map((log) => formatContextLog(log))
        .slice(-(chainOfThoughtSize ?? 5))
    ),
    updates: xml(
      "updates",
      undefined,
      formatWorkingMemory({
        memory: workingMemory,
        processed: false,
      })
    ),
  };
}

// WIP
export const mainPrompt = {
  name: "main",
  template: promptTemplate,
  sections: templateSections,
  render: (data: ReturnType<typeof formatPromptSections>) => {
    const sections = Object.fromEntries(
      Object.entries(mainPrompt.sections).map(([key, templateSection]) => [
        key,
        render(templateSection, data as any),
      ])
    ) as Record<keyof typeof templateSections, string>;
    return render(mainPrompt.template, sections);
  },
  formatter: formatPromptSections,
} as const;

export type PromptConfig = typeof mainPrompt;

--- End File: packages/core/src/prompts/main.ts ---

--- File: packages/core/src/providers/api.ts ---
/**
 * A generic response shape for GraphQL queries.
 */
interface GraphQLResponse<T> {
  data?: T;
  errors?: Array<{
    message: string;
    locations?: Array<{
      line: number;
      column: number;
    }>;
    path?: string[];
  }>;
}

/**
 * A generalized error type for convenience.
 */
class ApiError extends Error {
  constructor(
    public message: string,
    public details?: unknown
  ) {
    super(message);
  }
}

/**
 * A helper function to perform generic REST requests.
 * - `url`: full endpoint (including protocol, domain, path)
 * - `options`: standard `fetch` options such as method, headers, body, etc.
 */
export async function fetchRest<ResponseType = unknown>(
  url: string,
  options: RequestInit = {}
): Promise<ResponseType> {
  try {
    const res = await fetch(url, options);
    if (!res.ok) {
      throw new ApiError(`HTTP Error: ${res.status} ${res.statusText}`, {
        status: res.status,
        statusText: res.statusText,
      });
    }
    return (await res.json()) as ResponseType;
  } catch (error) {
    throw error instanceof ApiError
      ? error
      : new ApiError("Unknown error during REST fetch", error);
  }
}

/**
 * A helper function to perform GraphQL queries.
 * - `endpoint`: the GraphQL endpoint URL.
 * - `query`: the GraphQL query string.
 * - `variables`: an optional variables object for the query.
 */
export async function fetchGraphQL<DataType = unknown>(
  endpoint: string,
  query: string,
  variables?: Record<string, unknown>
): Promise<DataType | Error> {
  try {
    const res = await fetch(endpoint, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        query,
        variables,
      }),
    });

    if (!res.ok) {
      throw new ApiError(`HTTP Error: ${res.status} ${res.statusText}`, {
        status: res.status,
        statusText: res.statusText,
      });
    }

    const result = (await res.json()) as GraphQLResponse<DataType>;

    if (result.errors && result.errors.length > 0) {
      return new ApiError(result.errors[0].message, result.errors);
    }

    if (!result.data) {
      return new ApiError("No data returned from GraphQL query");
    }

    return result.data;
  } catch (error) {
    return error instanceof ApiError
      ? error
      : new ApiError("Unknown error during GraphQL fetch", error);
  }
}

--- End File: packages/core/src/providers/api.ts ---

--- File: packages/core/src/providers/index.ts ---
export { fetchGraphQL } from "./api";

--- End File: packages/core/src/providers/index.ts ---

--- File: packages/core/src/serviceProvider.ts ---
import type { Container } from "./container";

type ServiceProvider = {
  register?: (container: Container) => void;
  boot?: (container: Container) => void | Promise<void>;
};

type ServiceState = {
  providers: ServiceProvider[];
  booted: Set<ServiceProvider>;
  registered: Set<ServiceProvider>;
};

type ServiceManager = {
  register: (provider: ServiceProvider) => void;
  bootAll: () => Promise<void>;
  isBooted: (provider: ServiceProvider) => boolean;
  isRegistered: (provider: ServiceProvider) => boolean;
};

const service = (config: ServiceProvider): ServiceProvider => config;

const createServiceManager = (container: Container): ServiceManager => {
  const state: ServiceState = {
    providers: [],
    booted: new Set(),
    registered: new Set(),
  };

  const registerProvider = (
    container: Container,
    provider: ServiceProvider
  ): void => {
    if (state.registered.has(provider)) return;
    state.registered.add(provider);
    if (provider.register) provider.register(container);
  };

  const bootProvider = async (
    container: Container,
    provider: ServiceProvider
  ): Promise<void> => {
    if (state.booted.has(provider)) return;
    state.booted.add(provider);
    if (provider.boot) await provider.boot(container);
  };

  return {
    register: (provider: ServiceProvider): void => {
      if (!state.providers.includes(provider)) {
        state.providers.push(provider);
        registerProvider(container, provider);
      }
    },

    bootAll: async (): Promise<void> => {
      // First register all providers
      for (const provider of state.providers) {
        registerProvider(container, provider);
      }

      // Then boot them
      for (const provider of state.providers) {
        await bootProvider(container, provider);
      }
    },

    isBooted: (provider: ServiceProvider): boolean =>
      state.booted.has(provider),

    isRegistered: (provider: ServiceProvider): boolean =>
      state.registered.has(provider),
  };
};

export {
  createServiceManager,
  service,
  type ServiceProvider,
  type ServiceManager,
};

--- End File: packages/core/src/serviceProvider.ts ---

--- File: packages/core/src/streaming.ts ---
import type { Log, LogChunk } from "./types";
import { randomUUIDv7 } from "./utils";
import { xmlStreamParser } from "./xml";

type PartialLog = Partial<Log> &
  Pick<Log, "ref" | "id" | "timestamp" | "processed">;

export type StackElement = {
  index: number;
  tag: string;
  attributes: Record<string, any>;
  content: string;
  done: boolean;
  _depth: number;
};

export type StackElementChunk =
  | { type: "el"; el: StackElement }
  | { type: "content"; index: number; content: string }
  | { type: "end"; index: number };

export async function handleStream(
  textStream: AsyncGenerator<string>,
  initialIndex: number,
  tags: Set<string>,
  push: (el: StackElement) => void,
  __pushChunk?: (chunk: StackElementChunk) => void
) {
  let current: StackElement | undefined = undefined;
  let stack: StackElement[] = [];

  let index = initialIndex;

  const parser = xmlStreamParser(tags, (tag, isClosingTag) => {
    if (current?.tag === tag && !isClosingTag && tag === "think") {
      return false;
    }

    if (current?.tag === tag && !isClosingTag && tag === "response") {
      return false;
    }

    if (current?.tag === tag && !isClosingTag && tag === "reasoning") {
      return false;
    }

    if (current?.tag === tag && !isClosingTag) {
      current._depth++;
      return false;
    }

    if (current?.tag === tag && isClosingTag) {
      if (current._depth > 0) {
        current._depth--;
        return false;
      }

      return true;
    }

    if (current === undefined || current?.tag === "response") return true;

    if (isClosingTag && stack.length > 0) {
      const stackIndex = stack.findIndex((el) => el.tag === tag);
      if (stackIndex === -1) return false;

      if (current) {
        push({
          ...current,
          done: true,
        });

        __pushChunk?.({ type: "end", index: current.index });

        current = undefined;
      }

      const closed = stack.splice(stackIndex + 1).reverse();

      for (const el of closed) {
        push({
          ...el,
          done: true,
        });

        __pushChunk?.({ type: "end", index: el.index });
      }

      current = stack.pop();

      return true;
    }

    return false;
  });

  parser.next();

  function handleChunk(chunk: string) {
    let result = parser.next(chunk);
    while (!result.done && result.value) {
      if (result.value.type === "start") {
        if (current) stack.push(current);
        current = {
          index: index++,
          tag: result.value.name,
          attributes: result.value.attributes,
          content: "",
          done: false,
          _depth: 0,
        };

        push(current);

        __pushChunk?.({ type: "el", el: structuredClone(current) });
      }

      if (result.value.type === "end") {
        if (current) {
          push({
            ...current,
            done: true,
          });

          __pushChunk?.({ type: "end", index: current.index });

          current = stack.pop();
        }
      }

      if (result.value.type === "text") {
        if (current) {
          __pushChunk?.({
            type: "content",
            index: current.index,
            content: result.value.content,
          });

          current.content += result.value.content;
          push(current);
        }

        // todo: we need to handle text when !current to a default output?
      }

      if (result.value.type === "self-closing") {
        const el = {
          index: index++,
          tag: result.value.name,
          attributes: result.value.attributes,
          content: "",
          done: true,
          _depth: 0,
        };

        push(el);

        __pushChunk?.({ type: "el", el });
      }
      result = parser.next();
    }
  }

  for await (const chunk of textStream) {
    handleChunk(chunk);
  }

  parser.return?.();
}

export async function* wrapStream(
  stream: AsyncIterable<string>,
  prefix: string,
  suffix: string
) {
  yield prefix;
  yield* stream;
  yield suffix;
}

const defaultTags = new Set([
  "think",
  "thinking",
  "response",
  "output",
  "action_call",
  "reasoning",
]);

export function createContextStreamHandler({
  abortSignal,
  pushLog,
  __pushLogChunk,
}: {
  abortSignal?: AbortSignal;
  pushLog: (log: Log, done: boolean) => void;
  __pushLogChunk?: (chunk: LogChunk) => void;
}) {
  const streamState = {
    index: 0,
    logsByIndex: new Map<number, PartialLog>(),
  };

  function getOrCreateRef<
    TLog extends Omit<PartialLog, "id" | "timestamp" | "processed">,
  >(
    index: number,
    ref: TLog
  ): TLog & Pick<PartialLog, "id" | "timestamp" | "processed"> {
    if (!streamState.logsByIndex.has(index)) {
      streamState.logsByIndex.set(index, {
        id: randomUUIDv7(),
        timestamp: Date.now(),
        processed: false,
        ...ref,
      });
    }

    streamState.index = Math.max(index, streamState.index);

    return streamState.logsByIndex.get(index)! as TLog &
      Pick<PartialLog, "id" | "timestamp" | "processed">;
  }

  function __streamChunkHandler(chunk: StackElementChunk) {
    if (abortSignal?.aborted) return;

    switch (chunk.type) {
      case "el": {
        const { el } = chunk;

        switch (el.tag) {
          case "think":
          case "thinking":
          case "reasoning": {
            const ref = getOrCreateRef(el.index, {
              ref: "thought",
            });

            __pushLogChunk?.({
              type: "log",
              log: {
                ...ref,
                content: "",
              },
              done: el.done,
            });

            break;
          }

          case "action_call": {
            const ref = getOrCreateRef(el.index, {
              ref: "action_call",
            });

            const { name, ...params } = el.attributes;

            __pushLogChunk?.({
              type: "log",
              log: {
                ...ref,
                name,
                params,
                content: "",
                data: undefined,
                processed: false,
              },
              done: el.done,
            });

            break;
          }

          case "output": {
            const ref = getOrCreateRef(el.index, {
              ref: "output",
            });

            const { type, ...params } = el.attributes;

            __pushLogChunk?.({
              type: "log",
              log: {
                ...ref,
                type,
                params,
                content: "",
                data: undefined,
              },
              done: el.done,
            });

            break;
          }

          default:
            break;
        }

        break;
      }
      case "content": {
        const log = streamState.logsByIndex.get(chunk.index);
        if (log) {
          __pushLogChunk?.({
            type: "content",
            id: log.id,
            content: chunk.content,
          });
        }
        break;
      }

      case "end": {
        const log = streamState.logsByIndex.get(chunk.index);
        if (log) {
          __pushLogChunk?.({
            type: "done",
            id: log.id,
          });
        }
        break;
      }
    }
  }

  function streamHandler(el: StackElement) {
    if (abortSignal?.aborted) return;
    switch (el.tag) {
      case "think":
      case "thinking":
      case "reasoning": {
        const ref = getOrCreateRef(el.index, {
          ref: "thought",
        });
        pushLog(
          {
            ...ref,
            content: el.content,
          },
          el.done
        );
        break;
      }
      case "action_call": {
        const ref = getOrCreateRef(el.index, {
          ref: "action_call",
        });
        const { name, ...params } = el.attributes;
        pushLog(
          {
            ...ref,
            name,
            params,
            content: el.content,
            data: undefined,
            processed: false,
          },
          el.done
        );
        break;
      }
      case "output": {
        const ref = getOrCreateRef(el.index, {
          ref: "output",
        });
        const { type, ...params } = el.attributes;
        pushLog(
          {
            ...ref,
            type,
            params,
            content: el.content,
            data: undefined,
          },
          el.done
        );
        break;
      }
      default:
        break;
    }
  }

  return {
    streamState,
    streamHandler,
    tags: defaultTags,
    __streamChunkHandler,
  };
}

--- End File: packages/core/src/streaming.ts ---

--- File: packages/core/src/task.ts ---
import { v7 as randomUUIDv7 } from "uuid";
import type { MaybePromise } from "./types";
import pDefer, { type DeferredPromise } from "p-defer";

type TaskContext = {
  taskId: string;
  abortSignal: AbortSignal;
};

type TaskOptions = {
  concurrency?: number;
  retry?: number | boolean | ((failureCount: number, err: unknown) => boolean);
  priority?: number;
  queueKey?: string;
  timeoutMs?: number;
};

export type Task<Params = any, Result = any, TError = any> = {
  key: string;
  handler: (params: Params, ctx: TaskContext) => MaybePromise<Result>;
  concurrency?: number;
  retry?: boolean | number | ((failureCount: number, error: TError) => boolean);
  priority?: number;
  queueKey?: string;
  timeoutMs?: number;
};

type InferTaskParams<T extends Task<any, any>> =
  T extends Task<infer Params, any> ? Params : unknown;
type InferTaskResult<T extends Task<any, any>> =
  T extends Task<any, infer Result> ? Result : unknown;

type TaskInstance<TTask extends Task<any, any> = Task<any, any>> = {
  id: string;
  task: TTask;
  params: InferTaskParams<TTask>;
  options: Omit<TaskOptions, "concurrency">;
  createdAt: Date;
  attempts: number;
  controller: AbortController;
  promise: DeferredPromise<InferTaskResult<TTask>>;
  lastError?: unknown;
};

type Queue = {
  concurrency: number;
  tasks: TaskInstance[];
  running: Set<string>;
};

export class TaskRunner {
  queues = new Map<string, Queue>();
  processing = new Set<string>();

  constructor(concurrency: number) {
    this.queues.set("main", { concurrency, tasks: [], running: new Set() });
  }

  setQueue(queueKey: string, concurrency: number) {
    const queue = this.queues.get(queueKey);

    this.queues.set(queueKey, {
      tasks: queue?.tasks ?? [],
      running: queue?.running ?? new Set(),
      concurrency,
    });
  }

  private processQueue(queueKey: string) {
    if (this.processing.has(queueKey)) return;

    const queue = this.queues.get(queueKey);
    if (!queue) return;

    this.processing.add(queueKey);

    try {
      while (queue.tasks.length > 0 && queue.running.size < queue.concurrency) {
        queue.tasks.sort(
          (a, b) => (b.options.priority ?? 0) - (a.options.priority ?? 0)
        );
        const instance = queue.tasks.shift();

        if (!instance) break;

        queue.running.add(instance.id);

        this.processTask(instance)
          .then((res) => {
            instance.promise.resolve(res);
          })
          .catch((err) => {
            instance.promise.reject(err);
          })
          .finally(() => {
            queue.running.delete(instance.id);
            this.processQueue(queueKey);
          });
      }
    } finally {
      this.processing.delete(queueKey);
    }
  }

  private async processTask(instance: TaskInstance) {
    while (true) {
      instance.attempts++;

      if (instance.attempts > 1) {
        await new Promise<void>((resolve) =>
          setTimeout(resolve, 250 * instance.attempts)
        );
      }

      instance.controller.signal.throwIfAborted();

      try {
        const result = await instance.task.handler(instance.params, {
          taskId: instance.id,
          abortSignal: instance.controller.signal,
        });

        return result;
      } catch (error) {
        const retry = instance.options.retry;

        if (retry) {
          if (typeof retry === "boolean" && retry) continue;
          if (typeof retry === "number" && retry >= instance.attempts) continue;
          if (typeof retry === "function" && retry(instance.attempts, error))
            continue;
        }

        throw error;
      }
    }
  }

  async enqueueTask<TTask extends Task<any, any, any>>(
    task: TTask,
    params: InferTaskParams<TTask>,
    options?: Omit<TaskOptions, "concurrency"> & { abortSignal?: AbortSignal }
  ): Promise<InferTaskResult<TTask>> {
    const queueKey = options?.queueKey ?? "main";

    if (!this.queues.has(queueKey)) {
      throw new Error("Invalid queue");
    }

    const { key, handler, ...defaultTaskToptions } = task;

    const controller = new AbortController();
    const deferPromise = pDefer<InferTaskResult<TTask>>();

    const instance: TaskInstance<TTask> = {
      id: randomUUIDv7(),
      task,
      params,
      options: {
        ...defaultTaskToptions,
        ...options,
      },
      controller,
      attempts: 0,
      createdAt: new Date(),
      promise: deferPromise,
    };

    if (instance.options?.timeoutMs) {
      const timeoutSignal = AbortSignal.timeout(instance.options.timeoutMs);

      timeoutSignal.addEventListener(
        "abort",
        () => {
          controller.abort(timeoutSignal.reason);
        },
        {
          once: true,
          signal: controller.signal,
        }
      );
    }

    if (options?.abortSignal) {
      function signalListener() {
        controller.abort(options!.abortSignal!.reason);
      }

      options.abortSignal.addEventListener("abort", signalListener, {
        once: true,
        signal: controller.signal,
      });
    }

    controller.signal.addEventListener(
      "abort",
      () => {
        deferPromise.reject(controller.signal.reason);
      },
      {
        once: true,
      }
    );

    this.queues.get(queueKey)!.tasks.push(instance);

    setTimeout(() => this.processQueue(queueKey), 0);

    return deferPromise.promise;
  }
}

export function task<Params = any, Result = any>(
  definition: Task<Params, Result>
) {
  return definition;
}

--- End File: packages/core/src/task.ts ---

--- File: packages/core/src/tasks/index.ts ---
import {
  streamText,
  type CoreMessage,
  type LanguageModelV1,
  type StreamTextResult,
  type ToolSet,
} from "ai";
import { task } from "../task";
import type {
  Action,
  ActionCallContext,
  AnyAction,
  AnyAgent,
  AnyContext,
  WorkingMemory,
} from "../types";
import type { Logger } from "../logger";
import { wrapStream } from "../streaming";
import { modelsResponseConfig, reasoningModels } from "../configs";

/**
 * Prepares a stream response by handling the stream result and parsing it.
 *
 * @param options - Configuration options
 * @param options.contextId - The ID of the context
 * @param options.step - The current step in the process
 * @param options.stream - The stream result to process
 * @param options.logger - The logger instance
 * @param options.task - The task context containing callId and debug function
 * @returns An object containing the parsed response promise and wrapped text stream
 */
function prepareStreamResponse({
  model,
  stream,
  isReasoningModel,
}: {
  model: LanguageModelV1;
  stream: StreamTextResult<ToolSet, never>;
  isReasoningModel: boolean;
}) {
  const prefix =
    modelsResponseConfig[model.modelId]?.prefix ??
    (isReasoningModel
      ? (modelsResponseConfig[model.modelId]?.thinkTag ?? "<think>")
      : "<response>");
  const suffix = "</response>";
  return {
    getTextResponse: async () => {
      const result = await stream.text;
      const text = prefix + result + suffix;
      return text;
    },
    stream: wrapStream(stream.textStream, prefix, suffix),
  };
}

type GenerateOptions = {
  prompt: string;
  workingMemory: WorkingMemory;
  logger: Logger;
  model: LanguageModelV1;
  onError: (error: unknown) => void;
};

export const runGenerate = task({
  key: "agent:run:generate",
  handler: async (
    { prompt, workingMemory, model, onError }: GenerateOptions,
    { abortSignal }
  ) => {
    const isReasoningModel = reasoningModels.includes(model.modelId);

    const messages: CoreMessage[] = [
      {
        role: "user",
        content: [
          {
            type: "text",
            text: prompt,
          },
        ],
      },
    ];

    if (modelsResponseConfig[model.modelId]?.assist !== false)
      messages.push({
        role: "assistant",
        content: isReasoningModel
          ? (modelsResponseConfig[model.modelId]?.thinkTag ?? "<think>")
          : "<response>",
      });

    if (workingMemory.currentImage) {
      messages[0].content = [
        ...messages[0].content,
        {
          type: "image",
          image: workingMemory.currentImage,
        },
      ] as CoreMessage["content"];
    }

    const stream = streamText({
      model,
      messages,
      stopSequences: ["\n</response>"],
      temperature: 0.6,
      abortSignal,
      onError: (event) => {
        onError(event.error);
      },
    });

    return prepareStreamResponse({
      model,
      stream,
      isReasoningModel,
    });
  },
});

/**
 * Task that executes an action with the given context and parameters.
 *
 * @param options - Configuration options
 * @param options.ctx - The agent context with memory
 * @param options.action - The action to execute
 * @param options.call - The action call details
 * @param options.agent - The agent instance
 * @param options.logger - The logger instance
 * @returns The result of the action execution
 * @throws Will throw an error if the action execution fails
 */
export const runAction = task({
  key: "agent:run:action",
  handler: async <TContext extends AnyContext>({
    ctx,
    action,
    agent,
    logger,
  }: {
    ctx: ActionCallContext<any, TContext>;
    action: AnyAction;
    agent: AnyAgent;
    logger: Logger;
  }) => {
    logger.info(
      "agent:action_call:" + ctx.call.id,
      ctx.call.name,
      JSON.stringify(ctx.call.data)
    );

    try {
      const result =
        action.schema === undefined
          ? await Promise.try((action as Action<undefined>).handler, ctx, agent)
          : await Promise.try(action.handler as any, ctx.call.data, ctx, agent);

      logger.debug("agent:action_result:" + ctx.call.id, ctx.call.name, result);

      return result;
    } catch (error) {
      logger.error("agent:action", "ACTION_FAILED", { error });

      if (action.onError) {
        return await Promise.try(action.onError, error, ctx, agent);
      } else {
        throw error;
      }
    }
  },
});

--- End File: packages/core/src/tasks/index.ts ---

--- File: packages/core/src/types.ts ---
import { type LanguageModelV1, type Schema } from "ai";
import { z, ZodObject, ZodType, type ZodRawShape } from "zod";
import type { Container } from "./container";
import type { ServiceProvider } from "./serviceProvider";
import type { BaseMemory } from "./memory";
import type { TaskRunner } from "./task";
import type { Logger } from "./logger";

export { type LanguageModelV1, type Schema } from "ai";

export type Optional<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;

export type MaybePromise<T = any> = T | Promise<T>;

/**
 * Represents a memory configuration for storing data
 * @template Data - Type of data stored in memory
 */
export type Memory<Data = any> = {
  /** Unique identifier for this memory */
  key: string;
  /** Function to initialize memory data */
  create: () => Promise<Data> | Data;
};

/**
 * Extracts the data type from a Memory type
 * @template TMemory - Memory type to extract data from
 */
export type InferMemoryData<TMemory extends Memory<any>> =
  TMemory extends Memory<infer Data> ? Data : never;

/**
 * Represents an execution chain with experts and metadata
 */
export type Chain = {
  /** Unique identifier for the chain */
  id: string;
  /** Current thinking/reasoning state */
  thinking: string;
  /** Goal or purpose of this chain */
  purpose: string;
  /** List of experts involved in the chain */
  experts: { name: string; data: string }[];
};

/**
 * Interface for storing and retrieving memory data
 */
export interface MemoryStore {
  /**
   * Retrieves data from memory
   * @template T - Type of data to retrieve
   * @param key - Key to lookup
   * @returns Promise resolving to data or null if not found
   */
  get<T>(key: string): Promise<T | null>;

  /**
   * Stores data in memory
   * @template T - Type of data to store
   * @param key - Key to store under
   * @param value - Data to store
   */
  set<T>(key: string, value: T): Promise<void>;

  /**
   * Removes data from memory
   * @param key - Key to remove
   */
  delete(key: string): Promise<void>;

  /**
   * Removes all data from memory
   */
  clear(): Promise<void>;

  keys(base?: string): Promise<string[]>;
}
/**
 * Interface for storing and retrieving vector data
 */
export interface VectorStore {
  /** Optional connection string for the vector store */
  connection?: string;

  /**
   * Adds or updates data in the vector store
   * @param contextId - Unique identifier for the context
   * @param data - Data to add or update
   */
  upsert(contextId: string, data: any): Promise<void>;

  /**
   * Searches the vector store for similar data
   * @param contextId - Context to search within
   * @param query - Query text to search for
   * @returns Array of matching documents
   */
  query(contextId: string, query: string): Promise<any[]>;

  /**
   * Creates a new index in the vector store
   * @param indexName - Name of the index to create
   */
  createIndex(indexName: string): Promise<void>;

  /**
   * Deletes an existing index from the vector store
   * @param indexName - Name of the index to delete
   */
  deleteIndex(indexName: string): Promise<void>;
}

/**
 * Represents the working memory state during execution
 */
export interface WorkingMemory {
  /** List of input references */
  inputs: InputRef[];
  /** List of output references */
  outputs: OutputRef[];
  /** List of thought records */
  thoughts: Thought[];
  /** List of action calls */
  calls: ActionCall[];
  /** List of action results */
  results: ActionResult[];
  // chains: Chain[];
  episodicMemory?: EpisodicMemory;
  /** Current image URL for multimodal context */
  currentImage?: URL;

  runs: RunRef[];

  steps: StepRef[];

  events: EventRef[];
}

export type InferSchema<T> = T extends {
  schema?: infer S extends z.AnyZodObject;
}
  ? z.infer<S>
  : unknown;

export type InferAgentContext<TAgent extends AnyAgent> =
  TAgent extends Agent<infer Content> ? Content : never;

export type InferAgentMemory<TAgent extends AnyAgent> = InferContextMemory<
  InferAgentContext<TAgent>
>;

/**
 * Represents an evaluator that can validate action/output results
 * @template Data - Type of data being evaluated
 * @template Context - Context type for the evaluation
 */
export type Evaluator<
  Data = any,
  Context extends AgentContext<any> = AgentContext<any>,
  TAgent extends AnyAgent = AnyAgent,
> = {
  name: string;
  description?: string;
  /** Schema for the evaluation result */
  schema?: z.ZodType<any>;
  /** Custom prompt template for LLM-based evaluation */
  prompt?: string;
  /** Custom handler for evaluation logic */
  handler?: (
    data: Data,
    ctx: Context,
    agent: TAgent
  ) => Promise<boolean> | boolean;
  /** Optional callback when evaluation fails */
  onFailure?: (ctx: Context, agent: TAgent) => Promise<void> | void;
};

export type ActionSchema =
  | ZodRawShape
  | z.AnyZodObject
  | Schema<any>
  | undefined;

export type InferActionArguments<TSchema = undefined> =
  TSchema extends ZodRawShape
    ? z.infer<ZodObject<TSchema>>
    : TSchema extends z.AnyZodObject
      ? z.infer<TSchema>
      : TSchema extends Schema
        ? TSchema["_type"]
        : undefined;

export interface ActionContext<
  TContext extends AnyContext = AnyContext,
  AContext extends AnyContext = AnyContext,
  ActionMemory extends Memory<any> = Memory<any>,
> extends AgentContext<TContext> {
  actionMemory: InferMemoryData<ActionMemory>;
  agentMemory: InferContextMemory<AContext> | undefined;
  abortSignal?: AbortSignal;
}

export interface ActionCallContext<
  Schema extends ActionSchema = undefined,
  TContext extends AnyContext = AnyContext,
  AContext extends AnyContext = AnyContext,
  ActionMemory extends Memory<any> = Memory<any>,
> extends ActionContext<TContext, AContext, ActionMemory>,
    ContextStateApi<TContext> {
  call: ActionCall<InferActionArguments<Schema>>;
}

type InferActionResult<Result> = Result extends ZodRawShape
  ? z.infer<ZodObject<Result>>
  : Result extends ZodType
    ? z.infer<Result>
    : Result extends Schema
      ? Result["_type"]
      : Result;

export type ActionHandler<
  Schema extends ActionSchema = undefined,
  Result = any,
  TContext extends AnyContext = AnyContext,
  TAgent extends AnyAgent = AnyAgent,
  TMemory extends Memory<any> = Memory<any>,
> = Schema extends undefined
  ? (
      ctx: ActionCallContext<
        Schema,
        TContext,
        InferAgentContext<TAgent>,
        TMemory
      >,
      agent: TAgent
    ) => MaybePromise<Result>
  : (
      args: InferActionArguments<Schema>,
      ctx: ActionCallContext<
        Schema,
        TContext,
        InferAgentContext<TAgent>,
        TMemory
      >,
      agent: TAgent
    ) => MaybePromise<Result>;

/**
 * Represents an action that can be executed with typed parameters
 * @template Schema - Zod schema defining parameter types
 * @template Result - Return type of the action
 * @template Context - Context type for the action execution
 */
export interface Action<
  Schema extends ActionSchema = ActionSchema,
  Result = any,
  TError = unknown,
  TContext extends AnyContext = AnyContext,
  TAgent extends AnyAgent = AnyAgent,
  TMemory extends Memory<any> = Memory<any>,
> {
  name: string;
  description?: string;
  instructions?: string;

  schema: Schema;

  attributes?: ActionSchema;

  memory?: TMemory;

  install?: (agent: TAgent) => Promise<void> | void;

  enabled?: (
    ctx: ActionContext<TContext, InferAgentContext<TAgent>, TMemory>
  ) => boolean;

  handler: ActionHandler<Schema, Result, TContext, TAgent, TMemory>;

  returns?: ActionSchema;

  format?: (result: ActionResult<Result>) => string | string[];
  /** Optional evaluator for this specific action */
  evaluator?: Evaluator<Result, AgentContext<TContext>, TAgent>;

  context?: TContext;

  onSuccess?: (
    result: ActionResult<Result>,
    ctx: ActionCallContext<
      Schema,
      TContext,
      InferAgentContext<TAgent>,
      TMemory
    >,
    agent: TAgent
  ) => Promise<void> | void;

  retry?: boolean | number | ((failureCount: number, error: TError) => boolean);

  onError?: (
    err: TError,
    ctx: ActionCallContext<
      Schema,
      TContext,
      InferAgentContext<TAgent>,
      TMemory
    >,
    agent: TAgent
  ) => MaybePromise<any>;

  queueKey?:
    | string
    | ((
        ctx: ActionCallContext<
          Schema,
          TContext,
          InferAgentContext<TAgent>,
          TMemory
        >
      ) => string);

  examples?: string[];

  parser?: (ref: ActionCall) => InferActionArguments<Schema>;

  callFormat?: "json" | "xml";

  templateResolver?:
    | boolean
    | ((
        key: string,
        path: string,
        ctx: ActionCallContext<
          Schema,
          TContext,
          InferAgentContext<TAgent>,
          TMemory
        >
      ) => MaybePromise<string>);
}

export type ActionCtxRef = AnyAction & {
  ctxRef: {
    type: string;
    id: string;
    key?: string;
  };
};

export type OutputCtxRef = AnyOutput & {
  ctxRef: {
    type: string;
    id: string;
    key?: string;
  };
};

export type OutputSchema = z.AnyZodObject | z.ZodString | ZodRawShape;

type InferOutputSchemaParams<Schema extends OutputSchema> =
  Schema extends ZodRawShape
    ? z.infer<ZodObject<Schema>>
    : Schema extends z.AnyZodObject | z.ZodString
      ? z.infer<Schema>
      : never;

export type OutputRefResponse = Pick<OutputRef, "data" | "params"> & {
  processed?: boolean;
};

export type OutputResponse =
  | OutputRefResponse
  | OutputRefResponse[]
  | undefined
  | void;

export type Output<
  Schema extends OutputSchema = OutputSchema,
  Response extends OutputRefResponse = OutputRefResponse,
  TContext extends AnyContext = AnyContext,
  TAgent extends AnyAgent = AnyAgent,
> = {
  type: string;
  description?: string;
  instructions?: string;
  required?: boolean;
  schema?: Schema;
  attributes?: OutputSchema;
  context?: TContext;
  install?: (agent: TAgent) => MaybePromise<void>;
  enabled?: (ctx: ContextState<TContext>) => boolean;
  handler?: (
    data: InferOutputSchemaParams<Schema>,
    ctx: ContextState<TContext> & {
      outputRef: OutputRef<InferOutputSchemaParams<Schema>>;
    },
    agent: TAgent
  ) => MaybePromise<Response | Response[]>;
  format?: (res: OutputRef<Response["data"]>) => string | string[] | XMLElement;
  /** Optional evaluator for this specific output */
  evaluator?: Evaluator<OutputResponse, AgentContext<Context>, TAgent>;

  examples?: string[];
};

export type AnyOutput = Output<any, any, any, AnyAgent>;

export type AnyAction = Action<any, any, any, any, AnyAgent, any>;

export type AnyActionWithContext<Ctx extends Context<any, any, any, any, any>> =
  Action<any, any, any, Ctx, AnyAgent, any>;

/**
 * Represents an input handler with validation and subscription capability
 * @template Schema - Zod schema for input parameters
 * @template Context - Context type for input handling
 */
export type Input<
  Schema extends z.AnyZodObject | z.ZodString | z.ZodRawShape =
    | z.AnyZodObject
    | z.ZodString
    | z.ZodRawShape,
  TContext extends AnyContext = AnyContext,
  TAgent extends AnyAgent = AnyAgent,
> = {
  type: string;
  description?: string;
  schema?: Schema;
  context?: TContext;

  install?: (agent: TAgent) => MaybePromise<void>;
  enabled?: (state: AgentContext<TContext>) => Promise<boolean> | boolean;
  handler?: (
    data: InferSchemaArguments<Schema>,
    ctx: AgentContext<TContext>,
    agent: TAgent
  ) => MaybePromise<Pick<InputRef, "params" | "data">>;
  format?: (
    ref: InputRef<InferSchemaArguments<Schema>>
  ) => string | string[] | XMLElement;
  subscribe?: (
    send: <TContext extends AnyContext>(
      context: TContext,
      args: InferSchemaArguments<TContext["schema"]>,
      data: InferSchemaArguments<Schema>
    ) => MaybePromise<void>,
    agent: TAgent
  ) => (() => void) | void | Promise<void | (() => void)>;
};

export type RunRef = {
  id: string;
  ref: "run";
  type: string;
  data: any;
  // metrics: {
  //   duration: number;
  //   steps: number;
  //   inputs: number;
  //   thoughts: number;
  //   calls: number;
  //   results: number;
  //   outputs: number;
  // };
  // metadata: any;
  timestamp: number;
  processed: boolean;
  stopReason?: string;
};

export type StepRef = {
  id: string;
  ref: "step";
  type: string;
  step: number;
  data: {
    prompt?: string;
    response?: string;
  };
  timestamp: number;
  processed: boolean;
};

/** Reference to an input event in the system */
export type InputRef<Data = any> = {
  id: string;
  ref: "input";
  type: string;
  content: any;
  data: Data;
  params?: Record<string, string>;
  timestamp: number;
  processed: boolean;
  formatted?: string | string[] | XMLElement;
};

/** Reference to an output event in the system */
export type OutputRef<Data = any> = {
  id: string;
  ref: "output";
  type: string;
  params?: Record<string, string>;
  content: string;
  data: Data;
  timestamp: number;
  processed: boolean;
  formatted?: string | string[] | XMLElement;
  error?: unknown;
};

/** Represents a call to an action */
export type ActionCall<Data = any> = {
  ref: "action_call";
  id: string;
  name: string;
  content: string;
  data: Data;
  params?: Record<string, string>;
  timestamp: number;
  processed: boolean;
};

/** Represents the result of an action execution */
export type ActionResult<Data = any> = {
  ref: "action_result";
  id: string;
  callId: string;
  name: string;
  data: Data;
  timestamp: number;
  processed: boolean;
  formatted?: string | string[] | XMLElement;
};

/** Represents a thought or reasoning step */
export type Thought = {
  ref: "thought";
  id: string;
  content: string;
  timestamp: number;
  processed: boolean;
};

/** Represents a event */
export type EventRef<Data = any> = {
  ref: "event";
  id: string;
  name: string;
  params?: Record<string, string>;
  data: Data;
  timestamp: number;
  processed: boolean;
  formatted?: string | string[] | XMLElement;
};

export type Log =
  | InputRef
  | OutputRef
  | Thought
  | ActionCall
  | ActionResult
  | EventRef;

export type AnyRef =
  | InputRef
  | OutputRef
  | Thought
  | ActionCall
  | ActionResult
  | EventRef
  | StepRef
  | RunRef;

/** Properties required for Chain-of-Thought execution */
export type COTProps = {
  model: LanguageModelV1;
  plan: string;
  inputs: InputRef[];
  actions: Action[];
  outputs: Output[];
  logs: Log[];
};

/** Response structure from Chain-of-Thought execution */
export type COTResponse = {
  plan: string[];
  actions: ActionCall[];
  outputs: OutputRef[];
  thinking: Thought[];
};

/** Represents an XML element structure */
export type XMLElement = {
  tag: string;
  params?: Record<string, string>;
  children?: string | (XMLElement | string)[];
};

/** Utility type to preserve type information */
export type Pretty<type> = { [key in keyof type]: type[key] } & unknown;

/**
 * Extracts variable names from a template string
 * @template T - Template string type
 */
export type ExtractTemplateVariables<T extends string> =
  T extends `${infer Start}{{${infer Var}}}${infer Rest}`
    ? Var | ExtractTemplateVariables<Rest>
    : never;

/**
 * Converts a dot-separated path into a nested object type
 * @template P - Path string
 * @template V - Value type at the leaf
 */
type PathToObject<
  P extends string,
  V = string,
> = P extends `${infer Key}.${infer Rest}`
  ? { [K in Key]: PathToObject<Rest, V> }
  : { [K in P]: V };

/**
 * Merges a union of paths into a single nested object type
 * @template T - Union of path strings
 * @template V - Value type at the leaf
 */
type UnionToObject<T, V = string> = T extends string
  ? PathToObject<T, V>
  : never;

/**
 * Merges multiple object types into one (handles union overlap)
 */
type Merge<T> = { [K in keyof T]: T[K] extends object ? Merge<T[K]> : T[K] };

type Prettify<T> = T extends object ? { [K in keyof T]: Prettify<T[K]> } : T;
/**
 * Creates a type mapping template variables (including nested paths) to values
 * @template T - Template string type
 * @template V - Value type at the leaf (defaults to string)
 */
export type TemplateVariables<T extends string, V = any> = {
  [K in ExtractTemplateVariables<T>]: any;
};

/** Represents an expert system with instructions and actions */
export type Expert = {
  type: string;
  description: string;
  instructions: string;
  model?: LanguageModelV1;
  actions?: AnyAction[];
};

export interface AgentContext<TContext extends AnyContext = AnyContext> {
  id: string;
  context: TContext;
  args: InferSchemaArguments<TContext["schema"]>;
  options: InferContextOptions<TContext>;
  settings: ContextSettings;
  memory: InferContextMemory<TContext>;
  workingMemory: WorkingMemory;
}

export type AnyAgent = Agent<any>;

export interface Handlers {
  onLogStream: (log: AnyRef, done: boolean) => void;
  onThinking: (thought: Thought) => void;
}

export type Registry = {
  contexts: Map<string, AnyContext>;
  actions: Map<string, AnyAction>;
  inputs: Map<string, Input>;
  outputs: Map<string, Output>;
  extensions: Map<string, Extension>;
  prompts: Map<string, string>;
  models: Map<string, LanguageModelV1>;
};

interface AgentDef<TContext extends AnyContext = AnyContext> {
  logger: Logger;

  /**
   * The memory store and vector store used by the agent.
   */
  memory: BaseMemory;

  /**
   * The current context of the agent.
   */
  context?: TContext;

  /**
   * Debugger function for the agent.
   */
  debugger: Debugger;

  /**
   * The container used by the agent.
   */
  container: Container;

  /**
   * The task runner used by the agent.
   */
  taskRunner: TaskRunner;

  /**
   * The primary language model used by the agent.
   */
  model?: LanguageModelV1;

  /**
   * The reasoning model used by the agent, if any.
   */
  reasoningModel?: LanguageModelV1;

  /**
   * The vector model used by the agent, if any.
   */
  vectorModel?: LanguageModelV1;

  /**
   * A record of input configurations for the agent.
   */
  inputs: Record<string, InputConfig<any, AnyContext, Agent<TContext>>>;

  /**
   * A record of output configurations for the agent.
   */
  outputs: Record<string, Omit<Output<any, any, TContext, any>, "type">>;

  /**
   * A record of event schemas for the agent.
   */
  events: Record<string, z.AnyZodObject>;

  /**
   * A record of expert configurations for the agent.
   */
  experts: Record<string, ExpertConfig>;

  /**
   * An array of actions available to the agent.
   */
  actions: Action<
    any,
    any,
    unknown,
    AnyContext,
    Agent<TContext>,
    Memory<any>
  >[];

  /**
   * Whether to export training data for episodes
   */
  exportTrainingData?: boolean;

  /**
   * Path to save training data
   */
  trainingDataPath?: string;
}

export type LogChunk =
  | { type: "log"; log: AnyRef; done: boolean }
  | { type: "content"; id: string; content: string }
  | { type: "data"; id: string; data: any }
  | { type: "done"; id: string };

/**
 * Represents an agent with various configurations and methods for handling contexts, inputs, outputs, and more.
 * @template Memory - The type of memory used by the agent.
 * @template TContext - The type of context used by the agent.
 */
export interface Agent<TContext extends AnyContext = AnyContext>
  extends AgentDef<TContext> {
  registry: Registry;

  isBooted(): boolean;

  /**
   * Exports all episodes as training data
   * @param filePath Optional path to save the training data
   */
  exportAllTrainingData?: (filePath?: string) => Promise<void>;

  /**
   * Emits an event with the provided arguments.
   * @param args - Arguments to pass to the event handler.
   */
  emit: (...args: any[]) => void;

  /**
   * Runs the agent with the provided options.
   * @param opts - Options for running the agent.
   * @returns A promise that resolves to an array of logs.
   */
  run: <
    TContext extends AnyContext,
    SubContextRefs extends AnyContext[] = AnyContext[],
  >(opts: {
    context: TContext;
    args: InferSchemaArguments<TContext["schema"]>;
    model?: LanguageModelV1;
    contexts?: ContextRefArray<SubContextRefs>;
    outputs?: Record<string, Omit<Output<any, any, TContext, any>, "type">>;
    actions?: AnyAction[];
    handlers?: Partial<Handlers>;
    abortSignal?: AbortSignal;
    chain?: Log[];
  }) => Promise<AnyRef[]>;

  /**
   * Sends an input to the agent with the provided options.
   * @param opts - Options for sending input to the agent.
   * @returns A promise that resolves to an array of logs.
   */
  send: <
    SContext extends AnyContext,
    SubContextRefs extends AnyContext[] = AnyContext[],
  >(opts: {
    context: SContext;
    args: InferSchemaArguments<SContext["schema"]>;
    input: { type: string; data: any };
    model?: LanguageModelV1;
    contexts?: ContextRefArray<SubContextRefs>;
    outputs?: Record<string, Omit<Output<any, any, SContext, any>, "type">>;
    actions?: AnyAction[];
    handlers?: Partial<Handlers>;
    abortSignal?: AbortSignal;
    chain?: Log[];
  }) => Promise<AnyRef[]>;

  /**
   * Evaluates the provided context.
   * @param ctx - The context to evaluate.
   * @returns A promise that resolves when evaluation is complete.
   */
  evaluator<SContext extends AnyContext>(
    ctx: AgentContext<SContext>
  ): Promise<void>;

  /**
   * Starts the agent with the provided arguments.
   * @param args - Arguments to pass to the agent on start.
   * @returns A promise that resolves to the agent instance.
   */
  start(args?: InferSchemaArguments<TContext["schema"]>): Promise<this>;

  /**
   * Stops the agent.
   * @returns A promise that resolves when the agent is stopped.
   */
  stop(): Promise<void>;

  /**
   * Retrieves the contexts managed by the agent.
   * @returns A promise that resolves to an array of context objects.
   */
  getContexts(): Promise<
    { id: string; type: string; args?: any; settings?: ContextSettings }[]
  >;

  /**
   * Retrieves the ID for a given context and arguments.
   * @param params - Parameters for retrieving the context ID.
   * @returns The context ID.
   */
  getContextId<TContext extends AnyContext = AnyContext>(params: {
    context: TContext;
    args: InferSchemaArguments<TContext["schema"]>;
  }): string;

  getAgentContext(): Promise<ContextState<TContext> | undefined>;

  /**
   * Retrieves the state of a given context and arguments.
   * @param params - Parameters for retrieving the context state.
   * @returns A promise that resolves to the context state.
   */
  getContext<TContext extends AnyContext>(params: {
    context: TContext;
    args: InferSchemaArguments<TContext["schema"]>;
  }): Promise<ContextState<TContext>>;

  loadContext<TContext extends AnyContext>(params: {
    context: TContext;
    args: InferSchemaArguments<TContext["schema"]>;
  }): Promise<ContextState<TContext> | null>;

  saveContext(
    state: ContextState<AnyContext>,
    workingMemory?: WorkingMemory
  ): Promise<boolean>;

  getContextById<TContext extends AnyContext>(
    id: string
  ): Promise<ContextState<TContext> | null>;

  /**
   * Retrieves the working memory for a given context ID.
   * @param contextId - The ID of the context.
   * @returns A promise that resolves to the working memory.
   */
  getWorkingMemory(contextId: string): Promise<WorkingMemory>;

  deleteContext(contextId: string): Promise<void>;

  subscribeContext(
    contextId: string,
    handler: (log: AnyRef, done: boolean) => void
  ): () => void;

  __subscribeChunk(
    contextId: string,
    handler: (log: LogChunk) => void
  ): () => void;
}

export type Debugger = (contextId: string, keys: string[], data: any) => void;

export type Config<TContext extends AnyContext = AnyContext> = Partial<
  AgentDef<TContext>
> & {
  model?: Agent["model"];
  reasoningModel?: Agent["reasoningModel"];
  logLevel?: LogLevel;
  contexts?: AnyContext[];
  services?: ServiceProvider[];
  extensions?: Extension<TContext>[];
  /** Whether to export training data for episodes */
  exportTrainingData?: boolean;
  /** Path to save training data */
  trainingDataPath?: string;
};

/** Configuration type for inputs without type field */
export type InputConfig<
  Schema extends z.AnyZodObject | z.ZodString | z.ZodRawShape =
    | z.AnyZodObject
    | z.ZodString
    | z.ZodRawShape,
  TContext extends AnyContext = AnyContext,
  TAgent extends AnyAgent = AnyAgent,
> = Omit<Input<Schema, TContext, TAgent>, "type">;

/** Configuration type for outputs without type field */
export type OutputConfig<
  Schema extends OutputSchema = OutputSchema,
  Response extends OutputRefResponse = OutputRefResponse,
  TContext extends AnyContext = AnyContext,
  TAgent extends AnyAgent = AnyAgent,
> = Omit<Output<Schema, Response, TContext, TAgent>, "type">;

/** Configuration type for experts without type field */
export type ExpertConfig = Omit<Expert, "type">;

/** Function type for subscription cleanup */
export type Subscription = () => void;

/** Enum defining available log levels */
export enum LogLevel {
  ERROR = 0,
  WARN = 1,
  INFO = 2,
  DEBUG = 3,
  TRACE = 4,
}

/** Results from a research operation */
export interface ResearchResult {
  learnings: string[];
  visitedUrls: string[];
}

/** Configuration for research operations */
export interface ResearchConfig {
  query: string;
  breadth: number;
  depth: number;
  learnings?: string[];
  visitedUrls?: string[];
}

export interface IChain {
  /**
   * A unique identifier for the chain (e.g., "starknet", "ethereum", "solana", etc.)
   */
  chainId: string;

  /**
   * Read (call) a contract or perform a query on this chain.
   * The `call` parameter can be chain-specific data.
   */
  read(call: unknown): Promise<any>;

  /**
   * Write (execute a transaction) on this chain, typically requiring signatures, etc.
   */
  write(call: unknown): Promise<any>;
}
/** Type representing instructions that can be either a single string or array of strings */
export type Instruction = string | string[];

/** Type representing any Context with generic type parameters */
export type AnyContext = Context<any, any, any, any, any>;

/**
 * Extracts the Memory type from a Context type
 * @template TContext - The Context type to extract Memory from
 */
export type InferContextMemory<TContext extends AnyContext> =
  TContext extends Context<infer TMemory, any, any, any, any> ? TMemory : never;

/**
 * Extracts the Context type from a Context type
 * @template TContext - The Context type to extract Ctx from
 */
export type InferContextOptions<TContext extends AnyContext> =
  TContext extends Context<any, any, infer Options, any, any> ? Options : never;

/**
 * Configuration for a context that manages state and behavior
 * @template Memory - Type of memory for this context
 * @template Args - Zod schema type for context arguments
 * @template Ctx - Type of context data
 * @template Exports - Type of exported data
 */

export type InferSchemaArguments<
  Schema extends z.ZodTypeAny | ZodRawShape | undefined = z.ZodTypeAny,
> = Schema extends ZodRawShape
  ? z.infer<ZodObject<Schema>>
  : Schema extends z.ZodTypeAny
    ? z.infer<Schema>
    : never;

type ActionArray<T extends AnyAction[]> = {
  [K in keyof T]: T[K];
};

type MergeArrays<T extends Array<any>, C extends Array<any>> = T & C;

interface ContextConfigApi<
  TMemory = any,
  Schema extends z.ZodTypeAny | ZodRawShape = z.ZodTypeAny,
  Ctx = any,
  Actions extends AnyAction[] = AnyAction[],
  Events extends Record<string, z.ZodTypeAny | ZodRawShape> = Record<
    string,
    z.ZodTypeAny | ZodRawShape
  >,
> {
  setActions<
    TActions extends AnyActionWithContext<
      Context<TMemory, Schema, Ctx, any, Events>
    >[],
  >(
    actions: TActions
  ): Context<TMemory, Schema, Ctx, TActions, Events>;
  setInputs<
    TSchemas extends Record<
      string,
      z.AnyZodObject | z.ZodString | z.ZodRawShape
    >,
  >(inputs: {
    [K in keyof TSchemas]: InputConfig<
      TSchemas[K],
      Context<TMemory, Schema, Ctx, Actions, Events>,
      AnyAgent
    >;
  }): Context<TMemory, Schema, Ctx, Actions, Events>;
  setOutputs<
    TSchemas extends Record<
      string,
      z.AnyZodObject | z.ZodString | z.ZodRawShape
    >,
  >(outputs: {
    [K in keyof TSchemas]: OutputConfig<
      TSchemas[K],
      any,
      Context<TMemory, Schema, Ctx, Actions, Events>,
      AnyAgent
    >;
  }): Context<TMemory, Schema, Ctx, Actions, Events>;

  use<Refs extends AnyContext[]>(
    composer: ContextComposer<
      Context<TMemory, Schema, Ctx, Actions, Events>,
      Refs
    >
  ): Context<TMemory, Schema, Ctx, Actions, Events>;
}

export type EventDef<Schema extends z.ZodTypeAny | ZodRawShape = z.ZodTypeAny> =
  {
    name: string;
    schema: Schema;
    // description?: string;
  };

export type ContextsEventsRecord<T extends Record<string, EventDef>> = {
  [K in keyof T]: T[K]["schema"];
};

export type ContextConfig<
  TMemory = any,
  Args extends z.ZodTypeAny | ZodRawShape = any,
  Ctx = any,
  Actions extends AnyAction[] = AnyAction[],
  Events extends Record<string, z.ZodTypeAny | z.ZodRawShape> = Record<
    string,
    z.ZodTypeAny | z.ZodRawShape
  >,
> = Optional<
  Omit<Context<TMemory, Args, Ctx, Actions, Events>, keyof ContextConfigApi>,
  "actions" | "events" | "inputs" | "outputs"
>;

type ContextComposer<
  TContext extends AnyContext,
  T extends AnyContext[] = AnyContext[],
> = (state: ContextState<TContext>) => ContextRefArray<T>;

type BaseContextComposer<TContext extends AnyContext> = (
  state: ContextState<TContext>
) => ContextRef[];

export type Resolver<Result, Ctx> = Result | ((ctx: Ctx) => Result);

export interface Context<
  TMemory = any,
  Schema extends z.ZodTypeAny | ZodRawShape = z.ZodTypeAny,
  Ctx = any,
  Actions extends AnyAction[] = AnyAction[],
  Events extends Record<string, z.ZodTypeAny | ZodRawShape> = Record<
    string,
    z.ZodTypeAny | ZodRawShape
  >,
> extends ContextConfigApi<TMemory, Schema, Ctx, Actions, Events> {
  /** Unique type identifier for this context */
  type: string;
  /** Zod schema for validating context arguments */
  schema?: Schema;
  /** Function to generate a unique key from context arguments */
  key?: (args: InferSchemaArguments<Schema>) => string;

  /** Setup function to initialize context data */
  setup?: (
    args: InferSchemaArguments<Schema>,
    settings: ContextSettings,
    agent: AnyAgent
  ) => Promise<Ctx> | Ctx;

  /** Optional function to create new memory for this context */
  create?: (
    params: {
      id: string;
      key?: string;
      args: InferSchemaArguments<Schema>;
      options: Ctx;
      settings: ContextSettings;
    },
    agent: AnyAgent
  ) => TMemory | Promise<TMemory>;

  /** Optional instructions for this context */
  instructions?: Resolver<Instruction, ContextState<this>>;

  /** Optional description of this context */
  description?: Resolver<string | string[], ContextState<this>>;

  /** Optional function to load existing memory */
  load?: (
    id: string,
    params: { options: Ctx; settings: ContextSettings }
  ) => Promise<TMemory | null>;
  /** Optional function to save memory state */
  save?: (state: ContextState<this>) => Promise<void>;

  /** Optional function to render memory state */
  render?: (
    state: ContextState<this>
  ) => string | string[] | XMLElement | XMLElement[] | (string | XMLElement)[];

  model?: LanguageModelV1;

  onRun?: (ctx: AgentContext<this>, agent: AnyAgent) => Promise<void>;

  onStep?: (ctx: AgentContext<this>, agent: AnyAgent) => Promise<void>;

  shouldContinue?: (ctx: AgentContext<this>) => boolean;

  onError?: (
    error: unknown,
    ctx: AgentContext<this>,
    agent: AnyAgent
  ) => Promise<void>;

  loader?: (state: ContextState<this>, agent: AnyAgent) => Promise<void>;

  maxSteps?: number;

  maxWorkingMemorySize?: number;

  actions?: Resolver<Action[], ContextState<this>>;

  events?: Resolver<Events, ContextState<this>>;

  /**
   * A record of input configurations for the context.
   */
  inputs?: Resolver<
    Record<string, InputConfig<any, any, AnyAgent>>,
    ContextState<this>
  >;

  /**
   * A record of output configurations for the context.
   */
  outputs?: Resolver<
    Record<string, Omit<Output<any, any, AnyContext, any>, "type">>,
    ContextState<this>
  >;

  __composers?: BaseContextComposer<this>[];

  __templateResolvers?: Record<
    string,
    TemplateResolver<AgentContext<this> & ContextStateApi<this>>
  >;
}

export type ContextSettings = {
  model?: LanguageModelV1;
  maxSteps?: number;
  maxWorkingMemorySize?: number;
};

export type ContextRef<TContext extends AnyContext = AnyContext> = {
  context: TContext;
  args: InferSchemaArguments<TContext["schema"]>;
};

export type ContextsRefRecord<T extends Record<string, AnyContext>> = {
  [K in keyof T]: ContextRef<T[K]>;
};

export type ContextRefArray<T extends AnyContext[] = AnyContext[]> = {
  [K in keyof T]: ContextRef<T[K]>;
};

type InferContextEvents<TContext extends AnyContext> =
  TContext extends Context<any, any, any, any, infer Events> ? Events : never;

type ContextEventEmitter<TContext extends AnyContext> = <
  T extends keyof InferContextEvents<TContext>,
>(
  event: T,
  args: InferSchema<InferContextEvents<TContext>[T]>,
  options?: { processed?: boolean }
) => void;

//wip

export type TemplateResolver<Ctx = any> = (
  path: string,
  ctx: Ctx
) => MaybePromise<any>;

export interface ContextStateApi<TContext extends AnyContext> {
  emit: ContextEventEmitter<TContext>;
  push: (log: Log) => Promise<any>;

  callAction: (
    call: ActionCall,
    options?: Partial<{
      templateResolvers?: Record<string, TemplateResolver>;
      queueKey?: string;
    }>
  ) => Promise<ActionResult>;

  __getRunResults: () => Promise<ActionResult>[];
}

export type ContextState<TContext extends AnyContext = AnyContext> = {
  id: string;
  key?: string;
  context: TContext;
  args: InferSchemaArguments<TContext["schema"]>;
  options: InferContextOptions<TContext>;
  memory: InferContextMemory<TContext>;
  settings: ContextSettings;
  contexts: string[];
};

export type Extension<
  TContext extends AnyContext = AnyContext,
  Contexts extends Record<string, AnyContext> = Record<string, AnyContext>,
  Inputs extends Record<string, InputConfig<any, any>> = Record<
    string,
    InputConfig<any, any>
  >,
> = Pick<
  Config<TContext>,
  "inputs" | "outputs" | "actions" | "services" | "events"
> & {
  name: string;
  install?: (agent: AnyAgent) => Promise<void> | void;
  contexts?: Contexts;
  inputs: Inputs;
};

export interface Episode {
  id: string;
  timestamp: number;
  observation: string; // Context and setup
  result: string; // Outcomes of actions
  thoughts: string;
  metadata?: {
    success?: boolean;
    tags?: string[];
    [key: string]: any;
  };
}

export interface EpisodicMemory {
  episodes: Episode[];
  index?: number; // For vector store indexing
}

--- End File: packages/core/src/types.ts ---

--- File: packages/core/src/utils.ts ---
import { z } from "zod";
import type {
  Action,
  ActionCall,
  ActionSchema,
  AnyAgent,
  AnyContext,
  EventRef,
  ExpertConfig,
  Extension,
  InputConfig,
  InputRef,
  Memory,
  Optional,
  OutputConfig,
  OutputRef,
  OutputRefResponse,
  OutputSchema,
  WorkingMemory,
} from "./types";
import { v7 as randomUUIDv7 } from "uuid";

export { randomUUIDv7 };
/**
 * Creates an input configuration
 * @template Schema - Zod schema type for input validation
 * @template Context - Context type for input handling
 * @param config - Input configuration object
 * @returns Typed input configuration
 */
export function input<
  Schema extends z.AnyZodObject | z.ZodString | z.ZodRawShape = z.ZodString,
  TContext extends AnyContext = AnyContext,
  TAgent extends AnyAgent = AnyAgent,
>(config: InputConfig<Schema, TContext, TAgent>) {
  return config;
}

/**
 * Creates an action configuration
 * @template Schema - Zod schema type for action parameters
 * @template Result - Return type of the action
 * @template Context - Context type for action execution
 * @param action - Action configuration object
 * @returns Typed action configuration
 */
export function action<
  TSchema extends ActionSchema = undefined,
  Result = any,
  TError = any,
  TContext extends AnyContext = AnyContext,
  TAgent extends AnyAgent = AnyAgent,
  TMemory extends Memory<any> = Memory<any>,
>(
  action: Optional<
    Action<TSchema, Result, TError, TContext, TAgent, TMemory>,
    "schema"
  >
): Action<TSchema, Result, TError, TContext, TAgent, TMemory> {
  return {
    ...action,
    schema: action.schema ?? (undefined as TSchema),
  };
}

/**
 * Creates an output configuration
 * @template Schema - Zod schema type for output validation
 * @template Context - Context type for output handling
 * @param config - Output configuration object
 * @returns Typed output configuration
 */
export function output<
  Schema extends OutputSchema = OutputSchema,
  Response extends OutputRefResponse = OutputRefResponse,
  Context extends AnyContext = AnyContext,
>(config: OutputConfig<Schema, Response, Context>) {
  return config;
}

/**
 * Creates an expert configuration
 * @template Context - Context type for expert execution
 * @param config - Expert configuration object
 * @returns Typed expert configuration
 */
export function expert(config: ExpertConfig) {
  return config;
}

/**
 * Options for text chunking
 */
type ChunkOptions = {
  maxChunkSize: number;
};

/**
 * Splits text into chunks based on maximum chunk size
 * @param text - The text to split into chunks
 * @param options - Chunking options including maximum chunk size
 * @returns Array of text chunks
 */
export function splitTextIntoChunks(
  text: string,
  options: ChunkOptions
): string[] {
  const { maxChunkSize } = options;
  const lines = text.split("\n");
  const chunks: string[] = [];
  let currentChunk = "";

  for (const line of lines) {
    // If adding this line would exceed maxChunkSize, start a new chunk
    if (currentChunk.length + line.length + 1 > maxChunkSize) {
      if (currentChunk) {
        chunks.push(currentChunk.trim());
      }
      currentChunk = line;
    } else {
      // Add line to current chunk with a newline
      currentChunk = currentChunk ? currentChunk + "\n" + line : line;
    }
  }

  // Don't forget to add the last chunk
  if (currentChunk) {
    chunks.push(currentChunk.trim());
  }

  return chunks;
}

/**
 * Creates a memory configuration
 * @template Data - Type of data stored in memory
 * @param memory - Memory configuration object
 * @returns Typed memory configuration
 */
export function memory<Data = any>(memory: Memory<Data>) {
  return memory;
}

export function extension<
  Contexts extends Record<string, AnyContext> = Record<string, AnyContext>,
  Inputs extends Record<string, InputConfig<any, any>> = Record<
    string,
    InputConfig<any, any>
  >,
>(
  config: Optional<Extension<AnyContext, Contexts, Inputs>, "inputs">
): Extension<AnyContext, Contexts, Inputs> {
  return {
    ...config,
    inputs: config.inputs ?? ({} as Inputs),
  };
}

/**
 * Validates environment variables against a Zod schema
 * @param schema The Zod schema to validate against
 * @param env The environment object to validate (defaults to process.env)
 * @returns The validated environment variables
 */
export function validateEnv<T extends z.ZodTypeAny>(
  schema: T,
  env = process.env
): z.infer<T> {
  try {
    return schema.parse(env);
  } catch (error) {
    if (error instanceof z.ZodError) {
      console.error("Environment validation failed:");
      error.errors.forEach((err) => {
        console.error(`- ${err.message}`);
      });
      process.exit(1);
    }
    throw error;
  }
}

type TrimWorkingMemoryOptions = {
  thoughts: number;
  inputs: number;
  outputs: number;
  actions: number;
};

const defaultTrimOptions: TrimWorkingMemoryOptions = {
  thoughts: 6,
  inputs: 20,
  outputs: 20,
  actions: 20,
};

export function trimWorkingMemory(
  workingMemory: WorkingMemory,
  options: TrimWorkingMemoryOptions = defaultTrimOptions
) {
  workingMemory.thoughts = workingMemory.thoughts.slice(-options.thoughts);
  workingMemory.inputs = workingMemory.inputs.slice(-options.inputs);
  workingMemory.outputs = workingMemory.outputs.slice(-options.outputs);
  workingMemory.calls = workingMemory.calls.slice(-options.actions);
  workingMemory.results = workingMemory.results.slice(-options.actions);
}

/**
 * Utility function to safely execute a function asynchronously
 * This is an implementation of the Promise.try pattern which isn't available in standard JS
 * @param fn The function to execute
 * @param ...args The arguments to pass to the function
 * @returns A promise that resolves with the result of the function
 */
export async function tryAsync<T>(fn: Function, ...args: any[]): Promise<T> {
  try {
    return await fn(...args);
  } catch (error) {
    return Promise.reject(error);
  }
}

export function createInputRef(
  ref: Pick<InputRef, "type" | "content" | "data" | "processed">
): InputRef {
  return {
    id: randomUUIDv7(),
    ref: "input",
    timestamp: Date.now(),
    ...ref,
  };
}

export function createOutputRef(
  ref: Pick<OutputRef, "type" | "content" | "data" | "processed">
): OutputRef {
  return {
    id: randomUUIDv7(),
    ref: "output",
    timestamp: Date.now(),
    ...ref,
  };
}

export function createEventRef(
  ref: Pick<EventRef, "name" | "data" | "processed">
): EventRef {
  return {
    id: randomUUIDv7(),
    ref: "event",
    timestamp: Date.now(),
    ...ref,
  };
}

export function createActionCall(
  ref: Pick<ActionCall, "name" | "content" | "data" | "processed" | "params">
): ActionCall {
  return {
    id: randomUUIDv7(),
    ref: "action_call",
    timestamp: Date.now(),
    ...ref,
  };
}

--- End File: packages/core/src/utils.ts ---

--- File: packages/core/src/xml.ts ---
/**
 * Creates a regular expression to match XML tags with a specific name
 * @param tagName - The name of the XML tag to match
 * @returns RegExp that matches the specified XML tag and captures its attributes and content
 */
export function createTagRegex(tagName: string) {
  return new RegExp(
    `(<${tagName}(?:\\s+[^>]*)?>)([\\s\\S]*?)<\/${tagName}>`,
    "gs"
  );
}

export function createTagParser<T = string>(
  tagName: string,
  contentParser?: (content: any) => T
) {
  const regex = createTagRegex(tagName);

  return (content: string) => {
    const matches = Array.from(content.matchAll(regex));
    try {
      return matches.map((t) => ({
        tag: tagName,
        params: t[1] ? parseAttributes(t[1]) : {},
        content: (contentParser
          ? contentParser(t[2]?.trim())
          : t[2]?.trim()) as T extends string ? string : T,
      }));
    } catch (error) {
      throw error;
    }
  };
}

// new parser
export type TextNode = {
  type: "text";
  content: string;
  parent?: Node;
  children?: never;
};

export type ElementNode<
  Attributes extends Record<string, string> = Record<string, any>,
> = {
  type: "element";
  name: string;
  attributes: Attributes;
  content: string;
  parent?: Node;
  children?: Node[];
  closed?: true;
};

export type Node = TextNode | ElementNode;

export type NodeVisitor = (node: Node, parse: () => Node[]) => Node;

export function parseAttributes(text: string): Record<string, string> {
  const attrs: Record<string, string> = {};
  if (text.length === 0) return attrs;
  const matches = text.matchAll(/(\w+)="([^"]*)"/g);
  for (const match of matches) {
    attrs[match[1]] = match[2];
  }
  return attrs;
}

export function parse(
  text: string,
  visitor: NodeVisitor,
  depth = 0,
  parent: Node | undefined = undefined
): Node[] {
  const nodes: Node[] = [];

  let workingText = text.trim();

  while (workingText.length > 0) {
    // Find first opening tag
    const tagStart = workingText.indexOf("<");
    if (tagStart === -1) {
      const textNode: TextNode = {
        type: "text",
        content: workingText.trim(),
      };
      nodes.push(visitor(textNode, () => []));
      break;
    }

    const tagEnd = workingText.indexOf(">", tagStart);

    if (tagStart > 0 || tagEnd === -1) {
      const textNode: TextNode = {
        type: "text",
        content: workingText.slice(0, tagEnd === -1 ? -1 : tagStart).trim(),
      };
      nodes.push(visitor(textNode, () => []));
    }

    // Find end of opening tag
    if (tagEnd === -1) break;

    // Parse tag and attributes
    let tagContent = workingText.slice(tagStart + 1, tagEnd);
    let closed = false;
    if (tagContent.at(-1) === "/") {
      closed = true;
      tagContent = tagContent.slice(0, -1);
    }

    const [name, ...attrParts] = tagContent.split(" ");
    const attributes = parseAttributes(attrParts.join(" ").trim());

    // Skip if it's a closing tag
    if (closed) {
      workingText = workingText.slice(tagEnd + 1).trim();
      nodes.push(
        visitor(
          {
            type: "element",
            name,
            attributes,
            content: "",
            closed,
          },
          () => []
        )
      );
      continue;
    }

    // Find last matching close tag
    const closeTag = `</${name}>`;
    const closePos = workingText.indexOf(closeTag);
    if (closePos === -1) break;

    // Extract content between tags
    const content = workingText.slice(tagEnd + 1, closePos).trim();

    const node: ElementNode = {
      type: "element",
      name,
      attributes,
      content,
    };

    if (parent) node.parent = parent;

    nodes.push(visitor(node, () => parse(content, visitor, depth + 1, node)));
    // Continue with remaining text before this tag
    workingText = workingText.slice(closePos + closeTag.length).trim();
  }
  return nodes;
}

export function isElement(node: Node): node is ElementNode {
  return node.type === "element";
}

export function isText(node: Node): node is TextNode {
  return node.type === "text";
}

type StartTag = {
  type: "start";
  name: string;
  attributes: Record<string, string>;
};

type EndTag = {
  type: "end";
  name: string;
};

type TextContent = {
  type: "text";
  content: string;
};

type SelfClosingTag = {
  type: "self-closing";
  name: string;
  attributes: Record<string, string>;
};

type XMLToken = StartTag | EndTag | TextContent | SelfClosingTag;

const alphaSlashRegex = /[a-zA-Z\/]/;

const wrappers = ["'", "`", "(", ")"];

// todo: maybe only allow new tags in new lines or immediatly after closing one
export function* xmlStreamParser(
  parseTags: Set<string>,
  shouldParse: (tagName: string, isClosingTag: boolean) => boolean
): Generator<XMLToken | void, void, string> {
  let buffer = "";
  let textContent = "";
  let cachedLastContent = "";

  while (true) {
    const chunk = yield;
    if (!chunk) continue;

    buffer += chunk;

    while (buffer.length > 0) {
      const tagStart = buffer.indexOf("<");
      // detect wrapped tags ex:'<tag> and skip it
      if (
        tagStart === 0 &&
        cachedLastContent &&
        wrappers.includes(cachedLastContent.at(-1)!)
      ) {
        textContent += buffer[0];
        buffer = buffer.slice(1);
        continue;
      }

      if (tagStart > 0) {
        if (wrappers.includes(buffer[tagStart - 1])) {
          textContent += buffer.slice(0, tagStart + 1);
          buffer = buffer.slice(tagStart + 1);
        } else {
          textContent += buffer.slice(0, tagStart);
          buffer = buffer.slice(tagStart);
        }

        if (textContent.length > 0) {
          yield { type: "text", content: textContent };
          cachedLastContent = textContent;
          textContent = "";
        }

        continue;
      }

      // todo: regex performance
      if (
        tagStart === -1 ||
        (buffer.length > 1 && !alphaSlashRegex.test(buffer[tagStart + 1]))
      ) {
        textContent += buffer;
        buffer = "";
        break;
      }

      const tagEnd = buffer.indexOf(">", tagStart);
      if (tagEnd === -1) {
        break;
      }

      // wait for more content to detect wrapper
      if (buffer.length === tagEnd) break;

      if (wrappers.includes(buffer[tagEnd + 1])) {
        textContent += buffer.slice(0, tagEnd + 1);
        buffer = buffer.slice(tagEnd + 1);
        if (textContent.length > 0) {
          yield { type: "text", content: textContent };
          cachedLastContent = textContent;
          textContent = "";
        }
        break;
      }

      let tagContent = buffer.slice(tagStart + 1, tagEnd);
      const isClosingTag = tagContent.startsWith("/");
      const tagName = isClosingTag
        ? tagContent.slice(1).trim().split(" ")[0]
        : tagContent.trim().split(" ")[0];

      if (parseTags.has(tagName) && shouldParse(tagName, isClosingTag)) {
        // Emit accumulated text if any
        if (textContent.length > 0) {
          yield { type: "text", content: textContent };
          cachedLastContent = textContent;
          textContent = "";
        }

        if (isClosingTag) {
          yield { type: "end", name: tagName };
        } else {
          const attributes = parseAttributes(tagContent.slice(tagName.length));

          if (tagContent.endsWith("/")) {
            yield { type: "self-closing", name: tagName, attributes };
          } else {
            yield { type: "start", name: tagName, attributes };
          }
        }
      } else {
        // Not a tag we care about, treat as text
        textContent += buffer.slice(0, tagEnd + 1);
      }

      buffer = buffer.slice(tagEnd + 1);
    }

    if (textContent.length > 0) {
      yield { type: "text", content: textContent };
      cachedLastContent = textContent;
      textContent = "";
    }
  }
}

--- End File: packages/core/src/xml.ts ---

--- File: packages/create-agent/README.md ---
# @daydreamsai/create-agent

A CLI tool to bootstrap Daydreams agents easily.

## Usage

```bash
# Using npx (recommended)
npx @daydreamsai/create-agent my-agent

# Or install globally
npm install -g @daydreamsai/create-agent
create-agent my-agent
```

## Options

You can specify extensions to include:

```bash
npx @daydreamsai/create-agent my-agent --twitter --discord --cli
```

Available extensions:

- `--cli`: Include CLI extension
- `--twitter`: Include Twitter extension
- `--discord`: Include Discord extension
- `--telegram`: Include Telegram extension
- `--all`: Include all extensions

If no extensions are specified, you will be prompted to select which ones to
include.

## What it does

This tool:

1. Creates a new directory for your agent (or uses the current directory)
2. Sets up a package.json with the necessary dependencies
3. Creates an index.js file with the selected extensions
4. Generates a basic .env.example file with required environment variables
5. Installs all dependencies

## Development

```bash
# Install dependencies
pnpm install

# Build the package
pnpm run build

# Test the CLI locally
pnpm run start
```

## Testing

The create-agent CLI is tested using Vitest. To run tests:

```bash
# Run all tests
pnpm run test

# Run tests in watch mode during development
pnpm run test:watch

# Run tests with coverage report
pnpm run test:coverage
```

### Test Structure

- `test/index.test.ts`: Main CLI integration tests
- `test/utils/utils.test.ts`: Unit tests for utility functions
- `test/template-generation.test.ts`: Tests for template generation
  functionality

### Adding New Tests

When adding new features to the CLI, make sure to:

1. Extract pure functions to the `src/utils.ts` file where possible
2. Add unit tests for those functions in `test/utils/utils.test.ts`
3. Add integration tests for CLI behavior in `test/index.test.ts`

--- End File: packages/create-agent/README.md ---

--- File: packages/create-agent/package.json ---
{
  "name": "@daydreamsai/create-agent",
  "version": "0.3.6",
  "description": "CLI to bootstrap Daydreams agents",
  "license": "MIT",
  "type": "module",
  "exports": {
    ".": "./dist/index.js"
  },
  "bin": {
    "create-agent": "./dist/index.js"
  },
  "files": [
    "dist",
    "templates"
  ],
  "scripts": {
    "build": "tsup",
    "dev": "tsup --watch",
    "typecheck": "tsc --noEmit",
    "start": "node dist/index.js test-agent",
    "test": "vitest run",
    "test:watch": "vitest",
    "test:coverage": "vitest run --coverage"
  },
  "dependencies": {
    "chalk": "^5.3.0",
    "commander": "^12.0.0",
    "execa": "^8.0.1",
    "fs-extra": "^11.2.0",
    "ora": "^8.0.1",
    "prompts": "^2.4.2"
  },
  "devDependencies": {
    "@types/fs-extra": "^11.0.4",
    "@types/node": "^20.11.16",
    "@types/prompts": "^2.4.9",
    "@vitest/coverage-v8": "^1.4.0",
    "memfs": "^4.9.0",
    "mock-stdin": "^1.0.0",
    "strip-ansi": "^7.1.0",
    "tsup": "^8.0.1",
    "typescript": "^5.3.3",
    "vitest": "^1.4.0",
    "vitest-mock-process": "^1.0.0"
  }
}

--- End File: packages/create-agent/package.json ---

--- File: packages/create-agent/src/index.ts ---
import path from "path";
import fs from "fs-extra";
import { Command } from "commander";
import chalk from "chalk";
import ora from "ora";
import { execa } from "execa";
import prompts from "prompts";
import { fileURLToPath } from "url";
import {
  generateTemplateContent,
  createEnvVariables,
  createReadme,
} from "./utils.js";

// Define __dirname equivalent for ES modules
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Define the CLI program
const program = new Command()
  .name("create-agent")
  .description("Bootstrap a new Daydreams agent")
  .version("0.1.0")
  .argument("[directory]", "Directory to create the agent in")
  .option("--twitter", "Include Twitter extension")
  .option("--discord", "Include Discord extension")
  .option("--cli", "Include CLI extension")
  .option("--telegram", "Include Telegram extension")
  .option("--all", "Include all extensions")
  .option(
    "--model <model>",
    "Specify the model to use (openai, groq, anthropic, google)",
    "groq"
  );

// Export the main function for testing purposes
export async function main(
  testArgs?: string[],
  testOpts?: Record<string, any>,
  testTemplateContent?: string // Add template content parameter for testing
) {
  // Parse arguments and options only if not in test mode
  if (!testArgs && !testOpts) {
    program.parse(process.argv);
  }

  const options = testOpts || program.opts();
  const targetDir = (testArgs && testArgs[0]) || program.args[0] || ".";
  const cwd = process.cwd();
  const targetPath = path.resolve(cwd, targetDir);

  // Check if target directory exists and is not empty
  if (fs.existsSync(targetPath)) {
    const files = await fs.readdir(targetPath);
    if (files.length > 0) {
      const { proceed } = await prompts({
        type: "confirm",
        name: "proceed",
        message: `Directory ${chalk.cyan(targetPath)} is not empty. Continue?`,
        initial: false,
      });

      if (!proceed) {
        console.log(chalk.red("Aborted."));
        return;
      }
    }
  } else {
    await fs.mkdir(targetPath, { recursive: true });
  }

  console.log();
  console.log(chalk.bold("Creating a new Daydreams agent..."));
  console.log();

  // Determine selected extensions
  const availableExtensions = ["cli", "twitter", "discord", "telegram"];
  let selectedExtensions = [];

  if (options.all) {
    selectedExtensions = [...availableExtensions];
  } else {
    // Collect extensions from command line options
    selectedExtensions = availableExtensions.filter((ext) => options[ext]);

    // If no extensions were selected via flags, prompt the user
    if (selectedExtensions.length === 0) {
      const { extensions } = await prompts({
        type: "multiselect",
        name: "extensions",
        message: "Select extensions to include",
        choices: [
          { title: "CLI", value: "cli" },
          { title: "Twitter", value: "twitter" },
          { title: "Discord", value: "discord" },
          { title: "Telegram", value: "telegram" },
        ],
      });

      if (!extensions || extensions.length === 0) {
        console.log(
          chalk.yellow(
            "No extensions selected. Including CLI extension by default."
          )
        );
        selectedExtensions = ["cli"];
      } else {
        selectedExtensions = extensions;
      }
    }
  }

  // Determine the model to use
  const validModels = ["openai", "groq", "anthropic", "google"];
  let selectedModel = options.model || "groq";

  if (!validModels.includes(selectedModel)) {
    const { model } = await prompts({
      type: "select",
      name: "model",
      message: "Select the model provider to use",
      choices: [
        { title: "Groq", value: "groq" },
        { title: "OpenAI", value: "openai" },
        { title: "Anthropic", value: "anthropic" },
        { title: "Google", value: "google" },
      ],
      initial: 0,
    });
    selectedModel = model;
  }

  // Create package.json
  const spinner = ora("Creating package.json").start();
  const packageJson: {
    name: string;
    version: string;
    type: string;
    scripts: Record<string, string>;
    dependencies: Record<string, string>;
  } = {
    name: path.basename(targetPath),
    version: "0.1.0",
    type: "module",
    scripts: {
      start: "bun run index.ts",
      build: "tsc",
    },
    dependencies: {
      "@daydreamsai/core": "^0.2.13",
      "@ai-sdk/anthropic": "^1.1.6",
      "@ai-sdk/google": "^1.1.16",
      "@ai-sdk/groq": "^1.1.7",
      "@ai-sdk/openai": "^1.1.14",
      "@openrouter/ai-sdk-provider": "^0.2.1",
      ai: "^4.1.25",
      chalk: "^5.4.1",
      "discord.js": "^14.17.3",
      telegraf: "^4.16.3",
      typescript: "^5.3.3",
      zod: "^3.24.1",
    },
  };

  // Add extension-specific dependencies
  if (selectedExtensions.includes("discord")) {
    packageJson.dependencies["discord.js"] = "^14.14.1";
  }

  await fs.writeFile(
    path.join(targetPath, "package.json"),
    JSON.stringify(packageJson, null, 2)
  );
  spinner.succeed("Created package.json");

  // Create tsconfig.json
  spinner.start("Creating tsconfig.json");
  const tsconfigJson = {
    compilerOptions: {
      target: "ES2020",
      module: "NodeNext",
      moduleResolution: "NodeNext",
      esModuleInterop: true,
      strict: true,
      skipLibCheck: true,
      outDir: "dist",
    },
    include: ["*.ts"],
    exclude: ["node_modules"],
  };

  await fs.writeFile(
    path.join(targetPath, "tsconfig.json"),
    JSON.stringify(tsconfigJson, null, 2)
  );
  spinner.succeed("Created tsconfig.json");

  // Copy template file based on selected model
  spinner.start(
    `Creating agent with ${selectedModel} model and selected extensions`
  );

  // Read template content - either from test parameter or from file
  let templateContent: string;

  if (testTemplateContent) {
    // Use the provided test template content
    templateContent = testTemplateContent;
  } else {
    // Get the template file path
    const templateFile = path.join(
      __dirname,
      "..",
      "templates",
      "basic",
      "template.ts"
    );

    if (!fs.existsSync(templateFile)) {
      spinner.fail(`Template file not found: ${templateFile}`);
      console.error(
        chalk.red(
          `Error: Template file not found. Please check your installation.`
        )
      );
      return;
    }

    // Read the template file
    templateContent = await fs.readFile(templateFile, "utf-8");
  }

  // Define model-specific replacements
  const modelConfig = {
    groq: {
      MODEL_NAME: "Groq",
      MODEL_IMPORT_FUNCTION: "createGroq",
      MODEL_IMPORT_PATH: "@ai-sdk/groq",
      ENV_VAR_KEY: "GROQ_API_KEY",
      MODEL_VARIABLE: "groq",
      MODEL_VERSION: "deepseek-r1-distill-llama-70b",
    },
    openai: {
      MODEL_NAME: "OpenAI",
      MODEL_IMPORT_FUNCTION: "createOpenAI",
      MODEL_IMPORT_PATH: "@ai-sdk/openai",
      ENV_VAR_KEY: "OPENAI_API_KEY",
      MODEL_VARIABLE: "openai",
      MODEL_VERSION: "gpt-4o",
    },
    anthropic: {
      MODEL_NAME: "Anthropic",
      MODEL_IMPORT_FUNCTION: "createAnthropic",
      MODEL_IMPORT_PATH: "@ai-sdk/anthropic",
      ENV_VAR_KEY: "ANTHROPIC_API_KEY",
      MODEL_VARIABLE: "anthropic",
      MODEL_VERSION: "claude-3-opus-20240229",
    },
    google: {
      MODEL_NAME: "Google",
      MODEL_IMPORT_FUNCTION: "createGoogle",
      MODEL_IMPORT_PATH: "@ai-sdk/google",
      ENV_VAR_KEY: "GOOGLE_API_KEY",
      MODEL_VARIABLE: "google",
      MODEL_VERSION: "gemini-1.5-pro",
    },
  };

  // Replace placeholders with model-specific values
  const config = modelConfig[selectedModel as keyof typeof modelConfig];

  // Prepare extension imports and extension list for template generation
  const extensionImports: string[] = [];
  const extensionsList: string[] = [];

  for (const ext of selectedExtensions) {
    if (ext === "cli") {
      extensionImports.push(
        `import { cli } from "@daydreamsai/core/extensions";`
      );
      extensionsList.push("cli");
    } else if (ext === "twitter") {
      extensionImports.push(
        `import { twitter } from "@daydreamsai/core/extensions";`
      );
      extensionsList.push("twitter");
    } else if (ext === "discord") {
      extensionImports.push(
        `import { discord } from "@daydreamsai/core/extensions";`
      );
      extensionsList.push("discord");
    } else if (ext === "telegram") {
      extensionImports.push(
        `import { telegram } from "@daydreamsai/core/extensions";`
      );
      extensionsList.push("telegram");
    }
  }

  // Generate the template content with all replacements
  const processedContent = generateTemplateContent(
    templateContent,
    config,
    extensionImports,
    extensionsList
  );

  // Write the modified template to the target directory
  await fs.writeFile(path.join(targetPath, "index.ts"), processedContent);
  spinner.succeed(
    `Created agent with ${selectedModel} model and extensions: ${selectedExtensions.join(", ")}`
  );

  // Create .env file with required environment variables
  spinner.start("Creating .env file");
  const envContent = createEnvVariables(selectedModel, selectedExtensions);
  await fs.writeFile(path.join(targetPath, ".env.example"), envContent);
  spinner.succeed("Created .env.example file");

  // Create README
  spinner.start("Creating README");
  const readmeContent = createReadme(
    path.basename(targetPath),
    selectedExtensions,
    selectedModel
  );
  await fs.writeFile(path.join(targetPath, "README.md"), readmeContent);
  spinner.succeed("Created README");

  // Install dependencies - simplified to directly use pnpm
  spinner.start("Installing dependencies with pnpm");
  try {
    await execa("pnpm", ["install"], { cwd: targetPath });

    // Verify node_modules exists
    const nodeModulesPath = path.join(targetPath, "node_modules");
    const nodeModulesExists = await fs.pathExists(nodeModulesPath);

    if (nodeModulesExists) {
      spinner.succeed("Installed dependencies using pnpm");
    } else {
      spinner.fail(
        "Dependencies installed but node_modules directory wasn't found"
      );
      console.log(
        chalk.yellow(
          "You can install dependencies manually by running 'pnpm install' in the project directory."
        )
      );
    }
  } catch (error: unknown) {
    spinner.fail("Failed to install dependencies");
    console.error(
      chalk.red(
        `Error: ${error instanceof Error ? error.message : String(error)}`
      )
    );
    console.log(
      chalk.yellow(
        "You can install dependencies manually by running 'pnpm install' in the project directory."
      )
    );
  }

  console.log();
  console.log(
    chalk.green("✅ Your Daydreams agent has been created successfully!")
  );
  console.log();
  console.log(`To get started, run the following commands:`);

  if (targetDir !== ".") {
    console.log(`  cd ${targetDir}`);
  }

  console.log(`  cp .env.example .env`);
  console.log(`  # Fill in the required environment variables in .env`);
  console.log(`  npm start`);
  console.log();
}

// Directly run the main function when this file is executed directly
if (
  import.meta.url &&
  process.argv[1] &&
  (import.meta.url.endsWith(process.argv[1]) ||
    process.argv[1].endsWith("index.js") ||
    process.argv[1].endsWith("create-agent"))
) {
  main().catch((error) => {
    console.error(
      chalk.red(
        `Error: ${error instanceof Error ? error.message : String(error)}`
      )
    );
    process.exit(1);
  });
}

--- End File: packages/create-agent/src/index.ts ---

--- File: packages/create-agent/src/utils.ts ---
import { execa } from "execa";
import fs from "fs-extra";
import path from "path";
import chalk from "chalk";

/**
 * Generates the content for an agent template by replacing placeholders
 * @param templateContent The original template content with placeholders
 * @param modelConfig The model-specific configuration values
 * @param extensionImports Array of extension import statements
 * @param extensionsList Array of extension variable names
 * @returns The processed template content
 */
export function generateTemplateContent(
  templateContent: string,
  modelConfig: Record<string, string>,
  extensionImports: string[] = [],
  extensionsList: string[] = []
): string {
  // Replace model-specific placeholders
  let processedContent = templateContent;

  // Replace placeholders with model-specific values
  Object.entries(modelConfig).forEach(([key, value]) => {
    const placeholder = new RegExp(`{{${key}}}`, "g");
    processedContent = processedContent.replace(placeholder, value);
  });

  // Replace extension imports if specified
  if (extensionImports.length > 0) {
    processedContent = processedContent.replace(
      `import { cli } from "@daydreamsai/core/extensions";`,
      extensionImports.join("\n")
    );
  }

  // Replace extensions list in createDreams if specified
  if (extensionsList.length > 0) {
    processedContent = processedContent.replace(
      "extensions: [cli]",
      `extensions: [${extensionsList.join(", ")}]`
    );
  }

  // Add header comment
  const headerComment = `/**
 * Daydreams agent with ${extensionsList.join(", ")} extension(s)
 * Using ${modelConfig.MODEL_NAME} as the model provider
 */`;

  processedContent = processedContent.replace(
    /\/\*\*[\s\S]*?\*\//,
    headerComment
  );

  return processedContent;
}

/**
 * Creates environment variables content for the .env.example file
 * @param selectedModel The selected model provider
 * @param selectedExtensions Array of selected extensions
 * @returns The content for the .env.example file
 */
export function createEnvVariables(
  selectedModel: string,
  selectedExtensions: string[]
): string {
  const envVariables = ["# Daydreams Environment Variables\n"];

  // Model configurations
  envVariables.push("# Model Configurations");
  if (selectedModel === "groq") {
    envVariables.push("GROQ_API_KEY=your_groq_api_key");
  } else if (selectedModel === "openai") {
    envVariables.push("OPENAI_API_KEY=your_openai_api_key");
  } else if (selectedModel === "anthropic") {
    envVariables.push("ANTHROPIC_API_KEY=your_anthropic_api_key");
  } else if (selectedModel === "google") {
    envVariables.push("GOOGLE_API_KEY=your_google_api_key");
  }

  // Add OpenRouter API key regardless of selected model
  envVariables.push("OPENROUTER_API_KEY=your_openrouter_api_key\n");

  // Twitter Configuration
  if (selectedExtensions.includes("twitter")) {
    envVariables.push("# Twitter Configuration");
    // Add both authentication methods
    envVariables.push("# Method 1: Username/Password");
    envVariables.push("TWITTER_USERNAME=your_twitter_username");
    envVariables.push("TWITTER_PASSWORD=your_twitter_password");
    envVariables.push("TWITTER_EMAIL=your_twitter_email");

    envVariables.push("# Method 2: API Keys");
    envVariables.push("TWITTER_CONSUMER_KEY=your_consumer_key");
    envVariables.push("TWITTER_CONSUMER_SECRET=your_consumer_secret");
    envVariables.push("TWITTER_ACCESS_TOKEN=your_access_token");
    envVariables.push("TWITTER_ACCESS_TOKEN_SECRET=your_access_token_secret\n");
  }

  // Discord Configuration
  if (selectedExtensions.includes("discord")) {
    envVariables.push("# Discord Configuration");
    envVariables.push(
      "# Discord Bot Token (https://discord.com/developers/applications)"
    );
    envVariables.push(
      "# Required Gateway Intents: Server Members, Message Content, Presence"
    );
    envVariables.push("DISCORD_TOKEN=your_discord_token");
    envVariables.push("DISCORD_BOT_NAME=your_bot_name\n");
  }

  // Telegram Configuration
  if (selectedExtensions.includes("telegram")) {
    envVariables.push("# Telegram Configuration");
    envVariables.push(
      "# TELEGRAM_STARTUP_CHAT_ID: Chat ID where startup notifications will be sent"
    );
    envVariables.push("TELEGRAM_STARTUP_CHAT_ID=your_startup_chat_id");

    envVariables.push(
      "# GramJS Configuration (required for both bot and user clients)"
    );
    envVariables.push(
      "# TELEGRAM_TOKEN: Bot token from @BotFather (required for bot mode)"
    );
    envVariables.push("TELEGRAM_TOKEN=your_telegram_token");

    envVariables.push("# Get these from https://my.telegram.org/apps");
    envVariables.push("TELEGRAM_API_ID=your_api_id");
    envVariables.push("TELEGRAM_API_HASH=your_api_hash");

    envVariables.push("# Optional: Session string for user authentication");
    envVariables.push(
      "# After first successful interactive login, the app will provide a session string"
    );
    envVariables.push(
      "# Save it here to avoid interactive login in subsequent runs"
    );
    envVariables.push("TELEGRAM_USER_SESSION=your_session_string\n");
  }

  // Add common configurations regardless of extensions
  envVariables.push("# General Configuration");
  envVariables.push("DRY_RUN=1");
  envVariables.push(
    "GRAPHQL_URL=https://api.cartridge.gg/x/sepolia-rc-18/torii\n"
  );

  // Add blockchain configurations
  envVariables.push("# Blockchain Configurations");

  envVariables.push("# Starknet Configuration");
  envVariables.push("STARKNET_RPC_URL=your_starknet_rpc_url");
  envVariables.push("STARKNET_ADDRESS=your_starknet_address");
  envVariables.push("STARKNET_PRIVATE_KEY=your_starknet_private_key\n");

  envVariables.push("# Hyperliquid Trading Configuration");
  envVariables.push(
    "# HYPERLIQUID_MAIN_ADDRESS: Your main Hyperliquid address (format: 0x...)"
  );
  envVariables.push(
    "# HYPERLIQUID_WALLET_ADDRESS: Your wallet address for trading (format: 0x...)"
  );
  envVariables.push(
    "# HYPERLIQUID_PRIVATE_KEY: Your private key (Keep this secure!)"
  );
  envVariables.push("HYPERLIQUID_MAIN_ADDRESS=your_main_address");
  envVariables.push("HYPERLIQUID_WALLET_ADDRESS=your_wallet_address");
  envVariables.push("HYPERLIQUID_PRIVATE_KEY=your_private_key\n");

  envVariables.push("# Sui Configuration");
  envVariables.push(
    "# Sui Mnemonic Seed Phrase (`sui keytool generate ed25519`), Also support `suiprivatekeyxxxx` (sui keytool export --key-identity 0x63)"
  );
  envVariables.push("SUI_PRIVATE_KEY=your_sui_private_key");
  envVariables.push(
    "SUI_NETWORK=mainnet   # must be one of mainnet, testnet, devnet, localnet\n"
  );

  return envVariables.join("\n");
}

/**
 * Creates a README file content for the agent
 * @param projectName The name of the project
 * @param selectedExtensions Array of selected extensions
 * @param selectedModel The selected model provider
 * @returns The content for the README.md file
 */
export function createReadme(
  projectName: string,
  selectedExtensions: string[],
  selectedModel: string
): string {
  return `# ${projectName}

A Daydreams agent with the following extensions:
${selectedExtensions.map((ext) => `- ${ext}`).join("\n")}

## Features

- Uses ${selectedModel} as the model provider
- Includes context for managing goals and tasks
- Provides actions for adding and completing tasks

## Getting Started

1. Copy \`.env.example\` to \`.env\` and fill in the required values.
2. Install dependencies:

\`\`\`
bun install
\`\`\`

3. Run the agent:

\`\`\`
bun start
\`\`\`

## Customizing Your Agent

You can modify the \`index.ts\` file to add more contexts, actions, or change the model configuration.
`;
}

--- End File: packages/create-agent/src/utils.ts ---

--- File: packages/create-agent/templates/basic/template.ts ---
/**
 * {{MODEL_NAME}} template for a Daydreams agent
 * This template includes context for goals and tasks, and actions for managing them
 */
import { {{MODEL_IMPORT_FUNCTION}} } from "{{MODEL_IMPORT_PATH}}";
import {
    createDreams,
    context,
    render,
    action,
    validateEnv,
} from "@daydreamsai/core";
import { cli } from "@daydreamsai/core/extensions";
import { string, z } from "zod";

const env = validateEnv(
    z.object({
        {{ENV_VAR_KEY}}: z.string().min(1, "{{ENV_VAR_KEY}} is required"),
    })
);

// Initialize {{MODEL_NAME}} client
const {{MODEL_VARIABLE}} = {{MODEL_IMPORT_FUNCTION}}({
    apiKey: env.{{ENV_VAR_KEY}}!,
});

const template = `
Goal: {{goal}} 
Tasks: {{tasks}}
Current Task: {{currentTask}}
`;

type GoalMemory = {
    goal: string;
    tasks: string[];
    currentTask: string;
};

const goalContexts = context({
    type: "goal",
    schema: z.object({
        id: string(),
        initialGoal: z.string(),
        initialTasks: z.array(z.string()),
    }),

    key({ id }: { id: string }) {
        return id;
    },

    create(state: { args: { initialGoal: string; initialTasks: string[] } }) {
        return {
            goal: state.args.initialGoal,
            tasks: state.args.initialTasks ?? [],
            currentTask: state.args.initialTasks?.[0],
        };
    },

    render({ memory }: { memory: GoalMemory }) {
        return render(template, {
            goal: memory.goal,
            tasks: memory.tasks.join("\n"),
            currentTask: memory.currentTask ?? "NONE",
        });
    },
});

createDreams({
    model: {{MODEL_VARIABLE}}("{{MODEL_VERSION}}"),
    extensions: [cli],
    context: goalContexts,
    actions: [
        action({
            name: "addTask",
            description: "Add a task to the goal",
            schema: z.object({ task: z.string() }),
            handler(
                call: { data: { task: string } },
                ctx: { agentMemory: any },
                _agent: any
            ) {
                const agentMemory = ctx.agentMemory as GoalMemory;
                agentMemory.tasks.push(call.data.task);
                return {};
            },
        }),
        action({
            name: "completeTask",
            description: "Complete a task",
            schema: z.object({ task: z.string() }),
            handler(
                call: { data: { task: string } },
                ctx: { agentMemory: any },
                _agent: any
            ) {
                const agentMemory = ctx.agentMemory as GoalMemory;
                agentMemory.tasks = agentMemory.tasks.filter(
                    (task) => task !== call.data.task
                );
                return {};
            },
        }),
    ],
}).start({ id: "test", initialGoal: "", initialTasks: [] });

--- End File: packages/create-agent/templates/basic/template.ts ---

--- File: packages/create-agent/vitest.config.ts ---
import { defineConfig } from "vitest/config";
import { fileURLToPath } from "url";
import path from "path";

const __dirname = path.dirname(fileURLToPath(import.meta.url));

export default defineConfig({
  test: {
    environment: "node",
    include: ["test/**/*.test.ts"],
    exclude: ["**/node_modules/**", "**/dist/**"],
    globals: true,
    coverage: {
      provider: "v8",
      reporter: ["text", "json", "html"],
      exclude: ["node_modules/", "test/"],
    },
  },
  resolve: {
    alias: {
      "@": path.resolve(__dirname, "./src"),
    },
  },
});

--- End File: packages/create-agent/vitest.config.ts ---

--- File: packages/defai/package.json ---
{
  "name": "@daydreamsai/defai",
  "version": "0.3.6",
  "type": "module",
  "main": "./dist/index.js",
  "module": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "exports": {
    "./package.json": "./package.json",
    ".": {
      "types": "./dist/index.d.ts",
      "require": "./dist/index.js",
      "import": "./dist/index.js"
    }
  },
  "devDependencies": {
    "@types/bun": "latest",
    "tsup": "^8.3.6",
    "vitest": "^3.0.5"
  },
  "scripts": {
    "test": "vitest",
    "build": "tsup --dts-resolve"
  },
  "peerDependencies": {
    "typescript": "^5.8.2"
  },
  "dependencies": {
    "@cetusprotocol/aggregator-sdk": "^0.3.32",
    "@daydreamsai/core": "workspace:*",
    "@mysten/sui": "1.7.0",
    "@solana/web3.js": "^1.98.0",
    "bignumber.js": "^9.1.2",
    "bs58": "^6.0.0",
    "discord.js": "^14.18.0",
    "ethers": "^6.13.5",
    "starknet": "^6.24.1",
    "zod": "^3.24.2"
  }
}

--- End File: packages/defai/package.json ---

--- File: packages/defai/src/evm.ts ---
import { ethers } from "ethers";
import type { IChain } from "@daydreamsai/core";

/**
 * Configuration options for initializing an EVM chain connection
 */
export interface EvmChainConfig {
  /**
   * A name or descriptive label for this EVM chain (e.g. "ethereum", "polygon", "bsc", etc.)
   */
  chainName: string;

  /**
   * The RPC endpoint URL (e.g., Infura, Alchemy, local node, etc.)
   */
  rpcUrl: string;

  /**
   * A private key for signing transactions. In production, manage keys securely!
   */
  privateKey: string;

  /**
   * (Optional) Chain ID (e.g. 1 for mainnet, 5 for Goerli). Not strictly required,
   * but can help with certain ethers.js checks.
   */
  chainId?: number;
}

/**
 * Implementation of the IChain interface for Ethereum Virtual Machine (EVM) compatible chains.
 * Provides methods for reading from and writing to EVM-based blockchains.
 *
 * @example
 * ```typescript
 * const evmChain = new EvmChain({
 *   chainName: "ethereum",
 *   rpcUrl: process.env.ETH_RPC_URL,
 *   privateKey: process.env.ETH_PRIVATE_KEY,
 *   chainId: 1
 * });
 * ```
 */
export class EvmChain implements IChain {
  /**
   * Unique identifier for this chain implementation.
   * Matches the IChain interface.
   * This could be "ethereum", "polygon", etc.
   */
  public chainId: string;

  /**
   * JSON-RPC provider instance for connecting to the blockchain
   */
  private provider: ethers.JsonRpcProvider;

  /**
   * Wallet instance for signing transactions
   */
  private signer: ethers.Wallet;

  /**
   * Creates a new EVM chain instance
   * @param config - Configuration options for the chain connection
   */
  constructor(private config: EvmChainConfig) {
    this.chainId = config.chainName;
    // 1) Create a provider for this chain
    this.provider = new ethers.JsonRpcProvider(config.rpcUrl, {
      chainId: config.chainId,
      name: config.chainName,
    });

    // 2) Create a signer from the private key
    this.signer = new ethers.Wallet(config.privateKey, this.provider);
  }

  /**
   * Performs a read operation on the blockchain, typically calling a view/pure contract function
   * that doesn't modify state.
   *
   * @param call - The call parameters
   * @param call.contractAddress - Address of the contract to call
   * @param call.abi - Contract ABI (interface)
   * @param call.functionName - Name of the function to call
   * @param call.args - Arguments to pass to the function
   * @returns The result of the contract call
   * @throws Error if the call fails
   */
  public async read(call: unknown): Promise<any> {
    try {
      // In a real implementation, you might use a Zod schema or TS check here:
      const {
        contractAddress,
        abi,
        functionName,
        args = [],
      } = call as {
        contractAddress: string;
        abi: any;
        functionName: string;
        args?: any[];
      };

      // 1) Create a contract object with the provider
      const contract = new ethers.Contract(contractAddress, abi, this.provider);

      // 2) Call the function
      return await contract[functionName](...args);
    } catch (error) {
      return error instanceof Error
        ? error
        : new Error("Unknown error occurred in read()");
    }
  }

  /**
   * Performs a write operation on the blockchain by sending a transaction that modifies state.
   * Examples include transferring tokens or updating contract storage.
   *
   * @param call - The transaction parameters
   * @param call.contractAddress - Address of the contract to interact with
   * @param call.abi - Contract ABI (interface)
   * @param call.functionName - Name of the function to call
   * @param call.args - Arguments to pass to the function
   * @param call.overrides - Optional transaction overrides (gas limit, gas price, etc)
   * @returns The transaction receipt after confirmation
   * @throws Error if the transaction fails
   */
  public async write(call: unknown): Promise<any> {
    try {
      const {
        contractAddress,
        abi,
        functionName,
        args = [],
        overrides = {},
      } = call as {
        contractAddress: string;
        abi: any;
        functionName: string;
        args?: any[];
        overrides?: ethers.Overrides;
      };

      // 1) Create a contract object connected to the signer
      const contract = new ethers.Contract(contractAddress, abi, this.signer);

      // 2) Send the transaction
      const tx = await contract[functionName](...args, overrides);

      // 3) Optionally wait for it to confirm
      const receipt = await tx.wait();
      return receipt; // or return { tx, receipt } if you want both
    } catch (error) {
      return error instanceof Error
        ? error
        : new Error("Unknown error occurred in write()");
    }
  }
}

--- End File: packages/defai/src/evm.ts ---

--- File: packages/defai/src/index.ts ---
export * from "./starknet";
export * from "./solana";
export * from "./evm";
export * from "./sui";

--- End File: packages/defai/src/index.ts ---

--- File: packages/defai/src/solana.ts ---
import {
  Connection,
  Keypair,
  PublicKey,
  Transaction,
  sendAndConfirmTransaction,
} from "@solana/web3.js";
import type { IChain } from "@daydreamsai/core";
import bs58 from "bs58";

export interface SolanaChainConfig {
  /**
   * A descriptive chain name or environment (e.g., "solana-mainnet", "solana-devnet").
   */
  chainName: string;

  /**
   * RPC endpoint for Solana (e.g. https://api.devnet.solana.com).
   */
  rpcUrl: string;

  /**
   * Base-58 encoded private key or some format from which you can construct a Keypair.
   * In a real scenario, handle keys more securely (e.g., using a keystore or external vault).
   */
  privateKey: string;
}

export class SolanaChain implements IChain {
  public chainId: string; // e.g. "solana-mainnet" or "solana-devnet"
  private connection: Connection;
  private keypair: Keypair;

  constructor(private config: SolanaChainConfig) {
    this.chainId = config.chainName;

    // 1) Create a Connection to the Solana cluster
    this.connection = new Connection(config.rpcUrl);

    // 2) Create a Keypair from the private key
    //    - We assume it's a base-58 encoded private key (64- or 32-byte).
    //    - Another approach is if config.privateKey is a JSON array of 64 ints, etc.
    this.keypair = this.createKeypairFromBase58(config.privateKey);
  }

  /**
   * Example "read" method. Because Solana doesn't have a direct "contract read" by default,
   * we might interpret read calls as:
   *  - "getAccountInfo" or
   *  - "getBalance", or
   *  - "getProgramAccounts"
   *
   * So let's define a simple structure we can parse to do the relevant read.
   *
   * read({ type: "getBalance", address: "..." })
   * read({ type: "getAccountInfo", address: "..." })
   */
  public async read(call: unknown): Promise<any> {
    try {
      const { type, address } = call as {
        type: string;
        address: string;
      };

      switch (type) {
        case "getBalance": {
          const pubKey = new PublicKey(address);
          const lamports = await this.connection.getBalance(pubKey);
          return lamports; // in lamports
        }
        case "getAccountInfo": {
          const pubKey = new PublicKey(address);
          const accountInfo = await this.connection.getAccountInfo(pubKey);
          return accountInfo; // can be null if not found
        }
        case "getBlockHeight": {
          const blockHeight = await this.connection.getBlockHeight();
          return blockHeight;
        }
        // Extend with more read patterns as needed
        default:
          throw new Error(`Unknown read type: ${type}`);
      }
    } catch (error) {
      return error instanceof Error
        ? error
        : new Error("Unknown error occurred in Solana read()");
    }
  }

  /**
   * Example "write" method. We'll treat this as "send a Solana transaction."
   * A typical transaction might have multiple instructions.
   *
   * We'll define a structure for the `call` param:
   * {
   *   instructions: TransactionInstruction[];
   *   signers?: Keypair[];
   * }
   * where "instructions" is an array of instructions you want to execute.
   *
   * The agent or caller is responsible for constructing those instructions (e.g. for
   * token transfers or program interactions).
   */
  public async write(call: unknown): Promise<any> {
    try {
      const { instructions, signers = [] } = call as {
        instructions: any[]; // or TransactionInstruction[]
        signers: Keypair[];
      };

      // 1) Build a Transaction object
      const transaction = new Transaction().add(...instructions);

      // 2) We'll sign with the primary keypair + any additional signers
      // Typically, the main Keypair is the fee payer
      transaction.feePayer = this.keypair.publicKey;

      // 3) Send and confirm the transaction
      const txSig = await sendAndConfirmTransaction(
        this.connection,
        transaction,
        [this.keypair, ...signers]
      );

      return txSig; // transaction signature
    } catch (error) {
      return error instanceof Error
        ? error
        : new Error("Unknown error in Solana write()");
    }
  }

  /**
   * Helper method: Convert a base-58 string private key into a Keypair.
   * Implementation depends on how your private key is stored.
   */
  private createKeypairFromBase58(secretBase58: string): Keypair {
    const secretKeyBytes = Buffer.from(bs58.decode(secretBase58));
    // For Solana, a 64-byte secret is typical.
    // Another approach is if you have a 32-byte seed, etc.
    return Keypair.fromSecretKey(secretKeyBytes);
  }
}

--- End File: packages/defai/src/solana.ts ---

--- File: packages/defai/src/starknet.ts ---
import { RpcProvider, Account, type Call, CallData } from "starknet";
import type { IChain } from "@daydreamsai/core";

/**
 * Configuration options for initializing a Starknet chain connection
 */
export interface StarknetChainConfig {
  /** The RPC endpoint URL for connecting to Starknet */
  rpcUrl: string;
  /** The Starknet account contract address */
  address: string;
  /** Private key for signing transactions. Should be managed securely! */
  privateKey: string;
}

/**
 * Implementation of the IChain interface for interacting with the Starknet L2 blockchain
 *
 * @example
 * ```ts
 * const starknet = new StarknetChain({
 *   rpcUrl: process.env.STARKNET_RPC_URL,
 *   address: process.env.STARKNET_ADDRESS,
 *   privateKey: process.env.STARKNET_PRIVATE_KEY
 * });
 * ```
 */
export class StarknetChain implements IChain {
  /** Unique identifier for this chain implementation */
  public chainId = "starknet";
  /** RPC provider instance for connecting to Starknet */
  private provider: RpcProvider;
  /** Account instance for transaction signing */
  private account: Account;

  /**
   * Creates a new StarknetChain instance
   * @param config - Configuration options for the Starknet connection
   */
  constructor(config: StarknetChainConfig) {
    this.provider = new RpcProvider({ nodeUrl: config.rpcUrl });
    this.account = new Account(
      this.provider,
      config.address,
      config.privateKey
    );
  }

  /**
   * Performs a read-only call to a Starknet contract
   * @param call - The contract call parameters
   * @returns The result of the contract call
   * @throws Error if the call fails
   */
  public async read(call: Call): Promise<any> {
    try {
      call.calldata = CallData.compile(call.calldata || []);
      return this.provider.callContract(call);
    } catch (error) {
      return error instanceof Error
        ? error
        : new Error("Unknown error occurred");
    }
  }

  /**
   * Executes a state-changing transaction on Starknet
   * @param call - The transaction parameters
   * @returns The transaction receipt after confirmation
   * @throws Error if the transaction fails
   */
  public async write(call: Call): Promise<any> {
    try {
      call.calldata = CallData.compile(call.calldata || []);
      const { transaction_hash } = await this.account.execute(call);
      return this.account.waitForTransaction(transaction_hash, {
        retryInterval: 1000,
      });
    } catch (error) {
      return error instanceof Error
        ? error
        : new Error("Unknown error occurred");
    }
  }
}

--- End File: packages/defai/src/starknet.ts ---

--- File: packages/defai/src/sui.ts ---
import {
  getFullnodeUrl,
  SuiClient,
  type SuiTransactionBlockResponse,
} from "@mysten/sui/client";
import { getFaucetHost, requestSuiFromFaucetV0 } from "@mysten/sui/faucet";
import type { Signer } from "@mysten/sui/cryptography";
import { Ed25519Keypair } from "@mysten/sui/keypairs/ed25519";
import { Secp256k1Keypair } from "@mysten/sui/keypairs/secp256k1";
import { Secp256r1Keypair } from "@mysten/sui/keypairs/secp256r1";
import {
  Transaction,
  type TransactionObjectArgument,
} from "@mysten/sui/transactions";
import { SUI_DECIMALS } from "@mysten/sui/utils";
import { AggregatorClient, Env } from "@cetusprotocol/aggregator-sdk";
import BN from "bignumber.js";
import type { IChain } from "@daydreamsai/core";

interface SwapResult {
  success: boolean;
  tx: string;
  message: string;
}

interface TokenMetadata {
  symbol: string;
  decimals: number;
  tokenAddress: string;
}

const parseAccount = (privateKey: string): Signer => {
  if (privateKey.startsWith("suiprivkey")) {
    return loadFromSecretKey(privateKey);
  }
  return loadFromMnemonics(privateKey);
};
const loadFromSecretKey = (privateKey: string) => {
  // Remove the "suiprivkey" prefix if present
  const cleanedKey = privateKey.startsWith("suiprivkey")
    ? privateKey.substring("suiprivkey".length)
    : privateKey;

  // Convert the string to Uint8Array as required by the keypair classes
  const privateKeyBytes = new Uint8Array(Buffer.from(cleanedKey, "base64"));

  const keypairClasses = [Ed25519Keypair, Secp256k1Keypair, Secp256r1Keypair];
  for (const KeypairClass of keypairClasses) {
    try {
      return KeypairClass.fromSecretKey(privateKeyBytes);
    } catch {}
  }
  throw new Error("Failed to initialize keypair from secret key");
};

const loadFromMnemonics = (mnemonics: string) => {
  const keypairMethods = [
    { Class: Ed25519Keypair, method: "deriveKeypairFromSeed" },
    { Class: Secp256k1Keypair, method: "deriveKeypair" },
    { Class: Secp256r1Keypair, method: "deriveKeypair" },
  ];
  for (const { Class, method } of keypairMethods) {
    try {
      return (Class as any)[method](mnemonics);
    } catch {}
  }
  throw new Error("Failed to derive keypair from mnemonics");
};

export type SuiNetwork = "mainnet" | "testnet" | "devnet" | "localnet";
export type FaucetNetwork = "testnet" | "devnet" | "localnet";

export const supportedSuiTokens: Map<string, TokenMetadata> = new Map([
  [
    "SUI",
    {
      symbol: "SUI",
      decimals: SUI_DECIMALS,
      tokenAddress: "0x2::sui::SUI",
    },
  ],
  [
    "USDC",
    {
      symbol: "USDC",
      decimals: 6,
      tokenAddress:
        "0xdba34672e30cb065b1f93e3ab55318768fd6fef66c15942c9f7cb846e2f900e7::usdc::USDC",
    },
  ],
]);

export const getTokenMetadata = (symbol: string) => {
  const metadata = supportedSuiTokens.get(symbol.toUpperCase());
  if (!metadata) throw new Error(`Token ${symbol} not found`);
  return metadata;
};

/**
 * Configuration options for initializing a Sui chain connection
 */
export interface SuiChainConfig {
  /** Private key for signing transactions. Should be managed securely! */
  privateKey: string;
  /** Type of sui network */
  network: SuiNetwork;
}

/**
 * Implementation of the IChain interface for interacting with the Sui L1 blockchain
 *
 * @example
 * ```ts
 * const sui = new SuiChain({
 *   privateKey: process.env.SUI_PRIVATE_KEY,
 *   network: process.env.SUI_NETWORK,
 * });
 * ```
 */
export class SuiChain implements IChain {
  /** Unique identifier for this chain implementation */
  public chainId = "sui";
  /** RPC client instance for connecting to Sui */
  private client: SuiClient;
  /** Type of sui network */
  private network: SuiNetwork;
  /** Account instance for transaction signing */
  private wallet: Signer;

  /**
   * Creates a new SuiChain instance
   * @param config - Configuration options for the Sui connection
   */
  constructor(config: SuiChainConfig) {
    this.client = new SuiClient({
      url: getFullnodeUrl(config.network),
    });
    this.network = config.network;
    this.wallet = parseAccount(config.privateKey);
  }

  /**
   * Performs a read-only call to a Sui contract
   * @param call - The contract call parameters
   * @returns The result of the contract call
   * @throws Error if the call fails
   */
  public async read(call: unknown): Promise<any> {
    const { objectId } = call as {
      objectId: string;
    };

    const object = await this.client.getObject({
      id: objectId,
      options: {
        showContent: true,
        showBcs: true,
        showDisplay: true,
        showOwner: true,
        showPreviousTransaction: true,
        showStorageRebate: true,
        showType: true,
      },
    });

    return object;
  }

  /**
   * Executes a state-changing transaction on Sui
   * @param call - The transaction parameters
   * @returns The transaction receipt after confirmation
   * @throws Error if the transaction fails
   */
  public async write(call: unknown): Promise<SuiTransactionBlockResponse> {
    const { packageId, moduleName, functionName, params, tx } = call as {
      packageId: string;
      moduleName: string;
      functionName: string;
      params: Array<any>;
      tx: Transaction;
    };

    tx.moveCall({
      target: `${packageId}::${moduleName}::${functionName}`,
      arguments: params,
    });

    const result = await this.client.signAndExecuteTransaction({
      signer: this.wallet,
      transaction: tx,
    });

    return result;
  }

  /**
   * Executes a swap transaction on Sui
   * @param call - The swap transaction parameters
   * @returns The transaction digest and message after confirmation
   * @throws Error if the transaction fails
   */
  public async swapToken(call: unknown): Promise<SwapResult> {
    try {
      const { fromToken, amount, out_min_amount, targetToken } = call as {
        fromToken: string;
        amount: string;
        targetToken: string;
        out_min_amount: number | null;
      };

      const aggregatorURL = "https://api-sui.cetus.zone/router_v2/find_routes";
      const fromMeta = getTokenMetadata(fromToken);
      const toMeta = getTokenMetadata(targetToken);

      // Cast the client to any to avoid type incompatibilities
      const client = new AggregatorClient(
        aggregatorURL,
        this.wallet.toSuiAddress(),
        this.client as any,
        Env.Mainnet
      );
      // provider list : https://api-sui.cetus.zone/router_v2/status
      const routerRes = await client.findRouters({
        from: fromMeta.tokenAddress,
        target: toMeta.tokenAddress,
        amount: new BN(amount),
        byAmountIn: true, // `true` means fix input amount, `false` means fix output amount
        depth: 3, // max allow 3, means 3 hops
        providers: [
          "KRIYAV3",
          "CETUS",
          "SCALLOP",
          "KRIYA",
          "BLUEFIN",
          "DEEPBOOKV3",
          "FLOWXV3",
          "BLUEMOVE",
          "AFTERMATH",
          "FLOWX",
          "TURBOS",
        ],
      });
      if (routerRes === null) {
        console.error(
          "No router found " +
            JSON.stringify({
              from: fromMeta.tokenAddress,
              target: toMeta.tokenAddress,
              amount: amount,
            })
        );
        return {
          success: false,
          tx: "",
          message: "No router found",
        };
      }

      if (out_min_amount && routerRes.amountOut.toNumber() < out_min_amount) {
        return {
          success: false,
          tx: "",
          message: "Out amount is less than out_min_amount",
        };
      }

      let coin: TransactionObjectArgument;
      const routerTx = new Transaction();

      if (fromToken.toUpperCase() === "SUI") {
        coin = routerTx.splitCoins(routerTx.gas, [amount]);
      } else {
        const allCoins = await this.client.getCoins({
          owner: this.wallet.toSuiAddress(),
          coinType: fromMeta.tokenAddress,
          limit: 30,
        });

        if (allCoins.data.length === 0) {
          console.error("No coins found");
          return {
            success: false,
            tx: "",
            message: "No coins found",
          };
        }

        const mergeCoins = [];

        for (let i = 1; i < allCoins.data.length; i++) {
          mergeCoins.push(allCoins.data[i].coinObjectId);
        }

        if (mergeCoins.length > 0) {
          routerTx.mergeCoins(allCoins.data[0].coinObjectId, mergeCoins);
        }
        coin = routerTx.splitCoins(allCoins.data[0].coinObjectId, [amount]);
      }

      // Cast the transaction to any to avoid type incompatibilities
      const targetCoin = await client.routerSwap({
        routers: routerRes!.routes,
        byAmountIn: true,
        txb: routerTx as any,
        inputCoin: coin as any,
        slippage: 0.5,
      });

      routerTx.transferObjects([targetCoin], this.wallet.toSuiAddress());
      routerTx.setSender(this.wallet.toSuiAddress());

      // Cast the transaction and wallet to any to avoid type incompatibilities
      const result = await client.signAndExecuteTransaction(
        routerTx as any,
        this.wallet as any
      );

      await this.client.waitForTransaction({
        digest: result.digest,
      });

      return {
        success: true,
        tx: result.digest,
        message: "Swap successful",
      };
    } catch (e) {
      return {
        success: false,
        tx: "n/a",
        message: "Swap unsuccessful " + e?.toString(),
      };
    }
  }

  /**
   * Returns testnet sui tokens
   * @param call - The params for faucet
   * @returns Success/Failure message
   */
  public async requestSui(call: unknown): Promise<any> {
    try {
      const { network, recipient } = call as {
        network: FaucetNetwork;
        recipient: string;
      };

      await requestSuiFromFaucetV0({
        host: getFaucetHost(network),
        recipient,
      });

      return {
        message: `Successfully requested SUI to ${recipient} on ${network}`,
      };
    } catch (e) {
      return {
        message: `Failed to request SUI: ${e}`,
      };
    }
  }

  /**
   * Returns the sui address of the connected account
   */
  public getAddress(): string {
    return this.wallet.toSuiAddress();
  }
}

--- End File: packages/defai/src/sui.ts ---

--- File: packages/discord/package.json ---
{
  "name": "@daydreamsai/discord",
  "version": "0.3.6",
  "type": "module",
  "main": "./dist/index.js",
  "module": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "exports": {
    "./package.json": "./package.json",
    ".": {
      "types": "./dist/index.d.ts",
      "require": "./dist/index.js",
      "import": "./dist/index.js"
    }
  },
  "devDependencies": {
    "@types/bun": "latest",
    "tsup": "^8.3.6",
    "vitest": "^3.0.5"
  },
  "scripts": {
    "test": "vitest",
    "build": "tsup --dts-resolve"
  },
  "peerDependencies": {
    "typescript": "^5.6.3"
  },
  "dependencies": {
    "@daydreamsai/core": "workspace:*",
    "discord.js": "^14.18.0",
    "zod": "^3.24.2"
  }
}

--- End File: packages/discord/package.json ---

--- File: packages/discord/src/discord.ts ---
import { z } from "zod";
import { extension, input, output } from "@daydreamsai/core";
import { Events, type Message } from "discord.js";
import { DiscordClient } from "./io";
import { context } from "@daydreamsai/core";
import { service } from "@daydreamsai/core";
import { LogLevel } from "@daydreamsai/core";

/* Implementation of the discord extension */
const discordService = service({
  register(container) {
    container.singleton(
      "discord",
      () =>
        new DiscordClient(
          {
            discord_token: process.env.DISCORD_TOKEN!,
            discord_bot_name: process.env.DISCORD_BOT_NAME!,
          },
          LogLevel.DEBUG
        )
    );
  },
});

export const discordChannelContext = context({
  type: "discord.channel",
  key: ({ channelId }) => channelId,
  schema: z.object({ channelId: z.string() }),
  async setup(args, setttings, { container }) {
    const channel = await container
      .resolve<DiscordClient>("discord")
      .client.channels.fetch(args.channelId);

    if (!channel) throw new Error("Invalid channel");

    return { channel };
  },
})
  .setInputs({
    "discord:message": input({
      schema: {
        user: z.object({ id: z.string(), name: z.string() }),
        text: z.string(),
      },
      handler(data) {
        return {
          data: data.text,
          params: { userId: data.user.id, username: data.user.name },
        };
      },
      subscribe(send, { container }) {
        function listener(message: Message) {
          if (
            message.author.displayName ==
            container.resolve<DiscordClient>("discord").credentials
              .discord_bot_name
          ) {
            console.log(
              `Skipping message from ${
                container.resolve<DiscordClient>("discord").credentials
                  .discord_bot_name
              }`
            );
            return;
          }
          send(
            discord.contexts!.discordChannel,
            { channelId: message.channelId },
            {
              user: {
                id: message.author.id,
                name: message.author.displayName,
              },
              text: message.content,
            }
          );
        }

        const { client } = container.resolve<DiscordClient>("discord");

        client.on(Events.MessageCreate, listener);
        return () => {
          client.off(Events.MessageCreate, listener);
        };
      },
    }),
  })
  .setOutputs({
    "discord:message": output({
      schema: z.string(),
      examples: [`<output type="discord:message">Hi!</output>`],
      handler: async (data, ctx, { container }) => {
        const channel = ctx.options.channel;
        if (channel && (channel.isTextBased() || channel.isDMBased())) {
          await container.resolve<DiscordClient>("discord").sendMessage({
            channelId: ctx.args.channelId,
            content: data,
          });

          return {
            data,
            timestamp: Date.now(),
          };
        }
        throw new Error("Invalid channel id");
      },
    }),
  });

export const discord = extension({
  name: "discord",
  services: [discordService],
  contexts: {
    discordChannel: discordChannelContext,
  },
});

--- End File: packages/discord/src/discord.ts ---

--- File: packages/discord/src/index.ts ---
export * from "./discord";
export * from "./io";

--- End File: packages/discord/src/index.ts ---

--- File: packages/discord/src/io.ts ---
import {
  ChannelType,
  Client,
  Events,
  GatewayIntentBits,
  Partials,
  TextChannel,
  DMChannel,
  Message,
  type Channel,
} from "discord.js";
import { Logger, LogLevel } from "@daydreamsai/core";
import { z } from "zod";

export interface DiscordCredentials {
  discord_token: string;
  discord_bot_name: string;
}

export interface MessageData {
  content: string;
  channelId: string;
  conversationId?: string;
  sendBy?: string;
}

export const messageSchema = z.object({
  content: z.string().describe("The content of the message"),
  channelId: z.string().describe("The channel ID where the message is sent"),
  sendBy: z.string().optional().describe("The user ID of the sender"),
  conversationId: z
    .string()
    .optional()
    .describe("The conversation ID (if applicable)"),
});
export class DiscordClient {
  public client: Client;
  private logger: Logger;
  private messageListener?: (...args: any[]) => void;
  public credentials: DiscordCredentials;

  constructor(
    credentials: DiscordCredentials,
    logLevel: LogLevel = LogLevel.INFO
  ) {
    this.credentials = credentials;
    this.client = new Client({
      intents: [
        GatewayIntentBits.Guilds,
        GatewayIntentBits.GuildMessages,
        GatewayIntentBits.MessageContent,
        GatewayIntentBits.GuildMembers,
        GatewayIntentBits.DirectMessages,
        GatewayIntentBits.DirectMessageTyping,
        GatewayIntentBits.DirectMessageReactions,
      ],
      partials: [Partials.Channel], // For DM support
    });

    this.logger = new Logger({
      level: logLevel,
    });

    // Handle "ready" event
    this.client.on(Events.ClientReady, () => {
      this.logger.info("DiscordClient", "Initialized successfully");
    });

    // Log in to Discord
    this.client.login(this.credentials.discord_token).catch((error) => {
      this.logger.error("DiscordClient", "Failed to login", { error });
      console.error("Login error:", error);
    });
  }

  /**
   *  Optionally start listening to Discord messages.
   *  The onData callback typically feeds data into Orchestrator or similar.
   */
  public startMessageStream(onData: (data: any | any[]) => void) {
    this.logger.info("DiscordClient", "Starting message stream...");

    // If you want to capture the listener reference for removal:
    this.messageListener = (message: Message) => {
      // Here, you could decide what "data" looks like
      // E.g., check if the bot was mentioned, etc.

      if (message.author.displayName == this.credentials.discord_bot_name) {
        console.log(
          `Skipping message from ${this.credentials.discord_bot_name}`
        );
        return;
      }

      onData({
        userId: message.author?.displayName,
        platformId: "discord",
        threadId: message.channel.id,
        isDM: message.channel.type === ChannelType.DM,
        contentId: message.id,
        data: {
          content: message.content,
        },
      });
    };

    this.client.on(Events.MessageCreate, this.messageListener);
  }

  /**
   *  Optionally remove the message listener if you want to stop the stream.
   */
  public stopMessageStream() {
    if (this.messageListener) {
      this.client.removeListener(Events.MessageCreate, this.messageListener);
      this.logger.info("DiscordClient", "Message stream stopped");
    }
  }

  /**
   *  Gracefully destroy the Discord connection
   */
  public destroy() {
    this.stopMessageStream();
    this.client.destroy();
    this.logger.info("DiscordClient", "Client destroyed");
  }

  private getIsValidTextChannel(
    channel?: Channel
  ): channel is TextChannel | DMChannel {
    return (
      channel?.type === ChannelType.GuildText ||
      channel?.type === ChannelType.DM
    );
  }

  async sendMessage(data: MessageData): Promise<{
    success: boolean;
    messageId?: string;
    content?: string;
    error?: string;
  }> {
    try {
      this.logger.info("DiscordClient.sendMessage", "Sending message", {
        data,
      });

      if (!data?.channelId || !data?.content) {
        return {
          success: false,
          error: "Channel ID and content are required",
        };
      }

      const channel = this.client.channels.cache.get(data?.channelId);
      if (!this.getIsValidTextChannel(channel)) {
        const error = new Error(
          `Invalid or unsupported channel: ${data.channelId}`
        );
        this.logger.error(
          "DiscordClient.sendMessage",
          "Error sending message",
          {
            error,
          }
        );
        throw error;
      }

      let sentMessage;
      const MAX_LENGTH = 1500; // Setting a conservative limit to avoid Discord API errors

      console.log("Sending message", data.content.length);

      // If message is longer than MAX_LENGTH, split and send multiple messages
      if (data.content.length > MAX_LENGTH) {
        // Split on newlines if possible to maintain formatting
        const chunks = [];
        let currentChunk = "";
        const lines = data.content.split("\n");

        for (const line of lines) {
          // If adding this line would exceed max length, push current chunk and start new one
          if (currentChunk.length + line.length + 1 > MAX_LENGTH) {
            if (currentChunk) {
              chunks.push(currentChunk);
              currentChunk = "";
            }

            // If single line is longer than MAX_LENGTH, split it
            if (line.length > MAX_LENGTH) {
              let remainingLine = line;
              while (remainingLine.length > 0) {
                chunks.push(remainingLine.slice(0, MAX_LENGTH));
                remainingLine = remainingLine.slice(MAX_LENGTH);
              }
            } else {
              currentChunk = line;
            }
          } else {
            // Add line to current chunk
            currentChunk = currentChunk ? currentChunk + "\n" + line : line;
          }
        }

        // Push final chunk if it exists
        if (currentChunk) {
          chunks.push(currentChunk);
        }

        // Send all chunks sequentially
        for (const chunk of chunks) {
          sentMessage = await channel.send(chunk);
        }
      } else {
        // Send normal message
        sentMessage = await channel.send(data.content);
      }

      return {
        success: true,
        messageId: sentMessage?.id,
        content: data.content,
        error: undefined,
      };
    } catch (error) {
      this.logger.error("DiscordClient.sendMessage", "Error sending message", {
        error,
      });
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error",
      };
    }
  }
}

--- End File: packages/discord/src/io.ts ---

--- File: packages/hyperliquid/package.json ---
{
  "name": "@daydreamsai/hyperliquid",
  "version": "0.3.6",
  "type": "module",
  "main": "./dist/index.js",
  "module": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "exports": {
    "./package.json": "./package.json",
    ".": {
      "types": "./dist/index.d.ts",
      "require": "./dist/index.js",
      "import": "./dist/index.js"
    }
  },
  "devDependencies": {
    "@types/bun": "latest",
    "tsup": "^8.3.6",
    "vitest": "^3.0.5"
  },
  "scripts": {
    "test": "vitest",
    "build": "tsup --dts-resolve"
  },
  "peerDependencies": {
    "typescript": "^5.6.3"
  },
  "dependencies": {
    "@daydreamsai/core": "workspace:*",
    "hyperliquid": "^1.6.2",
    "zod": "^3.24.2"
  }
}

--- End File: packages/hyperliquid/package.json ---

--- File: packages/hyperliquid/src/hyperliquid.ts ---
import { Hyperliquid } from "hyperliquid";
import { Logger } from "@daydreamsai/core";
import { LogLevel } from "@daydreamsai/core";
import { z } from "zod";

const envSchema = z.object({
  HYPERLIQUID_MAIN_ADDRESS: z.string(),
  HYPERLIQUID_WALLET_ADDRESS: z.string(),
  HYPERLIQUID_PRIVATE_KEY: z.string(),
  WEBSOCKET_URL: z.string().default("ws://localhost:8080"),
  DRY_RUN: z
    .preprocess((val) => val === "1" || val === "true", z.boolean())
    .default(true),
});

export const env = envSchema.parse(process.env);

export interface HyperliquidCredentials {
  mainAddress: string;
  walletAddress: string;
  privateKey: string;
}

export class HyperliquidClient {
  private client: Hyperliquid;
  private mainAddress: string;
  private logger: Logger;
  private perpMeta: any;

  constructor(
    credentials: HyperliquidCredentials,
    logLevel: LogLevel = LogLevel.INFO,
    testnet: boolean = false
  ) {
    this.mainAddress = credentials.mainAddress;
    this.client = new Hyperliquid({
      enableWs: true,
      privateKey: credentials.privateKey,
      testnet,
      walletAddress: credentials.walletAddress,
    });
    this.logger = new Logger({
      level: logLevel,
    });

    this.client.connect().catch((error) => {
      this.logger.error("HyperliquidClient", "Failed to login", {
        error,
      });
      throw error;
    });
  }

  public async placeLimitOrderInstantOrCancel(
    ticker: string,
    sz: number,
    limit_px: number,
    is_buy: boolean
  ) {
    try {
      return await this.placeOrder(ticker, sz, limit_px, is_buy, {
        limit: { tif: "Ioc" },
      });
    } catch (error) {
      this.logger.error("HyperliquidClient", "Failed to place IOC order", {
        error,
        ticker,
        sz,
        limit_px,
        is_buy,
      });
      throw error;
    }
  }

  public async placeLimitOrderGoodTilCancel(
    ticker: string,
    sz: number,
    limit_px: number,
    is_buy: boolean
  ) {
    try {
      return await this.placeOrder(ticker, sz, limit_px, is_buy, {
        limit: { tif: "Gtc" },
      });
    } catch (error) {
      this.logger.error("HyperliquidClient", "Failed to place GTC order", {
        error,
        ticker,
        sz,
        limit_px,
        is_buy,
      });
      throw error;
    }
  }

  public async cancelOrder(ticker: string, orderId: number) {
    try {
      return await this.client.exchange.cancelOrder({
        coin: ticker,
        o: orderId,
      });
    } catch (error) {
      this.logger.error("HyperliquidClient", "Failed to cancel order", {
        error,
        ticker,
        orderId,
      });
      throw error;
    }
  }

  public async getAccountBalancesAndPositions() {
    try {
      return await this.client.info.perpetuals.getClearinghouseState(
        this.mainAddress
      );
    } catch (error) {
      this.logger.error(
        "HyperliquidClient",
        "Failed to get account balances and positions",
        { error }
      );
      throw error;
    }
  }

  public async getOpenOrders() {
    try {
      return await this.client.info.getUserOpenOrders(this.mainAddress);
    } catch (error) {
      this.logger.error("HyperliquidClient", "Failed to get open orders", {
        error,
      });
      throw error;
    }
  }

  public async marketSellPositions(tickers: string[]) {
    try {
      const positions = (await this.getAccountBalancesAndPositions())
        .assetPositions;
      return await Promise.all(
        tickers.map((ticker) => this.marketSellPosition(ticker, positions))
      );
    } catch (error) {
      this.logger.error(
        "HyperliquidClient",
        "Failed to market sell positions",
        { error, tickers }
      );
      throw error;
    }
  }

  public async marketSellPosition(ticker: string, positions: any) {
    try {
      if (!ticker) return;
      if (!positions) {
        const { assetPositions } = await this.getAccountBalancesAndPositions();
        positions = assetPositions;
      }
      const match = positions.find(
        (p: any) => p.position.coin === `${ticker.toUpperCase()}-PERP`
      );
      if (!match) return;
      const size = Number(match.position.szi);
      return await this.placeMarketOrder(ticker.toUpperCase(), size, false);
    } catch (error) {
      this.logger.error("HyperliquidClient", "Failed to market sell position", {
        error,
        ticker,
      });
      throw error;
    }
  }

  private async loadPerpMeta() {
    try {
      if (this.perpMeta) return;
      this.perpMeta = {};
      const universe = (await this.client.info.perpetuals.getMeta()).universe;
      universe.forEach((token) => {
        this.perpMeta[token.name] = token.szDecimals;
      });
    } catch (error) {
      this.logger.error("HyperliquidClient", "Failed to load perp meta", {
        error,
      });
      throw error;
    }
  }

  public async placeMarketOrderUSD(
    ticker: string,
    totalprice: number,
    is_buy: boolean
  ) {
    try {
      await this.loadPerpMeta();
      const orderbook = await this.client.info.getL2Book(ticker + "-PERP");
      const triggerPx = is_buy
        ? Number(orderbook.levels[1][3].px)
        : Number(orderbook.levels[0][3].px);
      let szDecimals = this.perpMeta[ticker + "-PERP"];
      if (szDecimals === undefined) {
        throw new Error("Can't find szDecimals for " + ticker);
      }
      const sz = Number((totalprice / triggerPx).toFixed(szDecimals));
      const result = await this.placeOrder(ticker, sz, triggerPx, is_buy, {
        limit: { tif: "Ioc" },
      });
      return result;
    } catch (error) {
      this.logger.error(
        "HyperliquidClient",
        "Failed to place market order USD",
        { error, ticker, totalprice, is_buy }
      );
      throw error;
    }
  }

  public async placeMarketOrder(ticker: string, sz: number, is_buy: boolean) {
    try {
      const orderbook = await this.client.info.getL2Book(ticker + "-PERP");
      const triggerPx = is_buy
        ? Number(orderbook.levels[1][3].px)
        : Number(orderbook.levels[0][3].px);
      const result = await this.placeOrder(ticker, sz, triggerPx, is_buy, {
        limit: { tif: "Ioc" },
      });
      return result;
    } catch (error) {
      this.logger.error("HyperliquidClient", "Failed to place market order", {
        error,
        ticker,
        sz,
        is_buy,
      });
      throw error;
    }
  }

  private async placeOrder(
    ticker: string,
    sz: number,
    limit_px: number,
    is_buy: boolean,
    order_type: object
  ) {
    try {
      return await this.client.exchange.placeOrder({
        coin: ticker + "-PERP",
        is_buy,
        sz,
        limit_px,
        order_type,
        reduce_only: false,
      });
    } catch (error) {
      this.logger.error("HyperliquidClient", "Failed to place order", {
        error,
        ticker,
        sz,
        limit_px,
        is_buy,
        order_type,
      });
      throw error;
    }
  }
}

--- End File: packages/hyperliquid/src/hyperliquid.ts ---

--- File: packages/hyperliquid/src/index.ts ---
export * from "./hyperliquid";

--- End File: packages/hyperliquid/src/index.ts ---

--- File: packages/mcp/README.md ---
# MCP Integration for Daydreams

This module provides integration with the Model Context Protocol (MCP), allowing
Daydreams agents to connect to any MCP server and access its resources, prompts,
and tools.

## Overview

The Model Context Protocol (MCP) allows applications to provide context for LLMs
in a standardized way, separating the concerns of providing context from the
actual LLM interaction. This integration enables Daydreams agents to:

- Connect to multiple MCP servers simultaneously
- Access resources from MCP servers
- Execute tools provided by MCP servers
- Use prompts defined on MCP servers

## Usage

### Basic Setup

To connect your Daydreams agent to one or more MCP servers, add the MCP
extension to your agent configuration:

```typescript
import { createDreams } from "@daydreams/core";
import { createMcpExtension } from "@daydreams/core/mcp";

const agent = createDreams({
  // ... other agent configuration
  extensions: [
    createMcpExtension([
      {
        id: "sqlite-explorer",
        name: "SQLite Explorer",
        transport: {
          type: "stdio",
          command: "node",
          args: ["path/to/sqlite-explorer-server.js"],
        },
      },
      {
        id: "web-search",
        name: "Web Search Service",
        transport: {
          type: "sse",
          serverUrl: "http://localhost:3001",
        },
      },
    ]),
    // ... other extensions
  ],
});

await agent.start();
```

### Available Actions

The MCP extension adds the following actions to your agent:

#### List MCP Servers

```typescript
// List all connected MCP servers
const result = await agent.callTool({
  name: "mcp.listServers",
  arguments: {},
});
```

#### List Prompts

```typescript
// List all prompts available on a specific MCP server
const result = await agent.callTool({
  name: "mcp.listPrompts",
  arguments: {
    serverId: "sqlite-explorer",
  },
});
```

#### Get a Prompt

```typescript
// Get a specific prompt from an MCP server
const result = await agent.callTool({
  name: "mcp.getPrompt",
  arguments: {
    serverId: "sqlite-explorer",
    name: "query-database",
    arguments: {
      table: "users",
    },
  },
});
```

#### List Resources

```typescript
// List all resources available on a specific MCP server
const result = await agent.callTool({
  name: "mcp.listResources",
  arguments: {
    serverId: "sqlite-explorer",
  },
});
```

#### Read a Resource

```typescript
// Read a specific resource from an MCP server
const result = await agent.callTool({
  name: "mcp.readResource",
  arguments: {
    serverId: "sqlite-explorer",
    uri: "schema://main",
  },
});
```

#### Call a Tool

```typescript
// Call a tool on an MCP server
const result = await agent.callTool({
  name: "mcp.callTool",
  arguments: {
    serverId: "sqlite-explorer",
    name: "query",
    arguments: {
      sql: "SELECT * FROM users LIMIT 10",
    },
  },
});
```

## Transport Types

The MCP extension supports two types of transports:

### stdio

Use this for local MCP servers that run as separate processes:

```typescript
{
  id: "local-server",
  name: "Local MCP Server",
  transport: {
    type: "stdio",
    command: "node",
    args: ["server.js"],
  },
}
```

### SSE (Server-Sent Events)

Use this for remote MCP servers that expose an HTTP API with SSE:

```typescript
{
  id: "remote-server",
  name: "Remote MCP Server",
  transport: {
    type: "sse",
    serverUrl: "http://example.com",
    sseEndpoint: "/sse",      // Optional, defaults to "/sse"
    messageEndpoint: "/messages", // Optional, defaults to "/messages"
  },
}
```

## Error Handling

All MCP actions return an `error` field if something goes wrong. You can check
for this field to handle errors:

```typescript
const result = await agent.callTool({
  name: "mcp.callTool",
  arguments: {
    serverId: "sqlite-explorer",
    name: "query",
    arguments: {
      sql: "SELECT * FROM users LIMIT 10",
    },
  },
});

if (result.error) {
  console.error("Error calling MCP tool:", result.error);
} else {
  console.log("Tool result:", result.result);
}
```

--- End File: packages/mcp/README.md ---

--- File: packages/mcp/package.json ---
{
  "name": "@daydreamsai/mcp",
  "version": "0.3.6",
  "type": "module",
  "main": "./dist/index.js",
  "module": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "exports": {
    "./package.json": "./package.json",
    ".": {
      "types": "./dist/index.d.ts",
      "require": "./dist/index.js",
      "import": "./dist/index.js"
    }
  },
  "devDependencies": {
    "@types/bun": "latest",
    "tsup": "^8.3.6",
    "vitest": "^3.0.5"
  },
  "scripts": {
    "test": "vitest",
    "build": "tsup --dts-resolve"
  },
  "peerDependencies": {
    "typescript": "^5.6.3"
  },
  "dependencies": {
    "@daydreamsai/core": "workspace:*",
    "@modelcontextprotocol/sdk": "^1.6.1",
    "zod": "^3.24.2"
  }
}

--- End File: packages/mcp/package.json ---

--- File: packages/mcp/src/client.ts ---
import { Client } from "@modelcontextprotocol/sdk/client/index.js";
import { StdioClientTransport } from "@modelcontextprotocol/sdk/client/stdio.js";
import { SSEClientTransport } from "@modelcontextprotocol/sdk/client/sse.js";

/**
 * Creates and connects an MCP client to a server
 * @param options Configuration options for the MCP client
 * @returns Connected MCP client instance
 */
export async function createMcpClient(options: {
  // Client identification
  clientInfo?: {
    name: string;
    version: string;
  };
  // Transport configuration
  transport: {
    type: "stdio" | "sse";
    // For stdio transport
    command?: string;
    args?: string[];
    // For SSE transport
    serverUrl?: string;
    sseEndpoint?: string;
    messageEndpoint?: string;
  };
  // Capabilities to request from the server
  capabilities?: {
    prompts?: Record<string, unknown>;
    resources?: Record<string, unknown>;
    tools?: Record<string, unknown>;
  };
  env?: Record<string, string>;
}) {
  // Set default client info if not provided
  const clientInfo = options.clientInfo || {
    name: "generic-mcp-client",
    version: "1.0.0",
  };

  // Set default capabilities if not provided
  const capabilities = options.capabilities || {
    prompts: {},
    resources: {},
    tools: {},
  };

  // Create the appropriate transport based on the type
  let transport;
  if (options.transport.type === "stdio") {
    if (!options.transport.command) {
      throw new Error("Command is required for stdio transport");
    }

    transport = new StdioClientTransport({
      command: options.transport.command,
      args: options.transport.args || [],
      env: options.env,
    });
  } else if (options.transport.type === "sse") {
    if (!options.transport.serverUrl) {
      throw new Error("Server URL is required for SSE transport");
    }

    // Create the SSE transport with the correct configuration
    // Convert string URL to URL object
    const serverUrl = new URL(options.transport.serverUrl);
    transport = new SSEClientTransport(serverUrl);
  } else {
    throw new Error(`Unsupported transport type: ${options.transport.type}`);
  }

  // Create the client
  const client = new Client(clientInfo, { capabilities });

  // Connect to the server
  await client.connect(transport);

  return client;
}

// Example usage:
/*
// Connect to a stdio-based server
const stdioClient = await createMcpClient({
  clientInfo: {
    name: "my-agent",
    version: "1.0.0",
  },
  transport: {
    type: "stdio",
    command: "node",
    args: ["server.js"],
  },
  capabilities: {
    prompts: {},
    resources: {},
    tools: {},
  },
});

// Connect to an SSE-based server
const sseClient = await createMcpClient({
  transport: {
    type: "sse",
    serverUrl: "http://localhost:3001",
  },
});

// List prompts
const prompts = await client.listPrompts();

// Get a prompt
const prompt = await client.getPrompt({
  name: "example-prompt",
  arguments: {
    arg1: "value",
  },
});

// List resources
const resources = await client.listResources();

// Read a resource
const resource = await client.readResource({
  uri: "file:///example.txt",
});

// Call a tool
const result = await client.callTool({
  name: "example-tool",
  arguments: {
    arg1: "value",
  },
});
*/

--- End File: packages/mcp/src/client.ts ---

--- File: packages/mcp/src/extension.ts ---
import { z } from "zod";
import { createMcpClient } from "./client";
import {
  Logger,
  action,
  extension,
  type ActionCallContext,
  type Context,
} from "@daydreamsai/core";
import { Client } from "@modelcontextprotocol/sdk/client/index.js";

export interface McpServerConfig {
  id: string;
  name: string;
  transport: {
    type: "stdio" | "sse";
    // For stdio transport
    command?: string;
    args?: string[];
    // For SSE transport
    serverUrl?: string;
    sseEndpoint?: string;
    messageEndpoint?: string;
  };
  capabilities?: {
    prompts?: Record<string, unknown>;
    resources?: Record<string, unknown>;
    tools?: Record<string, unknown>;
  };
}

/**
 * Creates an extension that connects to one or more MCP servers
 * and exposes their capabilities as actions within the agent system.
 *
 * @param servers Configuration for one or more MCP servers to connect to
 * @returns An extension that can be added to the agent's extensions list
 */
export function createMcpExtension(servers: McpServerConfig[]) {
  const clients = new Map<string, Client>();

  return extension({
    name: "mcp",

    // Initialize MCP clients when the extension is installed
    async install(agent) {
      const logger = agent.container.resolve<Logger>("logger");

      logger.info("mcp:extension", "Installing MCP extension", {
        serversCount: servers.length,
      });

      // Connect to each configured MCP server
      for (const server of servers) {
        logger.debug("mcp:extension", "Connecting to MCP server", {
          id: server.id,
          name: server.name,
          transportType: server.transport.type,
        });

        try {
          const client = await createMcpClient({
            clientInfo: {
              name: `daydreams-mcp-client`,
              version: "1.0.0",
            },
            transport: server.transport,
            capabilities: server.capabilities,
          });

          clients.set(server.id, client);
          logger.info("mcp:extension", "Connected to MCP server", {
            id: server.id,
            name: server.name,
          });
        } catch (error) {
          logger.error("mcp:extension", "Failed to connect to MCP server", {
            id: server.id,
            name: server.name,
            error,
          });
        }
      }
    },

    // Define actions for interacting with MCP servers
    actions: [
      action({
        name: "mcp.listServers",
        description: "List all MCP servers",
        handler() {
          const serverList = servers.map((server) => ({
            id: server.id,
            name: server.name,
            connected: clients.has(server.id),
            transportType: server.transport.type,
          }));

          return { servers: serverList };
        },
      }),

      // Action to list available tools from a specific MCP server
      action({
        name: "mcp.listTools",
        description: "List available tools from an MCP server",
        schema: {
          serverId: z.string().describe("ID of the MCP server to query"),
        },
        async handler({ serverId }, ctx, agent) {
          const client = clients.get(serverId);
          if (!client) {
            return {
              error: `MCP server with ID '${serverId}' not found`,
            };
          }
          const tools = await client.listTools();
          return { tools };
        },
      }),
      // Action to list available prompts from a specific MCP server
      action({
        name: "mcp.listPrompts",
        description: "List available prompts from an MCP server",
        schema: {
          serverId: z.string().describe("ID of the MCP server to query"),
        },
        async handler({ serverId }, ctx) {
          const client = clients.get(serverId);
          if (!client) {
            return {
              error: `MCP server with ID '${serverId}' not found`,
            };
          }

          const prompts = await client.listPrompts();
          return { prompts };
        },
      }),

      // Action to get a prompt from a specific MCP server
      action({
        name: "mcp.getPrompt",
        description: "Get a prompt from an MCP server",
        schema: {
          serverId: z.string().describe("ID of the MCP server to query"),
          name: z.string().describe("Name of the prompt to get"),
          arguments: z
            .record(z.any())
            .optional()
            .describe("Arguments for the prompt"),
        },
        async handler({ serverId, name, arguments: args }, ctx, agent) {
          const client = clients.get(serverId);
          if (!client) {
            return {
              error: `MCP server with ID '${serverId}' not found`,
            };
          }

          const prompt = await client.getPrompt({
            name,
            arguments: args || {},
          });
          return { prompt };
        },
      }),

      // Action to list available resources from a specific MCP server
      action({
        name: "mcp.listResources",
        description: "List available resources from an MCP server",
        schema: {
          serverId: z.string().describe("ID of the MCP server to query"),
        },
        async handler({ serverId }, ctx) {
          const client = clients.get(serverId);
          if (!client) {
            return {
              error: `MCP server with ID '${serverId}' not found`,
            };
          }

          const resources = await client.listResources();
          return { resources };
        },
      }),

      // Action to read a resource from a specific MCP server
      action({
        name: "mcp.readResource",
        description: "Read a resource from an MCP server",
        schema: {
          serverId: z.string().describe("ID of the MCP server to query"),
          uri: z.string().describe("URI of the resource to read"),
        },
        async handler({ serverId, uri }, ctx) {
          const client = clients.get(serverId);
          if (!client) {
            return {
              error: `MCP server with ID '${serverId}' not found`,
            };
          }

          const resource = await client.readResource({
            uri,
          });

          return { resource };
        },
      }),

      // Action to call a tool on a specific MCP server
      action({
        name: "mcp.callTool",
        description: "Call a tool on an MCP server",
        schema: {
          serverId: z.string().describe("ID of the MCP server to query"),
          name: z.string().describe("Name of the tool to call"),
          arguments: z
            .record(z.any())
            .optional()
            .describe("Arguments for the tool"),
        },
        async handler({ serverId, name, arguments: args }) {
          const client = clients.get(serverId);
          if (!client) {
            return {
              error: `MCP server with ID '${serverId}' not found`,
            };
          }

          const result = await client.callTool({
            name,
            arguments: args,
          });

          return { result };
        },
      }),
    ],
  });
}

--- End File: packages/mcp/src/extension.ts ---

--- File: packages/mcp/src/index.ts ---
export { createMcpClient } from "./client";
export { createMcpExtension } from "./extension";

--- End File: packages/mcp/src/index.ts ---

--- File: packages/mongo/package.json ---
{
  "name": "@daydreamsai/mongodb",
  "version": "0.3.6",
  "type": "module",
  "main": "./dist/index.js",
  "module": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "exports": {
    "./package.json": "./package.json",
    ".": {
      "types": "./dist/index.d.ts",
      "require": "./dist/index.js",
      "import": "./dist/index.js"
    }
  },
  "devDependencies": {
    "@types/bun": "latest",
    "tsup": "^8.3.6",
    "vitest": "^3.0.5"
  },
  "scripts": {
    "test": "vitest",
    "build": "tsup --dts-resolve"
  },
  "dependencies": {
    "@daydreamsai/core": "workspace:*",
    "crypto": "^1.0.1",
    "mongodb": "^6.14.2",
    "zod": "^3.24.2"
  }
}

--- End File: packages/mongo/package.json ---

--- File: packages/mongo/src/index.ts ---
export * from "./mongo";

--- End File: packages/mongo/src/index.ts ---

--- File: packages/mongo/src/mongo.ts ---
import { Collection, MongoClient } from "mongodb";
import type { MemoryStore } from "@daydreamsai/core";
import crypto from "crypto";

export interface MongoMemoryOptions {
  uri: string;
  dbName?: string;
  collectionName?: string;
}

interface MemoryDocument {
  _id: string;
  value: any;
}

export class MongoMemoryStore implements MemoryStore {
  private client: MongoClient;
  private collection: Collection<MemoryDocument> | null = null;
  private readonly dbName: string;
  private readonly collectionName: string;

  constructor(options: MongoMemoryOptions) {
    this.client = new MongoClient(options.uri);
    this.dbName = options.dbName || "dreams_memory";
    this.collectionName = options.collectionName || "conversations";
  }

  private _hashKey(key: string): string {
    return crypto.createHash("sha256").update(key).digest("hex");
  }

  /**
   * Initialize the MongoDB connection
   */
  async initialize(): Promise<void> {
    await this.client.connect();
    const db = this.client.db(this.dbName);
    this.collection = db.collection<MemoryDocument>(this.collectionName);
  }

  /**
   * Retrieves a value from the store
   * @param key - Key to look up
   * @returns The stored value or null if not found
   */
  async get<T>(key: string): Promise<T | null> {
    if (!this.collection) throw new Error("MongoDB not initialized");

    console.log("getting", key);
    const hashedKey = this._hashKey(key);

    const doc = await this.collection.findOne({ _id: hashedKey });
    if (!doc) return null;

    return doc.value as T;
  }

  /**
   * Stores a value in the store
   * @param key - Key to store under
   * @param value - Value to store
   */
  async set(key: string, value: any): Promise<void> {
    if (!this.collection) throw new Error("MongoDB not initialized");

    console.log("setting", key, value);
    const hashedKey = this._hashKey(key);

    await this.collection.updateOne(
      { _id: hashedKey },
      { $set: { value } },
      { upsert: true }
    );
  }

  /**
   * Removes a specific entry from the store
   * @param key - Key to remove
   */
  async delete(key: string): Promise<void> {
    if (!this.collection) throw new Error("MongoDB not initialized");

    const hashedKey = this._hashKey(key);
    await this.collection.deleteOne({ _id: hashedKey });
  }

  /**
   * Removes all entries from the store
   */
  async clear(): Promise<void> {
    if (!this.collection) throw new Error("MongoDB not initialized");

    await this.collection.deleteMany({});
  }

  /**
   * Close the MongoDB connection
   */
  async close(): Promise<void> {
    await this.client.close();
  }

  async keys() {
    return [];
  }

  // async keys(base?: string) {
  //   if (!this.collection) throw new Error("MongoDB not initialized");

  //   const keys = await this.collection
  //     .find()
  //     .project<{ key: string }>({ key: true })
  //     .map((d) => d.key)
  //     .toArray();

  //   if (base) {
  //     return keys.filter((key) => key.startsWith(base));
  //   }

  //   return keys;
  // }
}

/**
 * Creates a new MongoDB-backed memory store
 * @param options - MongoDB connection options
 * @returns A MemoryStore implementation using MongoDB for storage
 */
export async function createMongoMemoryStore(
  options: MongoMemoryOptions
): Promise<MemoryStore> {
  const store = new MongoMemoryStore(options);
  await store.initialize();
  return store;
}

--- End File: packages/mongo/src/mongo.ts ---

--- File: packages/supabase/README.md ---
# @daydreamsai/supabase

A Supabase integration package for the DaydreamsAI platform, providing vector
storage with pgvector and memory storage capabilities.

## Features

- Store and retrieve vector embeddings in Supabase using pgvector
- Perform similarity searches with customizable thresholds and filters
- Persistent memory storage for conversation data
- Fully typed API with Zod schema validation
- Implements core DaydreamsAI interfaces for seamless integration

## Installation

```bash
npm install @daydreamsai/supabase
# or
yarn add @daydreamsai/supabase
# or
pnpm add @daydreamsai/supabase
```

--- End File: packages/supabase/README.md ---

--- File: packages/supabase/package.json ---
{
  "name": "@daydreamsai/supabase",
  "version": "0.3.6",
  "type": "module",
  "main": "dist/index.js",
  "module": "dist/index.js",
  "types": "dist/index.d.ts",
  "exports": {
    "./package.json": "./package.json",
    ".": {
      "types": "./dist/index.d.ts",
      "import": {
        "development": "./src/index.ts",
        "default": "./dist/index.js"
      }
    }
  },
  "devDependencies": {
    "@types/bun": "latest",
    "tsup": "^8.3.6",
    "vitest": "^3.0.5"
  },
  "scripts": {
    "test": "vitest",
    "build": "tsup --dts-resolve"
  },
  "dependencies": {
    "@daydreamsai/core": "workspace:*",
    "@supabase/supabase-js": "^2.49.1",
    "ai": "^4.1.54",
    "zod": "^3.24.2"
  }
}

--- End File: packages/supabase/package.json ---

--- File: packages/supabase/sql/setup.sql ---
-- Enable the pgvector extension
CREATE EXTENSION IF NOT EXISTS vector;

-- Function to enable pgvector extension (used by the SupabaseVectorStore)
CREATE OR REPLACE FUNCTION enable_pgvector_extension()
RETURNS void
LANGUAGE plpgsql
AS $$
BEGIN
  CREATE EXTENSION IF NOT EXISTS vector;
END;
$$;

-- Function to execute arbitrary SQL (used by the SupabaseVectorStore for initialization)
CREATE OR REPLACE FUNCTION execute_sql(query text)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  EXECUTE query;
END;
$$;

-- -- Example table creation (this is done programmatically in the SupabaseVectorStore)
-- CREATE TABLE IF NOT EXISTS embeddings (
--   key TEXT PRIMARY KEY,
--   content TEXT,
--   embedding VECTOR(1536),
--   metadata JSONB
-- );

-- -- Example similarity search function (this is created programmatically in the SupabaseVectorStore)
-- CREATE OR REPLACE FUNCTION match_embeddings(
--   query_embedding VECTOR(1536),
--   match_threshold FLOAT,
--   match_count INT,
--   filter_metadata JSONB DEFAULT NULL,
--   filter_keys TEXT[] DEFAULT NULL
-- ) 
-- RETURNS TABLE (
--   key TEXT,
--   content TEXT,
--   metadata JSONB,
--   similarity FLOAT
-- )
-- LANGUAGE plpgsql
-- AS $$
-- BEGIN
--   RETURN QUERY
--   SELECT
--     t.key,
--     t.content,
--     t.metadata,
--     1 - (t.embedding <=> query_embedding) as similarity
--   FROM embeddings t
--   WHERE
--     (filter_metadata IS NULL OR t.metadata @> filter_metadata) AND
--     (filter_keys IS NULL OR t.key = ANY(filter_keys)) AND
--     1 - (t.embedding <=> query_embedding) > match_threshold
--   ORDER BY similarity DESC
--   LIMIT match_count;
-- END;
-- $$; 
--- End File: packages/supabase/sql/setup.sql ---

--- File: packages/supabase/src/index.ts ---
export * from "./schema";
export * from "./types";
export * from "./supabase";
export * from "./vector-store";
export * from "./memory-store";
export * from "./memory";

--- End File: packages/supabase/src/index.ts ---

--- File: packages/supabase/src/memory-store.ts ---
import type { MemoryStore } from "@daydreamsai/core";
import { createClient, SupabaseClient } from "@supabase/supabase-js";
import crypto from "crypto";

export function _hashKey(key: string): string {
  return crypto.createHash("sha256").update(key).digest("hex");
}

/**
 * Configuration for the Supabase memory store
 */
export interface SupabaseMemoryStoreConfig {
  /** Supabase URL */
  url: string;
  /** Supabase API key */
  key: string;
  /** Table name for storing memory data */
  tableName?: string;
}

/**
 * Creates a Supabase-backed implementation of the MemoryStore interface
 *
 * @param config - Configuration for the Supabase memory store
 * @returns A MemoryStore implementation using Supabase
 */
export function createSupabaseMemoryStore(
  config: SupabaseMemoryStoreConfig
): MemoryStore {
  const { url, key, tableName = "memory" } = config;

  // Create Supabase client
  const client = createClient(url, key);

  // Initialize the table if it doesn't exist
  initializeTable(client, tableName).catch(console.error);

  return {
    /**
     * Retrieves data from the Supabase memory store
     * @param key - Key to look up
     * @returns The stored value or null if not found
     */
    async get<T>(key: string): Promise<T | null> {
      const hashedKey = _hashKey(key);
      const { data, error } = await client
        .from(tableName)
        .select("value")
        .eq("key", hashedKey)
        .single();

      if (error || !data) {
        return null;
      }

      try {
        return JSON.parse(data.value) as T;
      } catch (e) {
        console.error(`Error parsing data for key ${key}:`, e);
        return null;
      }
    },

    /**
     * Stores data in the Supabase memory store
     * @param key - Key to store under
     * @param value - Value to store
     */
    async set<T>(key: string, value: T): Promise<void> {
      const hashedKey = _hashKey(key);
      const serializedValue = JSON.stringify(value);

      const { error } = await client
        .from(tableName)
        .upsert({
          key: hashedKey,
          value: serializedValue,
          updated_at: new Date().toISOString(),
        })
        .select();

      if (error) {
        throw new Error(`Failed to set value for key ${key}: ${error.message}`);
      }
    },

    /**
     * Retrieves all keys from the Supabase memory store.
     * Note: Returns hashed keys, not the original keys.
     * @returns An array of all stored (hashed) keys
     */
    async keys(): Promise<string[]> {
      const { data, error } = await client.from(tableName).select("key");

      if (error) {
        throw new Error(`Failed to retrieve keys: ${error.message}`);
      }

      return data ? data.map((row: { key: string }) => row.key) : [];
    },

    /**
     * Removes a specific entry from the Supabase memory store
     * @param key - Key to remove
     */
    async delete(key: string): Promise<void> {
      const hashedKey = _hashKey(key);
      const { error } = await client
        .from(tableName)
        .delete()
        .eq("key", hashedKey);

      if (error) {
        throw new Error(`Failed to delete key ${key}: ${error.message}`);
      }
    },

    /**
     * Removes all entries from the Supabase memory store
     */
    async clear(): Promise<void> {
      const { error } = await client.from(tableName).delete().neq("key", "");

      if (error) {
        throw new Error(`Failed to clear memory store: ${error.message}`);
      }
    },
  };
}

/**
 * Initialize the memory table in Supabase
 *
 * @param client - Supabase client
 * @param tableName - Name of the table to create
 */
async function initializeTable(
  client: SupabaseClient,
  tableName: string
): Promise<void> {
  // Check if the table exists by querying it
  const { error } = await client.from(tableName).select("key").limit(1);

  // If the table doesn't exist, create it
  if (error && error.code === "42P01") {
    // PostgreSQL code for undefined_table
    // We need to use raw SQL to create the table
    // This requires the execute_sql function to be available in the database
    const createTableQuery = `
      CREATE TABLE IF NOT EXISTS ${tableName} (
        key TEXT PRIMARY KEY,
        value TEXT NOT NULL,
        created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
        updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
      );
    `;

    try {
      const result = await client.rpc("execute_sql", {
        query: createTableQuery,
      });
      console.log(`Created memory table: ${tableName}`);
      console.log("result", result);
    } catch (e) {
      console.error(`Failed to create memory table ${tableName}:`, e);
      throw e;
    }
  } else if (error) {
    console.error(`Error checking memory table ${tableName}:`, error);
  }
}

/**
 * Factory function to create a MemoryStore implementation using Supabase
 *
 * @param url - Supabase URL
 * @param key - Supabase API key
 * @param tableName - Name of the table to store memory data
 * @returns A MemoryStore implementation
 */
export function createSupabaseMemory(
  url: string,
  key: string,
  tableName: string = "memory"
): MemoryStore {
  return createSupabaseMemoryStore({
    url,
    key,
    tableName,
  });
}

--- End File: packages/supabase/src/memory-store.ts ---

--- File: packages/supabase/src/memory.ts ---
import type { BaseMemory } from "@daydreamsai/core";
import type { LanguageModelV1 } from "ai";
import { createSupabaseMemoryStore } from "./memory-store";
import { createSupabaseVectorStore } from "./vector-store";
import type { TextEmbeddingModel } from "./vector-store";

/**
 * Configuration for creating a Supabase-backed memory system
 */
export interface SupabaseMemoryConfig {
  /** Supabase URL */
  url: string;
  /** Supabase API key */
  key: string;
  /** Table name for storing memory data */
  memoryTableName?: string;
  /** Table name for storing vector embeddings */
  vectorTableName?: string;
  /** Optional embedding model for generating vector embeddings */
  vectorModel?: TextEmbeddingModel | LanguageModelV1;
}

/**
 * Adapts a TextEmbeddingModel to the LanguageModelV1 interface expected by BaseMemory
 * This is a compatibility layer to make our TextEmbeddingModel work with the core package
 * @param embeddingModel - The TextEmbeddingModel to adapt
 * @returns A LanguageModelV1 compatible object that delegates to the TextEmbeddingModel
 */
function adaptEmbeddingModel(
  embeddingModel: TextEmbeddingModel
): LanguageModelV1 {
  return {
    specificationVersion: "v1",
    provider: embeddingModel.provider,
    modelId: embeddingModel.modelId,
    defaultObjectGenerationMode: undefined,

    // These methods are required by LanguageModelV1 but not used for embeddings
    doGenerate: async () => {
      throw new Error("Not implemented - this adapter is for embeddings only");
    },

    doStream: async () => {
      throw new Error("Not implemented - this adapter is for embeddings only");
    },
  };
}

/**
 * Creates a complete memory system backed by Supabase
 *
 * This includes both a MemoryStore for conversation data and a VectorStore for embeddings.
 *
 * @param config - Configuration for the Supabase memory system
 * @returns A BaseMemory implementation using Supabase
 */
export function createSupabaseBaseMemory(
  config: SupabaseMemoryConfig
): BaseMemory {
  const {
    url,
    key,
    memoryTableName = "memory",
    vectorTableName = "embeddings",
    vectorModel,
  } = config;

  // Create the memory store
  const store = createSupabaseMemoryStore({
    url,
    key,
    tableName: memoryTableName,
  });

  // Determine if the provided model is a TextEmbeddingModel or LanguageModelV1
  const isTextEmbeddingModel =
    vectorModel &&
    "generateEmbeddings" in vectorModel &&
    typeof vectorModel.generateEmbeddings === "function";

  // Create the vector store with the appropriate embedding model
  const vector = createSupabaseVectorStore(
    {
      url,
      key,
      tableName: vectorTableName,
      embeddingColumnName: "embedding",
      contentColumnName: "content",
      metadataColumnName: "metadata",
    },
    isTextEmbeddingModel ? (vectorModel as TextEmbeddingModel) : undefined
  );

  // Return the complete memory system with the appropriate vectorModel
  return {
    store,
    vector,
    // Adapt TextEmbeddingModel to LanguageModelV1 if needed
    vectorModel: isTextEmbeddingModel
      ? adaptEmbeddingModel(vectorModel as TextEmbeddingModel)
      : (vectorModel as LanguageModelV1 | undefined),
  };
}

--- End File: packages/supabase/src/memory.ts ---

--- File: packages/supabase/src/schema.ts ---
import { z } from "zod";

export const SupabaseVectorStoreSchema = z.object({
  url: z.string().url(),
  key: z.string(),
  tableName: z.string(),
  queryName: z.string().optional(),
  embeddingColumnName: z.string().default("embedding"),
  contentColumnName: z.string().default("content"),
  metadataColumnName: z.string().default("metadata"),
});

export const SupabaseVectorRecordSchema = z.object({
  key: z.string(),
  content: z.string(),
  embedding: z.array(z.number()),
  metadata: z.record(z.any()).optional(),
});

export const SupabaseVectorFilterSchema = z.object({
  metadata: z.record(z.any()).optional(),
  keys: z.array(z.string()).optional(),
});

export const SupabaseSearchResultSchema = z.object({
  key: z.string(),
  content: z.string(),
  metadata: z.record(z.any()).optional(),
  similarity: z.number().optional(),
});

--- End File: packages/supabase/src/schema.ts ---

--- File: packages/supabase/src/supabase.ts ---
import { createClient, SupabaseClient } from "@supabase/supabase-js";

import type {
  SupabaseVectorStoreConfig,
  SupabaseVectorRecord,
  SupabaseVectorFilter,
  SupabaseSearchResult,
  SupabaseVectorStoreOptions,
} from "./types";
import { SupabaseVectorStoreSchema } from "./schema";

/**
 * SupabaseVectorStore - A vector store implementation using Supabase with pgvector
 *
 * This class provides methods to store, retrieve, and search vector embeddings in a Supabase database
 * using the pgvector extension.
 */
export class SupabaseVectorStore {
  private client: SupabaseClient;
  private tableName: string;
  private queryName: string;
  private embeddingColumnName: string;
  private contentColumnName: string;
  private metadataColumnName: string;

  /**
   * Create a new SupabaseVectorStore instance
   *
   * @param options - Configuration options for the vector store
   */
  constructor(options: SupabaseVectorStoreOptions) {
    this.client = options.client;
    this.tableName = options.tableName.toLowerCase();
    this.queryName =
      options.queryName || `match_${this.tableName.toLowerCase()}`;
    this.embeddingColumnName = options.embeddingColumnName || "embedding";
    this.contentColumnName = options.contentColumnName || "content";
    this.metadataColumnName = options.metadataColumnName || "metadata";
  }

  /**
   * Create a new SupabaseVectorStore from configuration
   *
   * @param config - Configuration for the Supabase vector store
   * @returns A new SupabaseVectorStore instance
   */
  static fromConfig(config: SupabaseVectorStoreConfig): SupabaseVectorStore {
    const validatedConfig = SupabaseVectorStoreSchema.parse(config);

    const client = createClient(validatedConfig.url, validatedConfig.key);

    return new SupabaseVectorStore({
      client,
      tableName: validatedConfig.tableName,
      queryName: validatedConfig.queryName,
      embeddingColumnName: validatedConfig.embeddingColumnName,
      contentColumnName: validatedConfig.contentColumnName,
      metadataColumnName: validatedConfig.metadataColumnName,
    });
  }

  /**
   * Initialize the database schema for vector storage
   *
   * This method creates the necessary tables and functions for vector storage and similarity search
   *
   * @param dimensions - The dimensions of the vectors to be stored (default: 1536)
   * @returns A promise that resolves when the initialization is complete
   */
  async initialize(dimensions: number = 1536): Promise<void> {
    try {
      // Enable the pgvector extension
      const result = await this.client.rpc("enable_pgvector_extension");
      console.log("SupabaseVectorStore initialized", result);

      // Create the table if it doesn't exist
      const createTableQuery = `
        CREATE TABLE IF NOT EXISTS ${this.tableName} (
          key TEXT PRIMARY KEY,
          ${this.contentColumnName} TEXT,
          ${this.embeddingColumnName} VECTOR(${dimensions}),
          ${this.metadataColumnName} JSONB
        );
      `;
      const result2 = await this.client.rpc("execute_sql", {
        query: createTableQuery,
      });
      console.log("SupabaseVectorStore table created", result2);

      // Create the similarity search function
      const createFunctionQuery = `
        CREATE OR REPLACE FUNCTION ${this.queryName}(
          query_embedding VECTOR(${dimensions}),
          match_threshold FLOAT,
          match_count INT,
          filter_metadata JSONB DEFAULT NULL,
          filter_keys TEXT[] DEFAULT NULL
        ) 
        RETURNS TABLE (
          key TEXT,
          ${this.contentColumnName} TEXT,
          ${this.metadataColumnName} JSONB,
          similarity FLOAT
        )
        LANGUAGE plpgsql
        AS $$
        BEGIN
          RETURN QUERY
          SELECT
            t.key,
            t.${this.contentColumnName},
            t.${this.metadataColumnName},
            1 - (t.${this.embeddingColumnName} <=> query_embedding) as similarity
          FROM ${this.tableName} t
          WHERE
            (filter_metadata IS NULL OR t.${this.metadataColumnName} @> filter_metadata) AND
            (filter_keys IS NULL OR t.key = ANY(filter_keys)) AND
            1 - (t.${this.embeddingColumnName} <=> query_embedding) > match_threshold
          ORDER BY similarity DESC
          LIMIT match_count;
        END;
        $$;
      `;
      const result3 = await this.client.rpc("execute_sql", {
        query: createFunctionQuery,
      });
      console.log("SupabaseVectorStore function created", result3);
    } catch (error) {
      console.error("Error initializing SupabaseVectorStore:", error);
      throw error instanceof Error
        ? error
        : new Error("Unknown error during vector store initialization");
    }
  }

  /**
   * Add vector records to the store
   *
   * @param records - The vector records to add
   * @returns A promise that resolves when the records are added
   */
  async addVectors(records: SupabaseVectorRecord[]): Promise<void> {
    if (records.length === 0) return;

    const rows = records.map((record) => ({
      key: record.key,
      [this.contentColumnName]: record.content,
      [this.embeddingColumnName]: record.embedding,
      [this.metadataColumnName]: record.metadata || {},
    }));

    const { error } = await this.client.from(this.tableName).upsert(rows);

    if (error) {
      throw new Error(`Failed to add vectors: ${error.message}`);
    }
  }

  /**
   * Delete vector records from the store
   *
   * @param keys - The keys of the records to delete
   * @returns A promise that resolves when the records are deleted
   */
  async deleteVectors(keys: string[]): Promise<void> {
    if (keys.length === 0) return;

    const { error } = await this.client
      .from(this.tableName)
      .delete()
      .in("key", keys);

    if (error) {
      throw new Error(`Failed to delete vectors: ${error.message}`);
    }
  }

  /**
   * Search for similar vectors
   *
   * @param embedding - The query embedding vector
   * @param options - Search options
   * @returns A promise that resolves to the search results
   */
  async similaritySearch(
    embedding: number[],
    {
      filter = {},
      matchThreshold = 0.5,
      maxResults = 10,
    }: {
      filter?: SupabaseVectorFilter;
      matchThreshold?: number;
      maxResults?: number;
    } = {}
  ): Promise<SupabaseSearchResult[]> {
    const { data, error } = await this.client.rpc(this.queryName, {
      query_embedding: embedding,
      match_threshold: matchThreshold,
      match_count: maxResults,
      filter_metadata: filter.metadata || null,
      filter_keys: filter.keys || null,
    });

    if (error) {
      throw new Error(`Failed to search vectors: ${error.message}`);
    }

    return data.map((item: Record<string, any>) => ({
      key: item.key,
      content: item[this.contentColumnName],
      metadata: item[this.metadataColumnName],
      similarity: item.similarity,
    }));
  }

  /**
   * Get vector records by IDs
   *
   * @param ids - The IDs of the records to retrieve
   * @returns A promise that resolves to the retrieved records
   */
  async getVectorsByIds(ids: string[]): Promise<SupabaseVectorRecord[]> {
    if (ids.length === 0) return [];

    const { data, error } = await this.client
      .from(this.tableName)
      .select(
        `key, ${this.contentColumnName}, ${this.embeddingColumnName}, ${this.metadataColumnName}`
      )
      .in("key", ids);

    if (error) {
      throw new Error(`Failed to get vectors: ${error.message}`);
    }

    return data.map((item: Record<string, any>) => ({
      key: item.key,
      content: item[this.contentColumnName],
      embedding: item[this.embeddingColumnName],
      metadata: item[this.metadataColumnName],
    }));
  }
}

--- End File: packages/supabase/src/supabase.ts ---

--- File: packages/supabase/src/types.ts ---
import { type SupabaseClient } from "@supabase/supabase-js";
import { z } from "zod";
import type { SupabaseVectorStoreSchema } from "./schema";

export type SupabaseVectorStoreConfig = z.infer<
  typeof SupabaseVectorStoreSchema
>;

export interface SupabaseVectorRecord {
  key: string;
  content: string;
  embedding: number[];
  metadata?: Record<string, any>;
}

export interface SupabaseVectorFilter {
  metadata?: Record<string, any>;
  keys?: string[];
}

export interface SupabaseVectorStoreOptions {
  client: SupabaseClient;
  tableName: string;
  queryName?: string;
  embeddingColumnName?: string;
  contentColumnName?: string;
  metadataColumnName?: string;
}

export interface SupabaseSearchResult {
  key: string;
  content: string;
  metadata?: Record<string, any>;
  similarity?: number;
}

--- End File: packages/supabase/src/types.ts ---

--- File: packages/supabase/src/vector-store.ts ---
import { type VectorStore } from "@daydreamsai/core";
import { SupabaseVectorStore } from "./supabase";
import type { SupabaseVectorStoreConfig } from "./types";

/**
 * Interface for text embedding models
 */
export interface TextEmbeddingModel {
  /**
   * Provider name for the embedding model
   */
  provider: string;

  /**
   * Model ID for the embedding model
   */
  modelId: string;

  /**
   * Generates embeddings for an array of text strings
   * @param texts - Array of text strings to embed
   * @returns Promise resolving to a 2D array of embeddings
   */
  generateEmbeddings(texts: string[]): Promise<number[][]>;
}

/**
 * Creates a default OpenAI embedding provider
 * @param apiKey - OpenAI API key (defaults to process.env.OPENAI_API_KEY)
 * @param model - OpenAI embedding model to use (defaults to text-embedding-3-small)
 * @returns A TextEmbeddingModel implementation for generating embeddings
 */
export function createOpenAIEmbeddingProvider(
  apiKey: string = process.env.OPENAI_API_KEY || "",
  model: string = "text-embedding-3-small"
): TextEmbeddingModel {
  return {
    provider: "openai",
    modelId: model,

    async generateEmbeddings(texts: string[]): Promise<number[][]> {
      if (!apiKey) {
        throw new Error("OpenAI API key is required for embedding generation");
      }

      try {
        // Use fetch directly to avoid requiring the OpenAI SDK as a dependency
        const response = await fetch("https://api.openai.com/v1/embeddings", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${apiKey}`,
          },
          body: JSON.stringify({
            model,
            input: texts,
          }),
        });

        if (!response.ok) {
          const error = await response.json();
          throw new Error(`OpenAI API error: ${JSON.stringify(error)}`);
        }

        const data = await response.json();
        return data.data.map((item: any) => item.embedding);
      } catch (error) {
        console.error("Error generating embeddings:", error);
        throw error;
      }
    },
  };
}

/**
 * Creates a Supabase vector store that implements the core VectorStore interface
 *
 * @param config - Configuration for the Supabase vector store
 * @param embeddingProvider - Optional embedding provider (defaults to OpenAI if API key is available)
 * @returns A VectorStore implementation using Supabase with pgvector
 */
export function createSupabaseVectorStore(
  config: SupabaseVectorStoreConfig,
  embeddingProvider?: TextEmbeddingModel
): VectorStore {
  // Create the underlying SupabaseVectorStore
  const supabaseStore = SupabaseVectorStore.fromConfig(config);

  // Initialize the store with default dimensions
  // This is done asynchronously, but we don't await it here
  // to match the synchronous nature of the factory function
  supabaseStore.initialize().catch(console.error);

  // Use provided embedding provider or create a default one if OpenAI API key is available
  const embedder =
    embeddingProvider ||
    (process.env.OPENAI_API_KEY ? createOpenAIEmbeddingProvider() : undefined);

  return {
    connection: config.url,

    /**
     * Adds or updates data in the vector store
     * @param contextId - Unique identifier for the context
     * @param data - Data to add or update
     */
    async upsert(contextId: string, data: any[]): Promise<void> {
      // Generate embeddings if needed and if we have an embedding provider
      let dataWithEmbeddings = [...data];

      if (embedder) {
        const itemsNeedingEmbeddings = data.filter(
          (item) =>
            !item.embedding ||
            !Array.isArray(item.embedding) ||
            item.embedding.length === 0
        );

        if (itemsNeedingEmbeddings.length > 0) {
          const textsToEmbed = itemsNeedingEmbeddings.map(
            (item) => item.content || item.text || JSON.stringify(item)
          );
          const embeddings = await embedder.generateEmbeddings(textsToEmbed);

          // Update items with their embeddings
          let embeddingIndex = 0;
          dataWithEmbeddings = data.map((item) => {
            if (
              !item.embedding ||
              !Array.isArray(item.embedding) ||
              item.embedding.length === 0
            ) {
              return {
                ...item,
                embedding: embeddings[embeddingIndex++],
              };
            }
            return item;
          });
        }
      }

      // Convert the data to the format expected by SupabaseVectorStore
      const records = dataWithEmbeddings.map((item, index) => {
        // If the item already has an embedding, use it
        const embedding = item.embedding || [];

        return {
          key: item.key || `${contextId}-${index}`,
          content: item.content || item.text || JSON.stringify(item),
          embedding: embedding,
          metadata: {
            contextId,
            ...item.metadata,
          },
        };
      });

      await supabaseStore.addVectors(records);
    },

    /**
     * Searches the vector store for similar data
     * @param contextId - Context to search within
     * @param query - Query text to search for or query object with embedding
     * @returns Array of matching documents
     */
    async query(contextId: string, query: any): Promise<any[]> {
      // This implementation assumes that embeddings are generated elsewhere
      // and passed in the query parameter as an object with an embedding property
      const queryObj = typeof query === "string" ? { text: query } : query;

      // If we have an embedding in the query object, use it for similarity search
      if (queryObj.embedding && Array.isArray(queryObj.embedding)) {
        const results = await supabaseStore.similaritySearch(
          queryObj.embedding,
          {
            filter: {
              metadata: { contextId },
            },
            matchThreshold: queryObj.threshold || 0.5,
            maxResults: queryObj.limit || 10,
          }
        );

        return results.map((result) => ({
          ...result,
          text: result.content,
          score: result.similarity,
        }));
      }

      // If no embedding is provided but we have an embedding provider, generate one
      if (embedder && queryObj.text) {
        try {
          const [embedding] = await embedder.generateEmbeddings([
            queryObj.text,
          ]);

          const results = await supabaseStore.similaritySearch(embedding, {
            filter: {
              metadata: { contextId },
            },
            matchThreshold: queryObj.threshold || 0.5,
            maxResults: queryObj.limit || 10,
          });

          return results.map((result) => ({
            ...result,
            text: result.content,
            score: result.similarity,
          }));
        } catch (error) {
          console.error("Error generating query embedding:", error);
          return [];
        }
      }

      // If no embedding is provided and we can't generate one, return empty results
      console.warn(
        "No embedding provided for query and no embedding provider available. Returning empty results."
      );
      return [];
    },

    /**
     * Creates a new index in the vector store
     * @param indexName - Name of the index to create
     */
    async createIndex(indexName: string): Promise<void> {
      // In Supabase with pgvector, indexes are created at the database level
      // This is a no-op for now, but could be implemented to create specific indexes
      console.log(
        `Creating index ${indexName} (no-op in Supabase implementation)`
      );
    },

    /**
     * Deletes an existing index from the vector store
     * @param indexName - Name of the index to delete
     */
    async deleteIndex(indexName: string): Promise<void> {
      // In Supabase with pgvector, indexes are managed at the database level
      // This is a no-op for now, but could be implemented to drop specific indexes
      console.log(
        `Deleting index ${indexName} (no-op in Supabase implementation)`
      );
    },
  };
}

/**
 * Factory function to create a VectorStore implementation using Supabase
 *
 * @param url - Supabase URL
 * @param key - Supabase API key
 * @param tableName - Name of the table to store vectors
 * @param embeddingProvider - Optional embedding provider (defaults to OpenAI if API key is available)
 * @returns A VectorStore implementation
 */
export function createSupabaseStore(
  url: string,
  key: string,
  tableName: string = "embeddings",
  embeddingProvider?: TextEmbeddingModel
): VectorStore {
  return createSupabaseVectorStore(
    {
      url,
      key,
      tableName,
      embeddingColumnName: "embedding",
      contentColumnName: "content",
      metadataColumnName: "metadata",
    },
    embeddingProvider
  );
}

--- End File: packages/supabase/src/vector-store.ts ---

--- File: packages/supabase/tsconfig.build.json ---
{
  "extends": "./tsconfig.json",
  "include": ["src/**/*"],
  "exclude": ["**/*.test.ts", "**/*.spec.ts"]
}

--- End File: packages/supabase/tsconfig.build.json ---

--- File: packages/telegram/package.json ---
{
  "name": "@daydreamsai/telegram",
  "version": "0.3.6",
  "type": "module",
  "main": "./dist/index.js",
  "module": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "exports": {
    "./package.json": "./package.json",
    ".": {
      "types": "./dist/index.d.ts",
      "require": "./dist/index.js",
      "import": "./dist/index.js"
    }
  },
  "devDependencies": {
    "@types/bun": "latest",
    "tsup": "^8.3.6",
    "vitest": "^3.0.5"
  },
  "scripts": {
    "test": "vitest",
    "build": "tsup --dts-resolve"
  },
  "peerDependencies": {
    "typescript": "^5.6.3"
  },
  "dependencies": {
    "@daydreamsai/core": "workspace:*",
    "@telegraf/types": "^8.3.1",
    "telegraf": "^4.16.3",
    "zod": "^3.24.2"
  }
}

--- End File: packages/telegram/package.json ---

--- File: packages/telegram/src/index.ts ---
export * from "./telegram";

--- End File: packages/telegram/src/index.ts ---

--- File: packages/telegram/src/io.ts ---
import { z } from "zod";
import { context } from "@daydreamsai/core";
import { service } from "@daydreamsai/core";
import { Telegraf } from "telegraf";
import type { Chat } from "@telegraf/types";
import {
  extension,
  input,
  output,
  splitTextIntoChunks,
} from "@daydreamsai/core";
import { formatMsg } from "@daydreamsai/core";

const telegramService = service({
  register(container) {
    container.singleton(
      "telegraf",
      () => new Telegraf(process.env.TELEGRAM_TOKEN!)
    );
  },
  async boot(container) {
    const telegraf = container.resolve<Telegraf>("telegraf");
    console.log("starting..");
    telegraf.launch({ dropPendingUpdates: true });
    const telegrafInfo = await telegraf.telegram.getMe();
    console.log(telegrafInfo);
  },
});

const telegramChat = context({
  type: "telegram:chat",
  key: ({ chatId }) => chatId.toString(),
  schema: z.object({ chatId: z.number() }),
  async setup(args, {}, { container }) {
    const telegraf = container.resolve<Telegraf>("telegraf");
    const chat = await telegraf.telegram.getChat(args.chatId);
    return {
      chat: chat as Chat,
    };
  },
  description({ options: { chat } }) {
    if (chat.type === "private") {
      return `You are in private telegram chat with ${chat.username} id: ${chat.id}`;
    }
    return "";
  },
});

export const telegramExtension = extension({
  name: "telegram",
  services: [telegramService],
  contexts: {
    chat: telegramChat,
  },
  inputs: {
    "telegram:message": input({
      schema: z.object({
        user: z.object({ id: z.number(), username: z.string() }),
        text: z.string(),
      }),
      format: ({ data }) =>
        formatMsg({
          role: "user",
          content: data.text,
          user: data.user.username,
        }),
      subscribe(send, agent) {
        const { container } = agent;
        const telegraf = container.resolve("telegraf") as Telegraf;
        telegraf.on("message", (ctx: any) => {
          const chat = ctx.chat;
          const user = ctx.msg.from;

          if ("text" in ctx.message) {
            send(
              telegramChat,
              { chatId: chat.id },
              {
                user: {
                  id: user.id,
                  username: user.username!,
                },
                text: ctx.message.text,
              }
            );
          }
        });

        return () => {};
      },
    }),
  },
  outputs: {
    "telegram:message": output({
      schema: z.object({
        userId: z
          .string()
          .describe("the userId to send the message to, you must include this"),
        content: z.string().describe("the content of the message to send"),
      }),
      description: "use this to send a telegram message to user",
      enabled({ context }) {
        return context.type === telegramChat.type;
      },
      handler: async (data, ctx, { container }) => {
        const tg = container.resolve<Telegraf>("telegraf").telegram;
        const chunks = splitTextIntoChunks(data.content, {
          maxChunkSize: 4096,
        });

        for (const chunck of chunks) {
          await tg.sendMessage(data.userId, chunck);
        }

        return {
          data,
          timestamp: Date.now(),
        };
      },
    }),
  },
});

--- End File: packages/telegram/src/io.ts ---

--- File: packages/telegram/src/telegram.ts ---
import { z } from "zod";
import { context } from "@daydreamsai/core";
import { service } from "@daydreamsai/core";
import { Telegraf } from "telegraf";
import type { Chat } from "@telegraf/types";
import {
  extension,
  input,
  output,
  splitTextIntoChunks,
} from "@daydreamsai/core";
import { formatMsg } from "@daydreamsai/core";

const telegramService = service({
  register(container) {
    container.singleton(
      "telegraf",
      () => new Telegraf(process.env.TELEGRAM_TOKEN!)
    );
  },
  async boot(container) {
    const telegraf = container.resolve<Telegraf>("telegraf");
    console.log("starting..");
    telegraf.launch({ dropPendingUpdates: true });
    const telegrafInfo = await telegraf.telegram.getMe();
    console.log(telegrafInfo);
  },
});

const telegramChat = context({
  type: "telegram:chat",
  key: ({ chatId }) => chatId.toString(),
  schema: { chatId: z.number() },
  async setup(args, settings, { container }) {
    const telegraf = container.resolve<Telegraf>("telegraf");
    const chat: Chat = await telegraf.telegram.getChat(args.chatId);
    return {
      chat,
    };
  },
  description({ options: { chat } }) {
    if (chat.type === "private") {
      return `You are in private telegram chat with ${chat.username} id: ${chat.id}`;
    }
    return "";
  },
  inputs: {
    "telegram:message": input({
      schema: {
        user: z.object({ id: z.number(), username: z.string() }),
        text: z.string(),
      },
      format({ data: { user, text } }) {
        return {
          tag: "input",
          params: {
            type: "telegram:message",
            userId: user.id.toString(),
            username: user.username,
          },
          children: text,
        };
      },
      subscribe(send, { container }) {
        const tg = container.resolve<Telegraf>("telegraf");
        tg.on("message", (ctx) => {
          const chat = ctx.chat;
          const user = ctx.msg.from;

          if ("text" in ctx.message) {
            send(
              telegramChat,
              { chatId: chat.id },
              {
                user: {
                  id: user.id,
                  username: user.username!,
                },
                text: ctx.message.text,
              }
            );
          }
        });

        return () => {};
      },
    }),
  },
  outputs: {
    "telegram:message": output({
      attributes: {
        userId: z
          .string()
          .describe("the userId to send the message to, you must include this"),
      },
      schema: z
        .string()
        .describe("the content of the message to send using markdown format"),
      description: "use this to send a telegram message to user",
      examples: [
        `<output type="telegram:message" userId="123456789">Hello! How can I assist you today?</output>`,
      ],
      handler: async (data, ctx, { container }) => {
        const tg = container.resolve<Telegraf>("telegraf").telegram;
        const chunks = splitTextIntoChunks(data, {
          maxChunkSize: 4096,
        });

        for (const chunk of chunks) {
          await tg.sendMessage(ctx.outputRef.params!.userId, chunk, {
            parse_mode: "Markdown",
          });
        }

        return {
          data,
          timestamp: Date.now(),
        };
      },
    }),
  },
});

export const telegram = extension({
  name: "telegram",
  services: [telegramService],
  contexts: {
    chat: telegramChat,
  },
});

--- End File: packages/telegram/src/telegram.ts ---

--- File: packages/twitter/package.json ---
{
  "name": "@daydreamsai/twitter",
  "version": "0.3.6",
  "type": "module",
  "main": "./dist/index.js",
  "module": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "exports": {
    "./package.json": "./package.json",
    ".": {
      "types": "./dist/index.d.ts",
      "require": "./dist/index.js",
      "import": "./dist/index.js"
    }
  },
  "devDependencies": {
    "@types/bun": "latest",
    "tsup": "^8.3.6",
    "vitest": "^3.0.5"
  },
  "scripts": {
    "test": "vitest",
    "build": "tsup --dts-resolve"
  },
  "peerDependencies": {
    "typescript": "^5.6.3"
  },
  "dependencies": {
    "@daydreamsai/core": "workspace:*",
    "agent-twitter-client": "^0.0.18",
    "zod": "^3.24.2"
  }
}

--- End File: packages/twitter/package.json ---

--- File: packages/twitter/src/index.ts ---
export * from "./twitter";
export * from "./io";

--- End File: packages/twitter/src/index.ts ---

--- File: packages/twitter/src/io.ts ---
import { Scraper, SearchMode, type Tweet } from "agent-twitter-client";
import { Logger } from "@daydreamsai/core";
import { LogLevel } from "@daydreamsai/core";
import { z } from "zod";

const envSchema = z.object({
  TWITTER_USERNAME: z.string(),
  TWITTER_PASSWORD: z.string(),
  TWITTER_EMAIL: z.string(),
  DRY_RUN: z
    .preprocess((val) => val === "1" || val === "true", z.boolean())
    .default(true),
});

export interface TwitterCredentials {
  username: string;
  password: string;
  email: string;
}

export interface TweetData {
  content: string;
  inReplyTo?: string;
  conversationId?: string;
}

export class TwitterClient {
  private scraper: Scraper;
  private isInitialized: boolean = false;
  private lastCheckedTweetId: bigint | null = null;
  private logger: Logger;

  private env: z.infer<typeof envSchema>;
  constructor(
    private credentials: TwitterCredentials,
    logLevel: LogLevel = LogLevel.INFO
  ) {
    this.scraper = new Scraper();
    this.logger = new Logger({
      level: logLevel,
    });

    this.env = envSchema.parse(process.env);
  }

  async initialize() {
    if (!this.isInitialized) {
      try {
        await this.scraper.login(
          this.credentials.username,
          this.credentials.password,
          this.credentials.email
        );
        this.isInitialized = true;
        this.logger.info("TwitterClient", "Initialized successfully");
      } catch (error) {
        this.logger.error("TwitterClient", "Failed to initialize", {
          error,
        });
        throw error;
      }
    }
  }

  async checkMentions() {
    try {
      this.logger.debug("TwitterClient.checkMentions", "Checking mentions", {
        username: this.credentials.username,
      });

      const mentions = await this.scraper.fetchSearchTweets(
        `@${this.credentials.username}`,
        20,
        SearchMode.Latest
      );

      // Convert AsyncGenerator to array and process
      const mentionsArray: Tweet[] = [];
      for await (const tweet of mentions.tweets) {
        mentionsArray.push(tweet);
      }

      // Filter and format mentions
      const newMentions = mentionsArray
        .filter((tweet) => {
          // Skip own tweets and already processed tweets
          if (tweet.userId === this.credentials.username) {
            return false;
          }

          // Check if this is a new tweet we haven't seen
          if (
            this.lastCheckedTweetId &&
            BigInt(tweet.id ?? "") <= this.lastCheckedTweetId
          ) {
            return false;
          }

          // Update last checked ID if newer
          const tweetId = BigInt(tweet.id ?? "");
          if (!this.lastCheckedTweetId || tweetId > this.lastCheckedTweetId) {
            this.lastCheckedTweetId = tweetId;
          }

          return true;
        })
        .map(this.formatTweetData);

      // Only return if we have new mentions
      return newMentions.length > 0 ? newMentions : [];
    } catch (error) {
      this.logger.error(
        "TwitterClient.checkMentions",
        "Error checking mentions",
        { error }
      );
      throw error;
    }
  }

  async fetchUserTweets(username: string): Promise<Tweet[]> {
    const tweets: Tweet[] = [];
    try {
      for await (const tweet of this.scraper.getTweets(username, 10)) {
        tweets.push(tweet);
      }
    } catch (error) {
      this.logger.error(
        "TwitterClient.fetchUserTweets",
        "Error fetching tweets",
        { error }
      );
      throw error;
    }
    return tweets;
  }

  async sendTweet(data: TweetData) {
    try {
      this.logger.info("TwitterClient.sendTweet", "Would send tweet", {
        data,
      });

      if (this.env.DRY_RUN) {
        return {
          success: true,
          tweetId: "DRY RUN TWEET ID",
        };
      }

      const sendTweetResults = await this.scraper.sendTweet(
        data.content,
        data?.inReplyTo
      );

      return {
        success: true,
        tweetId: await sendTweetResults.json(),
      };
    } catch (error) {
      this.logger.error("TwitterClient.sendTweet", "Error sending tweet", {
        error,
      });
      throw error;
    }
  }

  private formatTweetData(tweet: Tweet) {
    return {
      type: "tweet",
      content: tweet.text ?? "",
      metadata: {
        tweetId: tweet.id,
        userId: tweet.userId,
        username: tweet.username,
        timestamp: new Date(tweet.timestamp ?? ""),
        metrics: {
          likes: tweet.likes,
          retweets: tweet.retweets,
          replies: tweet.replies,
        },
        isRetweet: tweet.isRetweet,
        isReply: tweet.isReply,
        hasMedia: tweet.photos.length > 0 || tweet.videos.length > 0,
        url: tweet.permanentUrl,
        conversationId: tweet.conversationId,
        inReplyToId: tweet.inReplyToStatusId,
      },
    };
  }
}

// Example usage:
/*
const twitter = new TwitterClient({
  username: "mybot",
  password: "pass",
  email: "bot@example.com"
});

// Register inputs
core.registerInput(twitter.createMentionsInput());
core.registerInput(twitter.createTimelineInput("elonmusk"));

// Register output
core.registerOutput(twitter.createTweetOutput());
*/

--- End File: packages/twitter/src/io.ts ---

--- File: packages/twitter/src/twitter.ts ---
import { z } from "zod";
import { context } from "@daydreamsai/core";
import { service } from "@daydreamsai/core";
import { TwitterClient } from "./io";
import { extension, input, output } from "@daydreamsai/core";
import { formatXml } from "@daydreamsai/core";

// Define Twitter context
const twitterContext = context({
  type: "twitter:thread",
  key: ({ tweetId }) => tweetId.toString(),
  schema: z.object({
    tweetId: z.string(),
  }),
});

// Twitter service setup
const twitterService = service({
  register(container) {
    container.singleton(
      "twitter",
      () =>
        new TwitterClient({
          username: process.env.TWITTER_USERNAME!,
          password: process.env.TWITTER_PASSWORD!,
          email: process.env.TWITTER_EMAIL!,
        })
    );
  },
  async boot(container) {
    const twitter = container.resolve<TwitterClient>("twitter");
    await twitter.initialize();
    console.log("Twitter client initialized");
  },
});

export const twitter = extension({
  name: "twitter",
  services: [twitterService],
  contexts: {
    twitter: twitterContext,
  },
  inputs: {
    "twitter:mentions": input({
      schema: z.object({
        userId: z.string(),
        tweetId: z.string(),
        text: z.string(),
      }),
      format: ({ data }) =>
        formatXml({
          tag: "tweet",
          params: { tweetId: data.tweetId },
          children: data.text,
        }),
      subscribe(send, agent) {
        const { container } = agent;

        const twitter = container.resolve("twitter") as TwitterClient;

        // Check mentions every minute
        const interval = setInterval(async () => {
          const mentions = await twitter.checkMentions();

          for (const mention of mentions) {
            console.log("Mention", mention);
            send(
              twitterContext,
              { tweetId: mention.metadata.tweetId || "" },
              {
                tweetId: mention.metadata.tweetId || "",
                userId: mention.metadata.userId || "",
                text: mention.content,
              }
            );
          }
        }, 10000);

        return () => clearInterval(interval);
      },
    }),
  },

  outputs: {
    "twitter:reply": output({
      schema: z.object({
        content: z.string().max(280),
        inReplyTo: z.string(),
      }),
      description: "Use this to reply to a tweet",

      handler: async (data, ctx, { container }) => {
        const twitter = container.resolve<TwitterClient>("twitter");
        const { tweetId } = await twitter.sendTweet({
          content: data.content,
          inReplyTo: data.inReplyTo,
        });

        return {
          data: {
            ...data,
            tweetId,
          },
          timestamp: Date.now(),
        };
      },
    }),

    "twitter:tweet": output({
      schema: z.object({
        content: z.string().max(280),
      }),
      description: "Use this to post a new tweet",

      handler: async (data, ctx, { container }) => {
        const twitter = container.resolve<TwitterClient>("twitter");
        await twitter.sendTweet({
          content: data.content,
        });
        return {
          data,
          timestamp: Date.now(),
        };
      },
    }),
  },
});

--- End File: packages/twitter/src/twitter.ts ---

